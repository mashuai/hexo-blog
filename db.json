{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/light/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0},{"_id":"themes/light/source/js/gallery.js","path":"js/gallery.js","modified":0},{"_id":"themes/light/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/light/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/light/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/light/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/light/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/light/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/light/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/light/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/light/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/light/source/css/font/fontawesome-webfont.woff","path":"css/font/fontawesome-webfont.woff","modified":0},{"_id":"themes/light/source/css/font/fontawesome-webfont.ttf","path":"css/font/fontawesome-webfont.ttf","modified":0},{"_id":"themes/light/source/css/font/fontawesome-webfont.svg","path":"css/font/fontawesome-webfont.svg","modified":0},{"_id":"themes/light/source/css/font/fontawesome-webfont.eot","path":"css/font/fontawesome-webfont.eot","modified":0}],"Cache":[{"_id":"source/_posts/Ansible-入门指南.md","shasum":"fa4105aa31bf90010278e932190aab757b8f8b90","modified":1447070568000},{"_id":"source/_posts/Go-Web-架构.md","shasum":"433c388f2ebc3c1a2160575046abd6ff8ecfde34","modified":1447158042000},{"_id":"source/_posts/http-Handler-与Go的错误处理.md","shasum":"b72f6f8b815996a3f4835211b05963b403fafb3b","modified":1447337415000},{"_id":"source/_posts/HTTP-2-和GO.md","shasum":"cce9c6cdd530225434945c1ca6e7824cc1eb0a3f","modified":1447301222000},{"_id":"source/_posts/为Go-Web-App-创建一个主页面.md","shasum":"0032e8f3a2af9ac053371d381a5220e59feb70f9","modified":1447496617000},{"_id":"source/_posts/Vagrant-Ansible-快速入门教程.md","shasum":"a9c244b89cce7839568ec8ad92147332b060a9a4","modified":1446973354000},{"_id":"source/_posts/Vagrant-入门指南.md","shasum":"2195d733d840fdb2f9af3794708e2a01d3bc3e07","modified":1446820549000},{"_id":"source/_posts/使用Go开发HTTP中间件.md","shasum":"cc7641e219c0f146d71aa195977ab0d810c70619","modified":1447305089000},{"_id":"themes/light/source/css/_base/utils.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1446804220000},{"_id":"themes/light/LICENSE","shasum":"c6f301bc722f0af3a55267a36c1c147aeddc6e46","modified":1446804220000},{"_id":"themes/light/README.md","shasum":"aa189c7ff03c60d8fceb009f5fca1a61d8a0ecdf","modified":1446804220000},{"_id":"themes/light/_config.yml","shasum":"35f36ea18cd436a788006984b84d05c01cf33884","modified":1446823034000},{"_id":"themes/light/languages/de.yml","shasum":"e076c7f2eb29ebcfb04d94861bf3063c4b08078c","modified":1446804220000},{"_id":"themes/light/languages/ru.yml","shasum":"35aadf8fdd28aaff8a1c8f50e80201dcf8ce0604","modified":1446804220000},{"_id":"themes/light/languages/default.yml","shasum":"fd7397be7789b43c1c163ab4faf106318811c2a8","modified":1446804220000},{"_id":"themes/light/languages/es.yml","shasum":"de273af604b27812cfd4195e7b7f28ceff2734b3","modified":1446804220000},{"_id":"themes/light/languages/zh-CN.yml","shasum":"ca0118e9081b54cc0fca8596660bd6acf4c0308f","modified":1446804220000},{"_id":"themes/light/layout/_partial/after_footer.ejs","shasum":"288cc67f0aa57d164f65c03d216dcc29b0384571","modified":1446986093000},{"_id":"themes/light/layout/_partial/archive.ejs","shasum":"7e4f7c2909b1b90241424ea2ff8e7b4761d8360f","modified":1446804220000},{"_id":"themes/light/layout/_partial/article.ejs","shasum":"508fb3aaac2b68e6f24bd5259a0684e23f46fe37","modified":1446804220000},{"_id":"themes/light/layout/_partial/comment.ejs","shasum":"be7d9849855f2bb31e626db88b49ac1d87446e21","modified":1446804220000},{"_id":"themes/light/layout/_partial/facebook_comment.ejs","shasum":"3fdc1d0ce9177825e7417635fbc545a35d528d04","modified":1446804220000},{"_id":"themes/light/layout/_partial/footer.ejs","shasum":"1deac5914b2fc93b271732fd4d5cbd0a6f78875f","modified":1446804220000},{"_id":"themes/light/layout/_partial/google_analytics.ejs","shasum":"7cf0d1f93051bda510d49dab7f684b9d7c6ba58f","modified":1446804220000},{"_id":"themes/light/layout/_partial/head.ejs","shasum":"5e110e4b0a2a896a073dfc7739220025b02a4077","modified":1446804220000},{"_id":"themes/light/layout/_partial/header.ejs","shasum":"d9a99aca97d8b41ed907fbf5b25df05da3ffa4f6","modified":1446804220000},{"_id":"themes/light/layout/_partial/pagination.ejs","shasum":"1206b630a07444e8744365f14ddb26095c925ae1","modified":1446804220000},{"_id":"themes/light/layout/_partial/post/category.ejs","shasum":"be740939c5c2d4ffdbed9557b4e63a590058b476","modified":1446804220000},{"_id":"themes/light/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1446804220000},{"_id":"themes/light/layout/_partial/post/share.ejs","shasum":"24c04b319f1b19e887c42db961b90a7e0ab26fdc","modified":1446804220000},{"_id":"themes/light/layout/_partial/post/tag.ejs","shasum":"095418df66a27a28cbab16d7cb0d16001b0e23f1","modified":1446804220000},{"_id":"themes/light/layout/_partial/post/title.ejs","shasum":"d7fbc575d35ae68f9045a382c651450e4131f335","modified":1446804220000},{"_id":"themes/light/layout/_partial/sidebar.ejs","shasum":"caf351797a18d03d8ee945ceb9f83785c50c09f9","modified":1446804220000},{"_id":"themes/light/layout/_widget/category.ejs","shasum":"8a2b90dc29661371f060f710668929c3588e15e4","modified":1446804220000},{"_id":"themes/light/layout/_widget/recent_posts.ejs","shasum":"f17d2cb69034acabea4df54f301f80812e7b84a8","modified":1446804220000},{"_id":"themes/light/layout/_widget/search.ejs","shasum":"55c707f3aa7453c305c41898ad22556edd213830","modified":1446804220000},{"_id":"themes/light/layout/_widget/tag.ejs","shasum":"1914db78bea49c333067d79fe7ad9567d2b08d00","modified":1446804220000},{"_id":"themes/light/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1446804220000},{"_id":"themes/light/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1446804220000},{"_id":"themes/light/layout/_widget/tagcloud.ejs","shasum":"a236c86481196ae43206e056ba78cec14f1ac014","modified":1446804220000},{"_id":"themes/light/layout/layout.ejs","shasum":"72da76881ebf00e71d7cc196f377e37a17ec7a6f","modified":1446804220000},{"_id":"themes/light/layout/index.ejs","shasum":"e569d8fe0741a24efb89e44781f9e616da17e036","modified":1446804220000},{"_id":"themes/light/layout/page.ejs","shasum":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1446804220000},{"_id":"themes/light/layout/post.ejs","shasum":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1446804220000},{"_id":"themes/light/source/css/_base/variable.styl","shasum":"6f3ad13e49634dae8cd992bbd598f5ff0b39a816","modified":1446804220000},{"_id":"themes/light/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1446804220000},{"_id":"themes/light/source/css/_base/layout.styl","shasum":"1b58c21aa48a8f9f7f811af681ac182dd058e23d","modified":1446804220000},{"_id":"themes/light/source/css/_partial/archive.styl","shasum":"072e9b8c5ee9acf95ac7cce9c34706d41e412229","modified":1446804220000},{"_id":"themes/light/source/css/_partial/footer.styl","shasum":"1757872dbdbd09295a625f13e356aa798a8bb308","modified":1446804220000},{"_id":"themes/light/source/css/_partial/header.styl","shasum":"50d36fe0c803cbba69dd57493611466e4d72156e","modified":1446804220000},{"_id":"themes/light/source/css/_partial/article.styl","shasum":"3750f8cb4208941864247224f1dc7a256992ba8b","modified":1446804220000},{"_id":"themes/light/source/css/_partial/comment.styl","shasum":"e7f8c085bfa8c26afc4b2fbc9f2092f4f07aef34","modified":1446804220000},{"_id":"themes/light/source/css/_partial/index.styl","shasum":"7a8c0ec6ab99a9f8e00c9687aca29d31752424a2","modified":1446804220000},{"_id":"themes/light/source/css/_partial/syntax.styl","shasum":"8d20eb41b8ba290b6c7d520c4f2d88bb9b51d60e","modified":1446804220000},{"_id":"themes/light/source/css/_partial/sidebar.styl","shasum":"a8bf5237d7d2fba66988cfb85a3ae218be8709ae","modified":1446804220000},{"_id":"themes/light/source/css/font/fontawesome-webfont.eot","shasum":"d775f599ff3f23be082e6a9604b4898718923a37","modified":1446804220000},{"_id":"themes/light/source/css/style.styl","shasum":"c03b2520e4a85b981e29516cadc0a365e6500e3d","modified":1446804220000},{"_id":"themes/light/source/css/font/fontawesome-webfont.woff","shasum":"0612cddf2f835cceffccc88fd194f97367d0b024","modified":1446804220000},{"_id":"themes/light/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1446804220000},{"_id":"themes/light/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1446804220000},{"_id":"themes/light/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1446804220000},{"_id":"themes/light/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1446804220000},{"_id":"themes/light/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1446804220000},{"_id":"themes/light/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1446804220000},{"_id":"themes/light/source/fancybox/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1446804220000},{"_id":"themes/light/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1446804220000},{"_id":"themes/light/source/fancybox/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1446804220000},{"_id":"themes/light/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1446804220000},{"_id":"themes/light/source/css/font/fontawesome-webfont.ttf","shasum":"a9468f6a1fe965fbcaf5a1bd6c11705e2fc5f84c","modified":1446804220000},{"_id":"themes/light/source/css/font/fontawesome-webfont.svg","shasum":"d162419c91b8bab3a4fd327c933a0fcf3799c251","modified":1446804220000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Ansible 入门指南","date":"2015-11-09T10:26:35.000Z","_content":"\n[原文地址](http://docs.ansible.com/ansible/intro_getting_started.html)\n\n## 快速入门\n\n### 前言\n\n&emsp;&emsp; 现在你已经知道如何[安装](http://docs.ansible.com/ansible/intro_installation.html)Ansible了，现在可以深入并开始使用Ansible的一些命令了。\n&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。\n&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读[特别命令简介](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。\n\n### 远程连接信息\n\n&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。\n&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。[加速功能](http://docs.ansible.com/ansible/playbooks_acceleration.html)。\n&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。\n&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在[配置文件](http://docs.ansible.com/ansible/intro_configuration.html)中切换到SCP模式。\n&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数`--ask-pass`。如果需要使用sudo权限，那么也要提供`--ask-sudo-pass`参数。\n&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。\n&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。\n\n### 第一个命令\n\n&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。\n&emsp;&emsp; 编辑（或者创建）`/etc/ansible/hosts`文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的`authorized_keys`文件中。\n\n```\n192.168.1.50\naserver.example.org\nbserver.example.org\n```\n\n&emsp;&emsp; 这是一个清单文件，同样会再[主机清单](http://docs.ansible.com/ansible/intro_inventory.html)中介绍。\n&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。\n\n```\nssh-agent bash\nssh-add ~/.ssh/id_rsa\n```\n\n(根据你的设置，你可能需要使用`--private-key`选项来制定一个pem文件)\n&emsp;&emsp; 现在可以ping一下所有的主机了。\n\n```\nansible all -m ping\n```\n\n&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上`-u`的选项。\n&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上`--sudo`选项。\n\n```\n# as bruce\n$ ansible all -m ping -u bruce\n# as bruce sudoing to root\n$ ansible all -m ping -u bruce --sudo\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce --sudo --sudo-user batman\n\n# With latest version of ansible `sudo` is deprecated so use become\n# as bruce, sudoing to root\n$ ansible all -m ping -u bruce -b\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce -b --become-user batman\n```\n\n(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)\n\n&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。\n\n```\n$ ansible all -a \"/bin/echo hello\"\n```\n\n&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读[更多命令介绍](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible [Playbooks](http://docs.ansible.com/ansible/playbooks.html)的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。\n\n### 主机密钥检查\n\n&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。\n&emsp;&emsp; 如果远程主机成新安装并且在`know_hosts`下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在`know_hosts`文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。\n&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改`/etc/ansible/ansible.cfg`或者是`~/.ansible.cfg`来关闭这个功能。\n\n```\n[default]\nhost_key_checking = False\n```\n\n&emsp;&emsp; 同样也可以通过环境变量来修改。\n\n```\n$ export ANSIBLE_HOST_KEY_CHECKING=False\n```\n\n&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。\n&emsp;&emsp; 除非Ansible的任务被标记为\"no_log:True\"，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。\n&emsp;&emsp; 如果要再本机开启log可以查看[配置章节](http://docs.ansible.com/ansible/intro_configuration.html)来设置“log_path”开启。企业用户可能会对[Ansible Tower](http://docs.ansible.com/ansible/tower.html)。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。\n","source":"_posts/Ansible-入门指南.md","raw":"title: Ansible 入门指南\ndate: 2015-11-09 18:26:35\ntags:\n  - Ansible\n  - Translate\n---\n\n[原文地址](http://docs.ansible.com/ansible/intro_getting_started.html)\n\n## 快速入门\n\n### 前言\n\n&emsp;&emsp; 现在你已经知道如何[安装](http://docs.ansible.com/ansible/intro_installation.html)Ansible了，现在可以深入并开始使用Ansible的一些命令了。\n&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。\n&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读[特别命令简介](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。\n\n### 远程连接信息\n\n&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。\n&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。[加速功能](http://docs.ansible.com/ansible/playbooks_acceleration.html)。\n&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。\n&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在[配置文件](http://docs.ansible.com/ansible/intro_configuration.html)中切换到SCP模式。\n&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数`--ask-pass`。如果需要使用sudo权限，那么也要提供`--ask-sudo-pass`参数。\n&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。\n&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。\n\n### 第一个命令\n\n&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。\n&emsp;&emsp; 编辑（或者创建）`/etc/ansible/hosts`文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的`authorized_keys`文件中。\n\n```\n192.168.1.50\naserver.example.org\nbserver.example.org\n```\n\n&emsp;&emsp; 这是一个清单文件，同样会再[主机清单](http://docs.ansible.com/ansible/intro_inventory.html)中介绍。\n&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。\n\n```\nssh-agent bash\nssh-add ~/.ssh/id_rsa\n```\n\n(根据你的设置，你可能需要使用`--private-key`选项来制定一个pem文件)\n&emsp;&emsp; 现在可以ping一下所有的主机了。\n\n```\nansible all -m ping\n```\n\n&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上`-u`的选项。\n&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上`--sudo`选项。\n\n```\n# as bruce\n$ ansible all -m ping -u bruce\n# as bruce sudoing to root\n$ ansible all -m ping -u bruce --sudo\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce --sudo --sudo-user batman\n\n# With latest version of ansible `sudo` is deprecated so use become\n# as bruce, sudoing to root\n$ ansible all -m ping -u bruce -b\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce -b --become-user batman\n```\n\n(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)\n\n&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。\n\n```\n$ ansible all -a \"/bin/echo hello\"\n```\n\n&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读[更多命令介绍](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible [Playbooks](http://docs.ansible.com/ansible/playbooks.html)的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。\n\n### 主机密钥检查\n\n&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。\n&emsp;&emsp; 如果远程主机成新安装并且在`know_hosts`下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在`know_hosts`文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。\n&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改`/etc/ansible/ansible.cfg`或者是`~/.ansible.cfg`来关闭这个功能。\n\n```\n[default]\nhost_key_checking = False\n```\n\n&emsp;&emsp; 同样也可以通过环境变量来修改。\n\n```\n$ export ANSIBLE_HOST_KEY_CHECKING=False\n```\n\n&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。\n&emsp;&emsp; 除非Ansible的任务被标记为\"no_log:True\"，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。\n&emsp;&emsp; 如果要再本机开启log可以查看[配置章节](http://docs.ansible.com/ansible/intro_configuration.html)来设置“log_path”开启。企业用户可能会对[Ansible Tower](http://docs.ansible.com/ansible/tower.html)。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。\n","slug":"Ansible-入门指南","published":1,"updated":"2015-11-09T12:02:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8up0000oz9kv7lzt6ao"},{"title":"使用Go开发HTTP中间件","date":"2015-11-12T04:07:49.000Z","_content":"[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n&emsp;&emsp; 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n&emsp;&emsp; 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n&emsp;&emsp; 首先我们定义一个结构体，叫做`SingleHost`\n\n```\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n&emsp;&emsp; 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n&emsp;&emsp; 实现如下：\n\n```\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n```\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n&emsp;&emsp; 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n&emsp;&emsp; 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n&emsp;&emsp; 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n&emsp;&emsp; 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n&emsp;&emsp;最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n&emsp;&emsp; 数据由Token设置：\n\n```\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n&emsp;&emsp;源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","source":"_posts/使用Go开发HTTP中间件.md","raw":"title: 使用Go开发HTTP中间件\ndate: 2015-11-12 12:07:49\ntags:\n  - HTTP\n  - Go\n  - Middleware\n---\n[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n&emsp;&emsp; 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n&emsp;&emsp; 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n&emsp;&emsp; 首先我们定义一个结构体，叫做`SingleHost`\n\n```\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n&emsp;&emsp; 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n&emsp;&emsp; 实现如下：\n\n```\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n```\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n&emsp;&emsp; 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n&emsp;&emsp; 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n&emsp;&emsp; 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n&emsp;&emsp; 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n&emsp;&emsp;最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n&emsp;&emsp; 数据由Token设置：\n\n```\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n&emsp;&emsp;源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","slug":"使用Go开发HTTP中间件","published":1,"updated":"2015-11-12T05:11:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8vl0005oz9k0xtd6e1t"},{"title":"为Go Web App 创建一个主页面","date":"2015-11-14T09:59:00.000Z","_content":"\n\n[原文地址](http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html)\n\n&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n&emsp;&emsp; 这个简单的例子来解释如何实现的：\n&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n&emsp;&emsp; header模板的代码如下：\n\n``` Go\n{{ define \"header\" }}\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>{{.Title}}</title>\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\">\n        <style type=\"text/css\">\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        </style>\n    </head>\n    <body>\n        <nav class=\"navbar navbar-default\" role=\"navigation\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"/\">Go App</a>\n          </div>\n          <div class=\"collapse navbar-collapse navbar-ex1-collapse\">  \n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Main</a></li>\n                <li><a href=\"/about\">About</a></li>\n            </ul>\n          </div>\n        </nav>\n{{ end }}\n``\n```\n\n&emsp;&emsp; footer模板的代码如下：\n\n\n``` Go\n{{ define \"footer\" }}\n        <p class=\"navbar-text navbar-fixed-bottom\">Go Rocks!</p>    \n        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"></script>\n    </body>\n</html>\n{{ end }}\n\n```\n\n&emsp;&emsp; main 模板的代码如下：\n\n```\n{{define \"main\"}}\n{{template \"header\" .}}\n<div class=\"content\">\n    <h2>Main</h2>\n    <div>This is the Main page</div>\n</div>\n{{template \"footer\" .}}\n{{end}}\n```\n\n&emsp;&emsp; about 模板的代码如下：\n\n```\n{{define \"about\"}}\n{{template \"header\" .}}\n<div class=\"content\">\n    <h2>About</h2>\n    <div>This is the About page</div>\n</div>\n{{template \"footer\" .}}\n{{end}}\n```\n\n&emsp;&emsp; 服务器代码如下：\n\n```\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(\"header.html\", \"footer.html\", \"main.html\", \"about.html\"))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"main\", &Page{Title: \"Home\"})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"about\", &Page{Title: \"About\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", mainHandler)\n    http.HandleFunc(\"/about\", aboutHandler)\n\n    //Listen on port 8080\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n&emsp;&emsp; 每一个模板页都有一个 `{{ define \"name\" }}`的命令来定义模板的名字。main和about页面通过`{{ template \"name\" }}`来包含header和footer。`.` 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n&emsp;&emsp; 两个页面的结果如下：\n\n![main](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png)  \n![about](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png)  \n","source":"_posts/为Go-Web-App-创建一个主页面.md","raw":"title: 为Go Web App 创建一个主页面\ndate: 2015-11-14 17:59:00\ntags:\n  - Go\n  - Translate\n---\n\n\n[原文地址](http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html)\n\n&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n&emsp;&emsp; 这个简单的例子来解释如何实现的：\n&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n&emsp;&emsp; header模板的代码如下：\n\n``` Go\n{{ define \"header\" }}\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>{{.Title}}</title>\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\">\n        <style type=\"text/css\">\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        </style>\n    </head>\n    <body>\n        <nav class=\"navbar navbar-default\" role=\"navigation\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"/\">Go App</a>\n          </div>\n          <div class=\"collapse navbar-collapse navbar-ex1-collapse\">  \n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Main</a></li>\n                <li><a href=\"/about\">About</a></li>\n            </ul>\n          </div>\n        </nav>\n{{ end }}\n``\n```\n\n&emsp;&emsp; footer模板的代码如下：\n\n\n``` Go\n{{ define \"footer\" }}\n        <p class=\"navbar-text navbar-fixed-bottom\">Go Rocks!</p>    \n        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"></script>\n    </body>\n</html>\n{{ end }}\n\n```\n\n&emsp;&emsp; main 模板的代码如下：\n\n```\n{{define \"main\"}}\n{{template \"header\" .}}\n<div class=\"content\">\n    <h2>Main</h2>\n    <div>This is the Main page</div>\n</div>\n{{template \"footer\" .}}\n{{end}}\n```\n\n&emsp;&emsp; about 模板的代码如下：\n\n```\n{{define \"about\"}}\n{{template \"header\" .}}\n<div class=\"content\">\n    <h2>About</h2>\n    <div>This is the About page</div>\n</div>\n{{template \"footer\" .}}\n{{end}}\n```\n\n&emsp;&emsp; 服务器代码如下：\n\n```\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(\"header.html\", \"footer.html\", \"main.html\", \"about.html\"))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"main\", &Page{Title: \"Home\"})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"about\", &Page{Title: \"About\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", mainHandler)\n    http.HandleFunc(\"/about\", aboutHandler)\n\n    //Listen on port 8080\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n&emsp;&emsp; 每一个模板页都有一个 `{{ define \"name\" }}`的命令来定义模板的名字。main和about页面通过`{{ template \"name\" }}`来包含header和footer。`.` 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n&emsp;&emsp; 两个页面的结果如下：\n\n![main](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png)  \n![about](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png)  \n","slug":"为Go-Web-App-创建一个主页面","published":1,"updated":"2015-11-14T10:23:37.000Z","_id":"cigyxr8vn000coz9k9hxu1p37","comments":1,"layout":"post","photos":[],"link":""},{"title":"http.Handler 与Go的错误处理","date":"2015-11-12T13:24:57.000Z","_content":"\n[原文地址](http://elithrar.github.io/article/http-handler-error-handling-revisited/)\n\n&emsp;&emsp; 在之前我写过一篇关于通过使用`http.HandlerFunc`来实现一个定制handler类型用来避免一些平常的错误的[文章](http://elithrar.github.io/article/custom-handlers-avoiding-globals/)。`func MyHandler(w http.ResponseWriter, r *http.Request)`的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n* 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n* 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用`log.Printf`，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n&emsp;&emsp; 我以前的方法中使用了`func(http.ResponseWriter, *http.Request)`签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n```\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\n    if user.LoggedIn {\n        http.Redirect(w, r, \"/dashboard\", 302)\n        // Superfluous! Our http.Redirect function handles the 302, not \n        // our return value (which is effectively ignored).\n        return 302, nil\n    }\n\n}\n```\n\n&emsp;&emsp;看起来还行，但是我们可以做的更好\n\n### 一些区别\n\n&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：\n\n```\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n```\n\n&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n* 我们自定义了一个`Error`类型（接口），他内嵌了Go的内建的error接口，同时提供了一个`Status() int`方法。\n* 我们提供了一个简单的`StatusError`类型（结构体），它满足`handler.Error`的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。\n* 我们的`ServeHTTP`方法包好了一个\"e := err.(type)\"的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个`handler.Error`类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。\n\n&emsp;&emsp; 如果我们不想捕捉那些错误，那么`default`将会默认捕捉到。记住一点，`ServeHTTP`可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n### 所有示例\n\n&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n```\npackage handler\n\nimport (\n    \"net/http\"\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It's also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\n    fmt.Fprintf(w, \"%+v\", users)\n    return nil\n}\n```\n\n&emsp;&emsp; main包：\n\n```\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/you/somepkg/handler\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"connectionstringhere\")\n    if err != nil {\n          log.Fatal(err)\n    }\n\n    // Initialise our app-wide environment with the services/info we need.\n    env := &handler.Env{\n        DB: db,\n        Port: os.Getenv(\"PORT\"),\n        Host: os.Getenv(\"HOST\"),\n        // We might also have a custom log.Logger, our \n        // template instance, and a config struct as fields \n        // in our Env struct.\n    }\n\n    // Note that we're using http.Handle, not http.HandleFunc. The \n    // latter only accepts the http.HandlerFunc type, which is not \n    // what we have here.\n    http.Handle(\"/\", handler.Handler{env, handler.GetIndex})\n\n    // Logs the error if ListenAndServe fails.\n    log.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n```\n\n&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。\n\n","source":"_posts/http-Handler-与Go的错误处理.md","raw":"title: http.Handler 与Go的错误处理\ndate: 2015-11-12 21:24:57\ntags:\n  - Go\n  - Translate\n---\n\n[原文地址](http://elithrar.github.io/article/http-handler-error-handling-revisited/)\n\n&emsp;&emsp; 在之前我写过一篇关于通过使用`http.HandlerFunc`来实现一个定制handler类型用来避免一些平常的错误的[文章](http://elithrar.github.io/article/custom-handlers-avoiding-globals/)。`func MyHandler(w http.ResponseWriter, r *http.Request)`的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n* 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n* 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用`log.Printf`，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n&emsp;&emsp; 我以前的方法中使用了`func(http.ResponseWriter, *http.Request)`签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n```\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\n    if user.LoggedIn {\n        http.Redirect(w, r, \"/dashboard\", 302)\n        // Superfluous! Our http.Redirect function handles the 302, not \n        // our return value (which is effectively ignored).\n        return 302, nil\n    }\n\n}\n```\n\n&emsp;&emsp;看起来还行，但是我们可以做的更好\n\n### 一些区别\n\n&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：\n\n```\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n```\n\n&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n* 我们自定义了一个`Error`类型（接口），他内嵌了Go的内建的error接口，同时提供了一个`Status() int`方法。\n* 我们提供了一个简单的`StatusError`类型（结构体），它满足`handler.Error`的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。\n* 我们的`ServeHTTP`方法包好了一个\"e := err.(type)\"的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个`handler.Error`类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。\n\n&emsp;&emsp; 如果我们不想捕捉那些错误，那么`default`将会默认捕捉到。记住一点，`ServeHTTP`可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n### 所有示例\n\n&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n```\npackage handler\n\nimport (\n    \"net/http\"\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It's also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\n    fmt.Fprintf(w, \"%+v\", users)\n    return nil\n}\n```\n\n&emsp;&emsp; main包：\n\n```\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/you/somepkg/handler\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"connectionstringhere\")\n    if err != nil {\n          log.Fatal(err)\n    }\n\n    // Initialise our app-wide environment with the services/info we need.\n    env := &handler.Env{\n        DB: db,\n        Port: os.Getenv(\"PORT\"),\n        Host: os.Getenv(\"HOST\"),\n        // We might also have a custom log.Logger, our \n        // template instance, and a config struct as fields \n        // in our Env struct.\n    }\n\n    // Note that we're using http.Handle, not http.HandleFunc. The \n    // latter only accepts the http.HandlerFunc type, which is not \n    // what we have here.\n    http.Handle(\"/\", handler.Handler{env, handler.GetIndex})\n\n    // Logs the error if ListenAndServe fails.\n    log.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n```\n\n&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。\n\n","slug":"http-Handler-与Go的错误处理","published":1,"updated":"2015-11-12T14:10:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8vp000foz9kxojy6rx6"},{"title":"Vagrant 入门指南","date":"2015-11-06T08:49:47.000Z","_content":"[原文地址](https://docs.vagrantup.com/v2/getting-started/index.html)\n## 开始\n\n&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。  \n&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下[Why Vagrant](https://docs.vagrantup.com/v2/why-vagrant/)。  \n&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的[提供商](https://docs.vagrantup.com/v2/getting-started/providers.html)\n\n> 更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O'Reilly 出版的[Vagrant: Up and Running](http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449335837&linkCode=as2&tag=vagrant-20) 更感兴趣，\n\n## 启动运行\n\n```\n$ vagrant init hashicorp/precise32\n$ vagrant up\n```\n\n&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过`vagrant ssh` 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用`vagrant destory`来删除所有的痕迹。  \n&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。    \n&emsp;&emsp;通过使用Vagrant,对于任何项目来说`vagrant up` 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。    \n&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  \n\n## 项目配置\n\n&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个[Vagrantfile](https://docs.vagrantup.com/v2/vagrantfile/)。该文件的作用有两个:  \n1. 指定项目的根目录。很多Vagrant的配置跟这个目录有关。  \n2. 描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  \n\n&emsp;&emsp; Vagrant 有一个内建的命令`vagrant init`用来初始化项目。出于本指南的目的，请在终端输入一下命令  \n\n```\n$ mkdir vagrant_getting_started\n$ cd vagrant_getting_started\n$ vagrant init\n```\n\n&emsp;&emsp; 以上命令将在你的当前目录下创建`Vagrantfile`。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。  \n&emsp;&emsp; 同样也可以在一个已存在的目录下运行`vagrant init`，来未一个已有项目设置Vagrant环境。\n&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。\n\n## Boxes\n\n&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  \n\n###  安装box\n\n&emsp;&emsp; 如果你运行了[开始指南](https://docs.vagrantup.com/v2/getting-started/)的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。  \n&emsp;&emsp; Boxes 由Vagrant的`vagrant box add`命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  \n\n```\n$ vagrant box add hashicorp/precise32\n```\n\n&emsp;&emsp; 这个将从[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)下载一个名字为`hashicorp/precise32`的box。你可以从HashiCorp's Atlas box catalog中找到各种box。很容易从HashiCorp's Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。\n&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的`hashicorp/precise32`的box，其中一个主机添加文件并不会影响另一个主机。  \n\n### 使用box\n\n&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\nend\n```\n&emsp;&emsp; 在这个例子中，\"hashicorp/precise32\" 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。  \n&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  \n\n### 寻找更多box\n\n&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的\"hashicorp/precise32\"的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。  \n&emsp;&emsp; 寻找更多box的最好的地方是[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。  \n&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。  \n&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  \n\n## 启动并且SSH登陆\n\n&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  \n\n```\nvagrant up\n```\n\n&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：\n\n```\nvagrant ssh\n```\n\n&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心`rm -rf /` 这种命令，因为Vagrant的`/vagrant`目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。  \n&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。  \n&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用`vagrant destory`来清除你再虚拟机的痕迹。\n\n## 同步文件夹\n\n&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用*同步文件夹*Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。  \n&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的`/vagrant`的。再次运行`vagrant up` 并且ssh到虚拟机。\n\n```\n$ vagrant up\n...\n$ vagrant ssh\n...\nvagrant@precise32:~$ ls /vagrant\nVagrantfile\n```\n\n&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：\n\n```\nvagrant@precise32:~$ touch /vagrant/foo\nvagrant@precise32:~$ exit\n$ ls\nfoo Vagrantfile\n```\n\n&emsp;&emsp; 哇！`foo`已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。  \n&emsp;&emsp; 通过使用[同步文件夹](https://docs.vagrantup.com/v2/synced-folders/)，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。\n\n## 配置\n\n&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。  \n&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你`vagrant up`的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  \n\n### 安装Apache\n\n&emsp;&emsp; 对于我们的项目来说可以仅仅使用[Apache](http://httpd.apache.org/)，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为`bootstrap.sh`的文件。  \n\n```\n#!/usr/bin/env bash\n\napt-get update\napt-get install -y apache2\nif ! [ -L /var/www ]; then\n  rm -rf /var/www\n  ln -fs /vagrant /var/www\nfi \n```\n\n&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\nend\n```\n\n&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用`shell`配置器运行`bootstrap.sh`脚本启动机器。脚本的路径是项目更目录的相对路径。\n\n### 配置\n\n&emsp;&emsp; 在所有的事情都配置好好，运行`vagrant up`来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行`vagrant reload --provision`, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。`--provision`表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。\n&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。\n\n```\n$ vagrant ssh\n...\nvagrant@precise32:~$ wget -qO- 127.0.0.1\n```\n\n&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的`DocumentRoot`指向了`/vagrant`。\n&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。\n\n## 网络\n\n&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。\n\n### 端口转发\n\n&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。\n&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\n  config.vm.network :forwarded_port, guest: 80, host: 4567\nend\n```\n\n&emsp;&emsp; 运行`vagrant reload`，或者如果没有启动过虚拟机运行`vagrant up`。使配置生效。\n\n### 其他的网络配置\n\n&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读[networking](https://docs.vagrantup.com/v2/networking/)章节。\n\n## 共享\n\n&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做[Vagrant Share](https://docs.vagrantup.com/v2/share/)。\n&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。\n\n### 登录Harshicorp's Altas\n\n&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个[HashiCorp's Altas](https://atlas.hashicorp.com/)的账号。不必担心，它是免费的。\n&emsp;&emsp; 当你有了账号后，你就可以使用`vagrant login`来登陆\n\n```\n$ vagrant login\nUsername or Email: mitchellh\nPassword (will be hidden):\nYou're now logged in!\n```\n\n### 共享\n\n&emsp;&emsp; 当你登录之后，你就可以使用`vagrant share`来共享环境了。\n\n```\n$ vagrant share\n...\n==> default: Your Vagrant Share is running!\n==> default: URL: http://frosty-weasel-0857.vagrantshare.com\n...\n```\n\n&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面`vagrant share`生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。\n&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。\n&emsp;&emsp; 关闭共享只需要使用`Ctrl+C`即可，重新刷新URL，你会发现你的环境已经不再被共享了。\n&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的[Vagrant Share](https://docs.vagrantup.com/v2/share/)文档。\n\n## 关闭\n\n&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。\n&emsp;&emsp; 通过Vagrant，我们可以*suspend*,*halt*或者*destory*虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  \n* **suspend** 使用`vagrant suspend`命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用`vagrant up`命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  \n* **halting** 使用`vagrant halt`命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行`vagrant up`命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。\n* **destory** 使用`vagrant destory`命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用`vagrant up`的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是`vagrant up`将会从头开始，这样会花费更长的时间。\n\n## 重新构建\n\n&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过`vagrant up`来轻松运行他。\n&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行`vagrant up`即可重新创建相同的环境。\n\n### Provider\n\n&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如[VMware](https://docs.vagrantup.com/v2/vmware/),[AWS](http://github.com/mitchellh/vagrant-aws)等。继续阅读来了解如何它们的更多信息以及如何使用它们。\n&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：\n\n```\n$ vagrant up --provider=vmware_fusion\n```\n\n准备转移到云端了？使用AWS：\n\n```\n$ vagrant up --provider=aws\n```\n\n&emsp;&emsp; 当你使用其他Provider运行`vagrant up`的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：`vagrant destory`，无需额外的参数。\n&emsp;&emsp; 更多信息请参考[provider](https://docs.vagrantup.com/v2/providers/)。\n[1]: https://www.virtualbox.org/\n\n\n","source":"_posts/Vagrant-入门指南.md","raw":"title: Vagrant 入门指南\ndate: 2015-11-06 16:49:47\ntags:\n  - Vagrant \n  - Translate\n---\n[原文地址](https://docs.vagrantup.com/v2/getting-started/index.html)\n## 开始\n\n&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。  \n&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下[Why Vagrant](https://docs.vagrantup.com/v2/why-vagrant/)。  \n&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的[提供商](https://docs.vagrantup.com/v2/getting-started/providers.html)\n\n> 更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O'Reilly 出版的[Vagrant: Up and Running](http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449335837&linkCode=as2&tag=vagrant-20) 更感兴趣，\n\n## 启动运行\n\n```\n$ vagrant init hashicorp/precise32\n$ vagrant up\n```\n\n&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过`vagrant ssh` 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用`vagrant destory`来删除所有的痕迹。  \n&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。    \n&emsp;&emsp;通过使用Vagrant,对于任何项目来说`vagrant up` 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。    \n&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  \n\n## 项目配置\n\n&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个[Vagrantfile](https://docs.vagrantup.com/v2/vagrantfile/)。该文件的作用有两个:  \n1. 指定项目的根目录。很多Vagrant的配置跟这个目录有关。  \n2. 描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  \n\n&emsp;&emsp; Vagrant 有一个内建的命令`vagrant init`用来初始化项目。出于本指南的目的，请在终端输入一下命令  \n\n```\n$ mkdir vagrant_getting_started\n$ cd vagrant_getting_started\n$ vagrant init\n```\n\n&emsp;&emsp; 以上命令将在你的当前目录下创建`Vagrantfile`。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。  \n&emsp;&emsp; 同样也可以在一个已存在的目录下运行`vagrant init`，来未一个已有项目设置Vagrant环境。\n&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。\n\n## Boxes\n\n&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  \n\n###  安装box\n\n&emsp;&emsp; 如果你运行了[开始指南](https://docs.vagrantup.com/v2/getting-started/)的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。  \n&emsp;&emsp; Boxes 由Vagrant的`vagrant box add`命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  \n\n```\n$ vagrant box add hashicorp/precise32\n```\n\n&emsp;&emsp; 这个将从[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)下载一个名字为`hashicorp/precise32`的box。你可以从HashiCorp's Atlas box catalog中找到各种box。很容易从HashiCorp's Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。\n&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的`hashicorp/precise32`的box，其中一个主机添加文件并不会影响另一个主机。  \n\n### 使用box\n\n&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\nend\n```\n&emsp;&emsp; 在这个例子中，\"hashicorp/precise32\" 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。  \n&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  \n\n### 寻找更多box\n\n&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的\"hashicorp/precise32\"的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。  \n&emsp;&emsp; 寻找更多box的最好的地方是[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。  \n&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。  \n&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  \n\n## 启动并且SSH登陆\n\n&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  \n\n```\nvagrant up\n```\n\n&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：\n\n```\nvagrant ssh\n```\n\n&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心`rm -rf /` 这种命令，因为Vagrant的`/vagrant`目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。  \n&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。  \n&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用`vagrant destory`来清除你再虚拟机的痕迹。\n\n## 同步文件夹\n\n&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用*同步文件夹*Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。  \n&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的`/vagrant`的。再次运行`vagrant up` 并且ssh到虚拟机。\n\n```\n$ vagrant up\n...\n$ vagrant ssh\n...\nvagrant@precise32:~$ ls /vagrant\nVagrantfile\n```\n\n&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：\n\n```\nvagrant@precise32:~$ touch /vagrant/foo\nvagrant@precise32:~$ exit\n$ ls\nfoo Vagrantfile\n```\n\n&emsp;&emsp; 哇！`foo`已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。  \n&emsp;&emsp; 通过使用[同步文件夹](https://docs.vagrantup.com/v2/synced-folders/)，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。\n\n## 配置\n\n&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。  \n&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你`vagrant up`的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  \n\n### 安装Apache\n\n&emsp;&emsp; 对于我们的项目来说可以仅仅使用[Apache](http://httpd.apache.org/)，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为`bootstrap.sh`的文件。  \n\n```\n#!/usr/bin/env bash\n\napt-get update\napt-get install -y apache2\nif ! [ -L /var/www ]; then\n  rm -rf /var/www\n  ln -fs /vagrant /var/www\nfi \n```\n\n&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\nend\n```\n\n&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用`shell`配置器运行`bootstrap.sh`脚本启动机器。脚本的路径是项目更目录的相对路径。\n\n### 配置\n\n&emsp;&emsp; 在所有的事情都配置好好，运行`vagrant up`来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行`vagrant reload --provision`, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。`--provision`表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。\n&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。\n\n```\n$ vagrant ssh\n...\nvagrant@precise32:~$ wget -qO- 127.0.0.1\n```\n\n&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的`DocumentRoot`指向了`/vagrant`。\n&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。\n\n## 网络\n\n&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。\n\n### 端口转发\n\n&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。\n&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\n  config.vm.network :forwarded_port, guest: 80, host: 4567\nend\n```\n\n&emsp;&emsp; 运行`vagrant reload`，或者如果没有启动过虚拟机运行`vagrant up`。使配置生效。\n\n### 其他的网络配置\n\n&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读[networking](https://docs.vagrantup.com/v2/networking/)章节。\n\n## 共享\n\n&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做[Vagrant Share](https://docs.vagrantup.com/v2/share/)。\n&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。\n\n### 登录Harshicorp's Altas\n\n&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个[HashiCorp's Altas](https://atlas.hashicorp.com/)的账号。不必担心，它是免费的。\n&emsp;&emsp; 当你有了账号后，你就可以使用`vagrant login`来登陆\n\n```\n$ vagrant login\nUsername or Email: mitchellh\nPassword (will be hidden):\nYou're now logged in!\n```\n\n### 共享\n\n&emsp;&emsp; 当你登录之后，你就可以使用`vagrant share`来共享环境了。\n\n```\n$ vagrant share\n...\n==> default: Your Vagrant Share is running!\n==> default: URL: http://frosty-weasel-0857.vagrantshare.com\n...\n```\n\n&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面`vagrant share`生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。\n&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。\n&emsp;&emsp; 关闭共享只需要使用`Ctrl+C`即可，重新刷新URL，你会发现你的环境已经不再被共享了。\n&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的[Vagrant Share](https://docs.vagrantup.com/v2/share/)文档。\n\n## 关闭\n\n&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。\n&emsp;&emsp; 通过Vagrant，我们可以*suspend*,*halt*或者*destory*虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  \n* **suspend** 使用`vagrant suspend`命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用`vagrant up`命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  \n* **halting** 使用`vagrant halt`命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行`vagrant up`命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。\n* **destory** 使用`vagrant destory`命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用`vagrant up`的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是`vagrant up`将会从头开始，这样会花费更长的时间。\n\n## 重新构建\n\n&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过`vagrant up`来轻松运行他。\n&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行`vagrant up`即可重新创建相同的环境。\n\n### Provider\n\n&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如[VMware](https://docs.vagrantup.com/v2/vmware/),[AWS](http://github.com/mitchellh/vagrant-aws)等。继续阅读来了解如何它们的更多信息以及如何使用它们。\n&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：\n\n```\n$ vagrant up --provider=vmware_fusion\n```\n\n准备转移到云端了？使用AWS：\n\n```\n$ vagrant up --provider=aws\n```\n\n&emsp;&emsp; 当你使用其他Provider运行`vagrant up`的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：`vagrant destory`，无需额外的参数。\n&emsp;&emsp; 更多信息请参考[provider](https://docs.vagrantup.com/v2/providers/)。\n[1]: https://www.virtualbox.org/\n\n\n","slug":"Vagrant-入门指南","published":1,"updated":"2015-11-06T14:35:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8vs000ioz9kh1bjir5f"},{"title":"Vagrant & Ansible 快速入门教程","date":"2015-11-07T16:39:10.000Z","_content":"\n[原文地址](https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html)  \n\n&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于[Chef](https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html)的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。  \n&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  \n\n## 为什么使用Ansible\n\n&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。  \n&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。\n\n## Ansible 和 Vagrant\n\n&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。\n\n## 基础\n\n&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。\n\n```\nmkdir -p ~/Projects/vagrant-ansible\ncd ~/Projects/vagrant-ansible\n```\n\n&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。\n\n```\nvagrant init ubuntu/trusty64\n```\n\n&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫`Vagrantfile`的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：\n\n```\nVAGRANTFILE_API_VERSION = \"2\"\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\nend\n```\n\n&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到`end`之前。\n\n```\nconfig.vm.network \"forworded_port\", guest: 80, host:8080\n```\n\n&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到`Vagrantfile`的`end`之前。\n\n```\nconfig.vm.provision :ansible do |ansible|\n  ansible.playbook = \"playbook.yml\"\nend\n```\n\n&emsp;&emsp; 以上所有的任务完成之后你的`Vagrantfile`将会是一下的配置。  \n\n```\nVAGRANTFILE_API_VERSION = \"2\"\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\n\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\n## 基本术语\n\n&emsp;&emsp; Ansible再你的服务器上运行一系列的*Tasks*。把Task想象成一个单一的Bash命令。接着是*playbook*，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的*Module*，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  \n\n## 第一个Playbook\n\n&emsp;&emsp; 创建一个叫`playbook.yml`的文件，这个名字必须和`Vagrantfile`的`ansible.playbook`相同。\n&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。  \n&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到`playbook.yml`文件中。\n\n```\n---\n- host: all\n  sudo: true\n  tasks:\n```\n\n&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值`all`，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 `tasks:` 用来添加Task。\n\n&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  \n1. 更新 Apt Cache\n2. 安装 Apache\n3. 安装 MySQL\n4. 安装 PHP\n\n&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。\n&emsp;&emsp; 首先我们给每一个task一个`name:`，这个可以是任何描述，它用来描述这个任务，如下:\n\n```\n- name: this should be some descriptive text\n```\n\n&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。\n\n```\napt\n```\n\n&emsp;&emsp; 紧随其后的是一些`key=value`的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。\n\n&emsp;&emsp; 安装Apache的任务如下：\n\n```\n- name: install apache\n  apt: name=apache2 state=present\n```\n\n&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到`playbook.yml`中，最后代码如下：\n\n```\n---\n- hosts: all\n  sudo: true\n  tasks:\n    - name: update apt cache\n      apt: update_cache=yes\n    - name: install apache\n      apt: name=apache2 state=present\n    - name: install mysql\n      apt: name=mysql-server state=present\n    - name: install php\n      apt: name=php5 state=present\n```\n\n&emsp;&emsp; 现在我们已经配置完了，然后运行`vagrant up`，你将会看到如下图所示：\n![result](https://adamcod.es/img/posts/vagrant-ansible-lamp.gif)  \n\n&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将`info.php`文件添加到`/var/www/html`下。\n```\n<?php phpinfo();?>\n```\n\n&emsp;&emsp; 然后在本机浏览器打开[http://localhost:8080/info.php](http://localhost:8080/info.php)，就会看到你想要看到的。\n\n**翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习**\n\n","source":"_posts/Vagrant-Ansible-快速入门教程.md","raw":"title: 'Vagrant & Ansible 快速入门教程'\ndate: 2015-11-08 00:39:10\ntags:\n  - Ansible\n  - Translate\n  - Vagrant\n---\n\n[原文地址](https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html)  \n\n&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于[Chef](https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html)的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。  \n&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  \n\n## 为什么使用Ansible\n\n&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。  \n&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。\n\n## Ansible 和 Vagrant\n\n&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。\n\n## 基础\n\n&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。\n\n```\nmkdir -p ~/Projects/vagrant-ansible\ncd ~/Projects/vagrant-ansible\n```\n\n&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。\n\n```\nvagrant init ubuntu/trusty64\n```\n\n&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫`Vagrantfile`的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：\n\n```\nVAGRANTFILE_API_VERSION = \"2\"\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\nend\n```\n\n&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到`end`之前。\n\n```\nconfig.vm.network \"forworded_port\", guest: 80, host:8080\n```\n\n&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到`Vagrantfile`的`end`之前。\n\n```\nconfig.vm.provision :ansible do |ansible|\n  ansible.playbook = \"playbook.yml\"\nend\n```\n\n&emsp;&emsp; 以上所有的任务完成之后你的`Vagrantfile`将会是一下的配置。  \n\n```\nVAGRANTFILE_API_VERSION = \"2\"\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\n\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\n## 基本术语\n\n&emsp;&emsp; Ansible再你的服务器上运行一系列的*Tasks*。把Task想象成一个单一的Bash命令。接着是*playbook*，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的*Module*，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  \n\n## 第一个Playbook\n\n&emsp;&emsp; 创建一个叫`playbook.yml`的文件，这个名字必须和`Vagrantfile`的`ansible.playbook`相同。\n&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。  \n&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到`playbook.yml`文件中。\n\n```\n---\n- host: all\n  sudo: true\n  tasks:\n```\n\n&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值`all`，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 `tasks:` 用来添加Task。\n\n&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  \n1. 更新 Apt Cache\n2. 安装 Apache\n3. 安装 MySQL\n4. 安装 PHP\n\n&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。\n&emsp;&emsp; 首先我们给每一个task一个`name:`，这个可以是任何描述，它用来描述这个任务，如下:\n\n```\n- name: this should be some descriptive text\n```\n\n&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。\n\n```\napt\n```\n\n&emsp;&emsp; 紧随其后的是一些`key=value`的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。\n\n&emsp;&emsp; 安装Apache的任务如下：\n\n```\n- name: install apache\n  apt: name=apache2 state=present\n```\n\n&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到`playbook.yml`中，最后代码如下：\n\n```\n---\n- hosts: all\n  sudo: true\n  tasks:\n    - name: update apt cache\n      apt: update_cache=yes\n    - name: install apache\n      apt: name=apache2 state=present\n    - name: install mysql\n      apt: name=mysql-server state=present\n    - name: install php\n      apt: name=php5 state=present\n```\n\n&emsp;&emsp; 现在我们已经配置完了，然后运行`vagrant up`，你将会看到如下图所示：\n![result](https://adamcod.es/img/posts/vagrant-ansible-lamp.gif)  \n\n&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将`info.php`文件添加到`/var/www/html`下。\n```\n<?php phpinfo();?>\n```\n\n&emsp;&emsp; 然后在本机浏览器打开[http://localhost:8080/info.php](http://localhost:8080/info.php)，就会看到你想要看到的。\n\n**翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习**\n\n","slug":"Vagrant-Ansible-快速入门教程","published":1,"updated":"2015-11-08T09:02:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8vu000moz9kj0ya1pom"},{"title":"HTTP/2 和GO","date":"2015-11-12T03:39:21.000Z","_content":"[原文地址](https://www.ianlewis.org/en/http2-and-go)\n&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n&emsp;&emsp; Brad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。\n","source":"_posts/HTTP-2-和GO.md","raw":"title: HTTP/2 和GO\ndate: 2015-11-12 11:39:21\ntags:\n  - HTTP/2\n  - Translate\n  - Go\n---\n[原文地址](https://www.ianlewis.org/en/http2-and-go)\n&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n&emsp;&emsp; Brad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。\n","slug":"HTTP-2-和GO","published":1,"updated":"2015-11-12T04:07:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8vx000qoz9kmu6f2l8b"},{"title":"Go Web 架构","date":"2015-11-10T11:01:21.000Z","_content":"\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n&emsp;&emsp; `main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n&emsp;&emsp; 因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n&emsp;&emsp; `web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```\n-web/\n|-middleware/\n|-server.go\n```\n\n&emsp;&emsp; `server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n&emsp;&emsp; `Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n&emsp;&emsp; 在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\n&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n&emsp;&emsp; 将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n&emsp;&emsp; 毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n&emsp;&emsp; 同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n&emsp;&emsp; 然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","source":"_posts/Go-Web-架构.md","raw":"title: Go Web 架构\ndate: 2015-11-10 19:01:21\ntags:\n  - Go\n  - Architecture\n  - Translate\n---\n\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n&emsp;&emsp; `main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n&emsp;&emsp; 因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n&emsp;&emsp; `web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```\n-web/\n|-middleware/\n|-server.go\n```\n\n&emsp;&emsp; `server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n&emsp;&emsp; `Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n&emsp;&emsp; 在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\n&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n&emsp;&emsp; 将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n&emsp;&emsp; 毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n&emsp;&emsp; 同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n&emsp;&emsp; 然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","slug":"Go-Web-架构","published":1,"updated":"2015-11-10T12:20:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cigyxr8w0000voz9kxj2qufg3"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cigyxr8up0000oz9kv7lzt6ao","tag_id":"cigyxr8uv0001oz9kx7qc3yev","_id":"cigyxr8ux0003oz9ks87mgihq"},{"post_id":"cigyxr8up0000oz9kv7lzt6ao","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8uy0004oz9kr2hl0kcb"},{"post_id":"cigyxr8vl0005oz9k0xtd6e1t","tag_id":"cigyxr8vm0006oz9kfiv7tqkp","_id":"cigyxr8vm0009oz9k8992bqdi"},{"post_id":"cigyxr8vl0005oz9k0xtd6e1t","tag_id":"cigyxr8vm0007oz9ksoesxj3z","_id":"cigyxr8vm000aoz9kzmxl8kg8"},{"post_id":"cigyxr8vl0005oz9k0xtd6e1t","tag_id":"cigyxr8vm0008oz9kkmgg7kal","_id":"cigyxr8vm000boz9k97vk27vi"},{"post_id":"cigyxr8vn000coz9k9hxu1p37","tag_id":"cigyxr8vm0007oz9ksoesxj3z","_id":"cigyxr8vo000doz9kwlxhpzug"},{"post_id":"cigyxr8vn000coz9k9hxu1p37","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8vo000eoz9kk8h9n8lq"},{"post_id":"cigyxr8vp000foz9kxojy6rx6","tag_id":"cigyxr8vm0007oz9ksoesxj3z","_id":"cigyxr8vr000goz9kjcwrevz6"},{"post_id":"cigyxr8vp000foz9kxojy6rx6","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8vr000hoz9km6by9q8b"},{"post_id":"cigyxr8vs000ioz9kh1bjir5f","tag_id":"cigyxr8vt000joz9kl7qm4e27","_id":"cigyxr8vu000koz9kw02ogpw0"},{"post_id":"cigyxr8vs000ioz9kh1bjir5f","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8vu000loz9ko9nvh4z8"},{"post_id":"cigyxr8vu000moz9kj0ya1pom","tag_id":"cigyxr8uv0001oz9kx7qc3yev","_id":"cigyxr8vv000noz9k8ctmsvhd"},{"post_id":"cigyxr8vu000moz9kj0ya1pom","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8vw000ooz9k9ccqe5dd"},{"post_id":"cigyxr8vu000moz9kj0ya1pom","tag_id":"cigyxr8vt000joz9kl7qm4e27","_id":"cigyxr8vw000poz9k8efsgfre"},{"post_id":"cigyxr8vx000qoz9kmu6f2l8b","tag_id":"cigyxr8vy000roz9k2kahplbi","_id":"cigyxr8vz000soz9keazmhnni"},{"post_id":"cigyxr8vx000qoz9kmu6f2l8b","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8vz000toz9k5tql0jag"},{"post_id":"cigyxr8vx000qoz9kmu6f2l8b","tag_id":"cigyxr8vm0007oz9ksoesxj3z","_id":"cigyxr8vz000uoz9ka68p5gq4"},{"post_id":"cigyxr8w0000voz9kxj2qufg3","tag_id":"cigyxr8vm0007oz9ksoesxj3z","_id":"cigyxr8w1000xoz9kzrqp7ldu"},{"post_id":"cigyxr8w0000voz9kxj2qufg3","tag_id":"cigyxr8w0000woz9k1308rekm","_id":"cigyxr8w1000yoz9kh5jh3r7t"},{"post_id":"cigyxr8w0000voz9kxj2qufg3","tag_id":"cigyxr8ux0002oz9kd3mv9r41","_id":"cigyxr8w1000zoz9k3k915luj"}],"Tag":[{"name":"Ansible","_id":"cigyxr8uv0001oz9kx7qc3yev"},{"name":"Translate","_id":"cigyxr8ux0002oz9kd3mv9r41"},{"name":"HTTP","_id":"cigyxr8vm0006oz9kfiv7tqkp"},{"name":"Go","_id":"cigyxr8vm0007oz9ksoesxj3z"},{"name":"Middleware","_id":"cigyxr8vm0008oz9kkmgg7kal"},{"name":"Vagrant","_id":"cigyxr8vt000joz9kl7qm4e27"},{"name":"HTTP/2","_id":"cigyxr8vy000roz9k2kahplbi"},{"name":"Architecture","_id":"cigyxr8w0000woz9k1308rekm"}]}}