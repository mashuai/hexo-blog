{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"184b732ae9135945cf139b09dbec42b2a59ceef8","modified":1522511675000},{"_id":"source/robots.txt","hash":"7470d06ea2966e17ca1657df9b2995f17bf29160","modified":1522511676000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1522511676000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1522511676000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1522511676000},{"_id":"themes/landscape/_config.yml","hash":"9efe9b636d767b96b5689c43b00fe07f4d9f469e","modified":1522511676000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1522511676000},{"_id":"source/_posts/Ansible-入门指南.md","hash":"fa4105aa31bf90010278e932190aab757b8f8b90","modified":1522511675000},{"_id":"source/_posts/Git分支.md","hash":"95e5db65738afe7b1abb320e91c5e90168e281d5","modified":1522511675000},{"_id":"source/_posts/Go-Web-架构.md","hash":"433c388f2ebc3c1a2160575046abd6ff8ecfde34","modified":1522511675000},{"_id":"source/_posts/HTTP-2-和GO.md","hash":"cce9c6cdd530225434945c1ca6e7824cc1eb0a3f","modified":1522511675000},{"_id":"source/_posts/Vagrant-Ansible-快速入门教程.md","hash":"a9c244b89cce7839568ec8ad92147332b060a9a4","modified":1522511675000},{"_id":"source/_posts/Vagrant-入门指南.md","hash":"2195d733d840fdb2f9af3794708e2a01d3bc3e07","modified":1522511675000},{"_id":"source/_posts/java8-date-time-api.md","hash":"6583d8925780feced7c9003d7d8d94d257706f67","modified":1523026031000},{"_id":"source/_posts/cup-load-high.md","hash":"9808d66e24aea71b6b706deb4fc6cb847477071e","modified":1522511675000},{"_id":"source/_posts/http-Handler-与Go的错误处理.md","hash":"b72f6f8b815996a3f4835211b05963b403fafb3b","modified":1522511675000},{"_id":"source/_posts/mybaits-configuration.md","hash":"b8e0c7482ce6dc3148f98e7cd11a3941ca4aebb2","modified":1522511675000},{"_id":"source/_posts/为Go-Web-App-创建一个主页面.md","hash":"aa614ee69a7dd65adcea8ed4a34409ab709c7267","modified":1522511675000},{"_id":"source/_posts/使用Go开发HTTP中间件.md","hash":"cc7641e219c0f146d71aa195977ab0d810c70619","modified":1522511675000},{"_id":"source/projects/index.md","hash":"e41dab49c7f7c868d77d6fdf761945479da22304","modified":1522511676000},{"_id":"source/velocity/index.md","hash":"df22fc1ee16967437edf016dc8469866aa088542","modified":1522511676000},{"_id":"source/_posts/jackson-tutorial.md","hash":"f106937fe85a6dc3cb8917cf77023f47b9f2d235","modified":1523023015000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1522511676000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1522511676000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1522511676000},{"_id":"themes/landscape/layout/layout.ejs","hash":"24b5986a3b76fa96e7afe8e552bb5ac76520c6c6","modified":1522511676000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1522511676000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522511676000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522511676000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1522511676000},{"_id":"source/_posts/mybatis/mybatis-started.md","hash":"f4c93c93ff8e93499932cde1634e7cbfd13de4d7","modified":1522511675000},{"_id":"source/_posts/okhttp/Recipes.md","hash":"455df5a26107a8b4d17745acb7c7e9a0f0e49f46","modified":1522511675000},{"_id":"source/_posts/okhttp/calls.md","hash":"3cb2cd155d411e56274adb227bdd4bfb2b6111a6","modified":1522511675000},{"_id":"source/_posts/okhttp/connections.md","hash":"38e13fcb1f3411ae87102a8e7e7821ca919ac85a","modified":1522511675000},{"_id":"source/_posts/okhttp/https.md","hash":"57dd797247aa2791153d890b9e0da05ddd0d0195","modified":1522511675000},{"_id":"source/_posts/okhttp/interceptors.md","hash":"138adaa83386c928c8c50f425afbe77d237ddd22","modified":1522511675000},{"_id":"themes/landscape/layout/_custom_ad/google_adsense.ejs","hash":"0512a9bbc6bb194c3aebfe053a390bc5c7caa468","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"24b74b45ccc66a3c5680635e7c7f26099bd98b2a","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/google_adsense.ejs","hash":"0512a9bbc6bb194c3aebfe053a390bc5c7caa468","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"f1ed8521a9fe567335ba9254e5096c8e17fd3082","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1522511676000},{"_id":"themes/landscape/layout/_analysis/google_analysis.ejs","hash":"6e9469ebfa00e51f9dd4e6191a52bcd0669a404e","modified":1522511676000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1522511676000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1522511676000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1522511676000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1522511676000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1522511676000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1522511676000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1522511676000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1522511676000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1522511676000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"36eefe6332b86b66023a9884b754d305235846b4","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1522511676000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1522511676000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1522511676000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1522511676000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1522511676000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1522511676000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522511676000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1522511676000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1522511676000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1522511676000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1522511676000},{"_id":"public/atom.xml","hash":"71866d7bc62aa0d2c0b213c5d1c6503be5c18006","modified":1523026044911},{"_id":"public/sitemap.xml","hash":"a3e8a0871607d79aaa2b0d10202010f375e260d2","modified":1523026044963},{"_id":"public/baidusitemap.xml","hash":"31dcbb4573a2c42e73b6d9047b7040687bff0dff","modified":1523026044964},{"_id":"public/projects/index.html","hash":"6cbf2993e750e9e0b40b34aa96d9135a999f1b9a","modified":1523026045337},{"_id":"public/velocity/index.html","hash":"79dcf407d4ca8935bfc87fccd96e814d19dd06df","modified":1523026045624},{"_id":"public/2017/03/25/cup-load-high/index.html","hash":"ab3e014a2cf3defb99badb0066fa7a59681ff9ff","modified":1523026045688},{"_id":"public/archives/index.html","hash":"b9ddf06386aa267258b6cb9cdb22dcb53703c337","modified":1523026045712},{"_id":"public/archives/2017/index.html","hash":"223bd68f8bb52ec200b94bff60df7a3cf2b21643","modified":1523026045713},{"_id":"public/archives/page/2/index.html","hash":"bb93df2819c49411e1c3b88a2ef761a1bdae3753","modified":1523026045714},{"_id":"public/archives/2015/11/index.html","hash":"05a6952058491ec1840b04af568ebc2b9a6a6fbf","modified":1523026045714},{"_id":"public/archives/2015/index.html","hash":"6a12be293d557e9d82db20a3f7685020de0ac13d","modified":1523026045714},{"_id":"public/archives/2017/03/index.html","hash":"e4744f104dc3541adfd22805f386b0c82c8877e0","modified":1523026045714},{"_id":"public/tags/Ansible/index.html","hash":"9e49ec6b4ca86e77b5e1d16b852209ac98bcf25f","modified":1523026045714},{"_id":"public/tags/Git/index.html","hash":"54f291427495ff5c7e9ca4320a51aaf004c20442","modified":1523026045715},{"_id":"public/tags/Translate/index.html","hash":"0aa4e5e364c423b9dd51cd525f8e8fc9ec60abc4","modified":1523026045715},{"_id":"public/tags/Translate/page/2/index.html","hash":"f54b5c34f455d777961b5cbb255b3d6fd4eb402a","modified":1523026045715},{"_id":"public/archives/2017/06/index.html","hash":"d58e956008475969cca08b4c175ccb3bd6fb4a3c","modified":1523026045715},{"_id":"public/tags/Git分支/index.html","hash":"88f25cf62e7d69980e9b2d9e0a00f6c42f4bc634","modified":1523026045715},{"_id":"public/tags/Go/index.html","hash":"bc59b3bf5c18788cdba07db94654d24d1f99b0e7","modified":1523026045715},{"_id":"public/tags/Architecture/index.html","hash":"ab33c6453d1b3ee4be96a28d382bc89589a88500","modified":1523026045715},{"_id":"public/tags/Java/index.html","hash":"f4b3a459c2a40201c9526f42a5b87680300327a4","modified":1523026045715},{"_id":"public/tags/Vagrant/index.html","hash":"110489e7a954bafb2f7977ed880e17074b5603a2","modified":1523026045715},{"_id":"public/tags/CPU/index.html","hash":"0680ad941e713408435032df25b0b593af42dbb1","modified":1523026045715},{"_id":"public/tags/Linux/index.html","hash":"ac194f2407a1ac8e088ed60cb561fc086332a5b5","modified":1523026045716},{"_id":"public/tags/HTTP-2/index.html","hash":"134382e2607c0aa73d36eeae37d89f7aa4fe8707","modified":1523026045716},{"_id":"public/tags/HTTP/index.html","hash":"92b9cc82c27d1880b86ac33076988af088457fe1","modified":1523026045716},{"_id":"public/tags/Middleware/index.html","hash":"89ec2f82134f9237b147a2b2ca05d7ed444a2ebc","modified":1523026045716},{"_id":"public/tags/Mybatis/index.html","hash":"9bbc68876667b8005c416c58e25f027c205b2689","modified":1523026045716},{"_id":"public/tags/OKHttp/index.html","hash":"ecbdb62d831c60c4b8935f8dc5e76e3386bc42c0","modified":1523026045716},{"_id":"public/2018/04/06/java8-date-time-api/index.html","hash":"7b855534c621edc734b13cfa32851f1312d03cfa","modified":1523026045716},{"_id":"public/2018/03/31/jackson-tutorial/index.html","hash":"a6ad935ab2f1526b2f484b85ad6e1dfa9117d6ea","modified":1523026045716},{"_id":"public/2017/03/24/Git分支/index.html","hash":"7ce699981b3aea409493053326c927617764fca4","modified":1523026045716},{"_id":"public/2017/06/28/mybaits-configuration/index.html","hash":"d01bc60b3e709849d0953c25632c0192ac891d62","modified":1523026045716},{"_id":"public/2017/03/21/mybatis/mybatis-started/index.html","hash":"13159ad8b24d8a92a603f624c32705b9c5c6980b","modified":1523026045717},{"_id":"public/2017/03/19/okhttp/interceptors/index.html","hash":"4aeb7890cb78b4f8dec2094cd1c9a93eeda4e002","modified":1523026045717},{"_id":"public/2017/03/18/okhttp/connections/index.html","hash":"4117908b50a5c009eb384b89e02748801a16431e","modified":1523026045717},{"_id":"public/2017/03/18/okhttp/calls/index.html","hash":"8f16e2ca7cca7a45f483ecea5841fcec605c8c94","modified":1523026045717},{"_id":"public/2017/03/23/okhttp/https/index.html","hash":"4ba89e0915dfbca250a3a92e87fd607b70e6946e","modified":1523026045717},{"_id":"public/2017/03/18/okhttp/Recipes/index.html","hash":"cf89af8367e10cd22f6f894be09c46fead1da484","modified":1523026045717},{"_id":"public/2015/11/14/为Go-Web-App-创建一个主页面/index.html","hash":"b611f0c38a4815f9772d5579fff0537c52d173f2","modified":1523026045717},{"_id":"public/2015/11/10/Go-Web-架构/index.html","hash":"cdb3840a0b37f3498bbf76f8f7d22a7084a53bf2","modified":1523026045717},{"_id":"public/2015/11/12/HTTP-2-和GO/index.html","hash":"f839387176047d9915ee2117ee9852cb7d07e702","modified":1523026045717},{"_id":"public/2015/11/12/http-Handler-与Go的错误处理/index.html","hash":"51b0ef6c911f55adee5181edd466c8d604a20441","modified":1523026045718},{"_id":"public/2015/11/12/使用Go开发HTTP中间件/index.html","hash":"125d86d796630a1312b998f968cc822b896f30e3","modified":1523026045718},{"_id":"public/index.html","hash":"6ab215f8265113c2b0585684e945582cc5729487","modified":1523026045718},{"_id":"public/2015/11/06/Vagrant-入门指南/index.html","hash":"9eefea753daf209ac1099a484073ebf0b6917f75","modified":1523026045718},{"_id":"public/page/2/index.html","hash":"4085517355f6334d78cdd51049c9485610a038c1","modified":1523026045718},{"_id":"public/2015/11/09/Ansible-入门指南/index.html","hash":"7eb602428bb94a1e2abe8b35a2135ec86001205d","modified":1523026045718},{"_id":"public/2015/11/08/Vagrant-Ansible-快速入门教程/index.html","hash":"6ffa23908954c2a8620f60a93966071ae075150d","modified":1523026045718},{"_id":"public/archives/2018/index.html","hash":"356efdee88ff65d8a0be36eaa3009785e71ca9b4","modified":1523026045725},{"_id":"public/archives/2018/04/index.html","hash":"b0d892df71ac07f23c9880b4c802a148c26c3287","modified":1523026045725},{"_id":"public/archives/2018/03/index.html","hash":"bc79b92b83c22b9d24fc245e8eb91bf65522a108","modified":1523026045725},{"_id":"public/tags/Java8/index.html","hash":"0aaeee2b0fb69f01a717ad68cf004393fcaf69ac","modified":1523026045725},{"_id":"public/tags/JSON/index.html","hash":"f2374e7bebec37d72eb8e53cfb7aa63a32b5d326","modified":1523026045725},{"_id":"public/tags/Jackson/index.html","hash":"2bf9c706eae0b3e68ea6642ae80db453c3c3b84f","modified":1523026045725},{"_id":"public/robots.txt","hash":"7470d06ea2966e17ca1657df9b2995f17bf29160","modified":1523026045726},{"_id":"public/CNAME","hash":"184b732ae9135945cf139b09dbec42b2a59ceef8","modified":1523026045726},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523026045726},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523026045727},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523026045727},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523026045728},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523026045728},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523026045728},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1523026045728},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1523026045729},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1523026045729},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523026045729},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1523026047577},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1523026047642},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1523026047642},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1523026047642},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1523026047645},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1523026047645},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1523026047645},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1523026047646},{"_id":"public/css/style.css","hash":"5e933caac06e02b7cf02c3050347c00ce5b31184","modified":1523026047646},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1523026047646},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1523026047646},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1523026047655},{"_id":"public/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1523026047659}],"Category":[],"Data":[],"Page":[{"title":"test","date":"2017-03-28T05:22:18.000Z","tags":null,"_content":"\n#### hello world\n","source":"projects/index.md","raw":"title: test\ndate: 2017-03-28 13:22:18\ntags:\n---\n\n#### hello world\n","updated":"2018-03-31T15:54:36.000Z","path":"projects/index.html","comments":1,"layout":"page","_id":"cjfo2ds5a0001martveephm8q","content":"<h4 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h4>"},{"title":"velocity 用户指南 -- 简介","date":"2017-03-30T11:55:20.000Z","tags":["velocity","Java"],"_content":"[原文链接](http://velocity.apache.org/engine/devel/user-guide.html)  \n\n#### 关于此指南\n&emsp;&emsp; 这篇指南主要是帮助网页设计师和内容提供商熟悉Velocity和语法简单，但是很强大的Velocity模板语言（VTL）。在这篇指南的很多示例通过使用Velocity向网站中嵌入内容，但是VTL的例子同样适用于其他网页和模板。  \n&emsp;&emsp; 谢谢选择Velocity。  \n#### Velocity 是什么\n&emsp;&emsp; Velocity是一个基于Java的模板引擎。它允许网页设计师引用在Java中定义的方法。通过MVC的设计模式，网页设计师可以和Java程序员同时开发网站，这意味着设计师可以专注于创作精心设计的网页，程序员也可以专注写一流的代码。Velocity从web页面中分离了Java代码，使得Web站在运行很长时间后仍然很容易维护，同时也提供了 JSP或者PHP的另一种选择。\n&emsp;&emsp;Velocity可以用来生成页面，SQL，PostScript和其他可以由模板输出的的东西。它既可以作为生成源码和报表单独使用，也可以和其他系统集成。当完成的时候Velocity将会为turbine web框架提供模板服务。通过使用Velocity+Turbine可以让开发者使用真正的MVC开发模式。  \n#### Velocity 可以为我做什么\n#####　一个泥土店的例子\n&emsp;&emsp;假设你是一个为专门卖泥土的店设计网上商店的设计师。暂且叫作“泥土网店”。店铺生意兴旺。客户订购了各种各样的大量泥浆。他们通过使用用户名和密码来登录网站，浏览订单，购买更多的泥浆。现在非常流行的赤陶土泥正在开卖，少数顾客购买了同样买卖的明亮的红色的泥，这个没有那么流行，所以就放到了网页边缘。顾客的信息记录在数据库中，那么问题来了，为什么不使用Velocity直接给那些喜欢不同泥土的客户推送他们感兴趣的泥土呢？  \n&emsp;&emsp;Velocity可以很容易的为你的用户定制页面。作为泥土屋的网页设计师，你希望用户登录之后就可以看到他们想要的页面。  \n&emsp;&emsp;你在公司见到了开发人员，并且每个人都同意使用`$customer `来保持用户登录之后用户的相关信息，使用`$mudsOnSpecial`来表示当前正在买的泥土的所有类型。`$flogger`对象包含了用来推广的方法。对现在手头上的任务，我们只需要关心这三个引用。记住，你不需要考虑程序员如何从数据库取得这些信息，你只需要知道，他可以工作就可以了。这样你就可以专注于自己的工作，程序员也可以专注于自己的工作。\n&emsp;&emsp;下面这个例子可能就是你要嵌入网页的的VTL的语句    \n```\n<html>\n  <body>\n    Hello $customer.Name!\n    <table>\n    #foreach( $mud in $mudsOnSpecial )\n      #if ( $customer.hasPurchased($mud) )\n        <tr>\n          <td>\n            $flogger.getPromo( $mud )\n          </td>\n        </tr>\n      #end\n    #end\n    </table>\n  </body>\n</html>\n```\n&emsp;&emsp;`foreach`的细节稍后会进行深入的描述；现在重要的是这段脚本对你网页的影响。当一个喜欢明亮红土的人登录网站，将会看到明亮的红土突出显示在网页中售卖。当一个一直购买赤陶土泥的用户登录的时候他将会看见赤陶土泥正在网页的中央。Velocity的潜力和限制只和你的创造力相关。\n&emsp;&emsp;VTL文档中还有很多其他的Velocity的元素，这些元素可以让你更加轻松的设计网页。当你熟悉了这些元素之后就会释放Velocity所有的强大的能力。","source":"velocity/index.md","raw":"title: velocity 用户指南 -- 简介\ndate: 2017-03-30 19:55:20\ntags:\n    - velocity\n    - Java\n---\n[原文链接](http://velocity.apache.org/engine/devel/user-guide.html)  \n\n#### 关于此指南\n&emsp;&emsp; 这篇指南主要是帮助网页设计师和内容提供商熟悉Velocity和语法简单，但是很强大的Velocity模板语言（VTL）。在这篇指南的很多示例通过使用Velocity向网站中嵌入内容，但是VTL的例子同样适用于其他网页和模板。  \n&emsp;&emsp; 谢谢选择Velocity。  \n#### Velocity 是什么\n&emsp;&emsp; Velocity是一个基于Java的模板引擎。它允许网页设计师引用在Java中定义的方法。通过MVC的设计模式，网页设计师可以和Java程序员同时开发网站，这意味着设计师可以专注于创作精心设计的网页，程序员也可以专注写一流的代码。Velocity从web页面中分离了Java代码，使得Web站在运行很长时间后仍然很容易维护，同时也提供了 JSP或者PHP的另一种选择。\n&emsp;&emsp;Velocity可以用来生成页面，SQL，PostScript和其他可以由模板输出的的东西。它既可以作为生成源码和报表单独使用，也可以和其他系统集成。当完成的时候Velocity将会为turbine web框架提供模板服务。通过使用Velocity+Turbine可以让开发者使用真正的MVC开发模式。  \n#### Velocity 可以为我做什么\n#####　一个泥土店的例子\n&emsp;&emsp;假设你是一个为专门卖泥土的店设计网上商店的设计师。暂且叫作“泥土网店”。店铺生意兴旺。客户订购了各种各样的大量泥浆。他们通过使用用户名和密码来登录网站，浏览订单，购买更多的泥浆。现在非常流行的赤陶土泥正在开卖，少数顾客购买了同样买卖的明亮的红色的泥，这个没有那么流行，所以就放到了网页边缘。顾客的信息记录在数据库中，那么问题来了，为什么不使用Velocity直接给那些喜欢不同泥土的客户推送他们感兴趣的泥土呢？  \n&emsp;&emsp;Velocity可以很容易的为你的用户定制页面。作为泥土屋的网页设计师，你希望用户登录之后就可以看到他们想要的页面。  \n&emsp;&emsp;你在公司见到了开发人员，并且每个人都同意使用`$customer `来保持用户登录之后用户的相关信息，使用`$mudsOnSpecial`来表示当前正在买的泥土的所有类型。`$flogger`对象包含了用来推广的方法。对现在手头上的任务，我们只需要关心这三个引用。记住，你不需要考虑程序员如何从数据库取得这些信息，你只需要知道，他可以工作就可以了。这样你就可以专注于自己的工作，程序员也可以专注于自己的工作。\n&emsp;&emsp;下面这个例子可能就是你要嵌入网页的的VTL的语句    \n```\n<html>\n  <body>\n    Hello $customer.Name!\n    <table>\n    #foreach( $mud in $mudsOnSpecial )\n      #if ( $customer.hasPurchased($mud) )\n        <tr>\n          <td>\n            $flogger.getPromo( $mud )\n          </td>\n        </tr>\n      #end\n    #end\n    </table>\n  </body>\n</html>\n```\n&emsp;&emsp;`foreach`的细节稍后会进行深入的描述；现在重要的是这段脚本对你网页的影响。当一个喜欢明亮红土的人登录网站，将会看到明亮的红土突出显示在网页中售卖。当一个一直购买赤陶土泥的用户登录的时候他将会看见赤陶土泥正在网页的中央。Velocity的潜力和限制只和你的创造力相关。\n&emsp;&emsp;VTL文档中还有很多其他的Velocity的元素，这些元素可以让你更加轻松的设计网页。当你熟悉了这些元素之后就会释放Velocity所有的强大的能力。","updated":"2018-03-31T15:54:36.000Z","path":"velocity/index.html","comments":1,"layout":"page","_id":"cjfo2ds5e0003martr4ezwlje","content":"<p><a href=\"http://velocity.apache.org/engine/devel/user-guide.html\" target=\"_blank\" rel=\"noopener\">原文链接</a>  </p>\n<h4 id=\"关于此指南\"><a href=\"#关于此指南\" class=\"headerlink\" title=\"关于此指南\"></a>关于此指南</h4><p>&emsp;&emsp; 这篇指南主要是帮助网页设计师和内容提供商熟悉Velocity和语法简单，但是很强大的Velocity模板语言（VTL）。在这篇指南的很多示例通过使用Velocity向网站中嵌入内容，但是VTL的例子同样适用于其他网页和模板。<br>&emsp;&emsp; 谢谢选择Velocity。  </p>\n<h4 id=\"Velocity-是什么\"><a href=\"#Velocity-是什么\" class=\"headerlink\" title=\"Velocity 是什么\"></a>Velocity 是什么</h4><p>&emsp;&emsp; Velocity是一个基于Java的模板引擎。它允许网页设计师引用在Java中定义的方法。通过MVC的设计模式，网页设计师可以和Java程序员同时开发网站，这意味着设计师可以专注于创作精心设计的网页，程序员也可以专注写一流的代码。Velocity从web页面中分离了Java代码，使得Web站在运行很长时间后仍然很容易维护，同时也提供了 JSP或者PHP的另一种选择。<br>&emsp;&emsp;Velocity可以用来生成页面，SQL，PostScript和其他可以由模板输出的的东西。它既可以作为生成源码和报表单独使用，也可以和其他系统集成。当完成的时候Velocity将会为turbine web框架提供模板服务。通过使用Velocity+Turbine可以让开发者使用真正的MVC开发模式。  </p>\n<h4 id=\"Velocity-可以为我做什么\"><a href=\"#Velocity-可以为我做什么\" class=\"headerlink\" title=\"Velocity 可以为我做什么\"></a>Velocity 可以为我做什么</h4><p>#####　一个泥土店的例子<br>&emsp;&emsp;假设你是一个为专门卖泥土的店设计网上商店的设计师。暂且叫作“泥土网店”。店铺生意兴旺。客户订购了各种各样的大量泥浆。他们通过使用用户名和密码来登录网站，浏览订单，购买更多的泥浆。现在非常流行的赤陶土泥正在开卖，少数顾客购买了同样买卖的明亮的红色的泥，这个没有那么流行，所以就放到了网页边缘。顾客的信息记录在数据库中，那么问题来了，为什么不使用Velocity直接给那些喜欢不同泥土的客户推送他们感兴趣的泥土呢？<br>&emsp;&emsp;Velocity可以很容易的为你的用户定制页面。作为泥土屋的网页设计师，你希望用户登录之后就可以看到他们想要的页面。<br>&emsp;&emsp;你在公司见到了开发人员，并且每个人都同意使用<code>$customer</code>来保持用户登录之后用户的相关信息，使用<code>$mudsOnSpecial</code>来表示当前正在买的泥土的所有类型。<code>$flogger</code>对象包含了用来推广的方法。对现在手头上的任务，我们只需要关心这三个引用。记住，你不需要考虑程序员如何从数据库取得这些信息，你只需要知道，他可以工作就可以了。这样你就可以专注于自己的工作，程序员也可以专注于自己的工作。<br>&emsp;&emsp;下面这个例子可能就是你要嵌入网页的的VTL的语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Hello $customer.Name!</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">    #foreach( $mud in $mudsOnSpecial )</span><br><span class=\"line\">      #if ( $customer.hasPurchased($mud) )</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">          &lt;td&gt;</span><br><span class=\"line\">            $flogger.getPromo( $mud )</span><br><span class=\"line\">          &lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">      #end</span><br><span class=\"line\">    #end</span><br><span class=\"line\">    &lt;/table&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>foreach</code>的细节稍后会进行深入的描述；现在重要的是这段脚本对你网页的影响。当一个喜欢明亮红土的人登录网站，将会看到明亮的红土突出显示在网页中售卖。当一个一直购买赤陶土泥的用户登录的时候他将会看见赤陶土泥正在网页的中央。Velocity的潜力和限制只和你的创造力相关。<br>&emsp;&emsp;VTL文档中还有很多其他的Velocity的元素，这些元素可以让你更加轻松的设计网页。当你熟悉了这些元素之后就会释放Velocity所有的强大的能力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://velocity.apache.org/engine/devel/user-guide.html\" target=\"_blank\" rel=\"noopener\">原文链接</a>  </p>\n<h4 id=\"关于此指南\"><a href=\"#关于此指南\" class=\"headerlink\" title=\"关于此指南\"></a>关于此指南</h4><p>&emsp;&emsp; 这篇指南主要是帮助网页设计师和内容提供商熟悉Velocity和语法简单，但是很强大的Velocity模板语言（VTL）。在这篇指南的很多示例通过使用Velocity向网站中嵌入内容，但是VTL的例子同样适用于其他网页和模板。<br>&emsp;&emsp; 谢谢选择Velocity。  </p>\n<h4 id=\"Velocity-是什么\"><a href=\"#Velocity-是什么\" class=\"headerlink\" title=\"Velocity 是什么\"></a>Velocity 是什么</h4><p>&emsp;&emsp; Velocity是一个基于Java的模板引擎。它允许网页设计师引用在Java中定义的方法。通过MVC的设计模式，网页设计师可以和Java程序员同时开发网站，这意味着设计师可以专注于创作精心设计的网页，程序员也可以专注写一流的代码。Velocity从web页面中分离了Java代码，使得Web站在运行很长时间后仍然很容易维护，同时也提供了 JSP或者PHP的另一种选择。<br>&emsp;&emsp;Velocity可以用来生成页面，SQL，PostScript和其他可以由模板输出的的东西。它既可以作为生成源码和报表单独使用，也可以和其他系统集成。当完成的时候Velocity将会为turbine web框架提供模板服务。通过使用Velocity+Turbine可以让开发者使用真正的MVC开发模式。  </p>\n<h4 id=\"Velocity-可以为我做什么\"><a href=\"#Velocity-可以为我做什么\" class=\"headerlink\" title=\"Velocity 可以为我做什么\"></a>Velocity 可以为我做什么</h4><p>#####　一个泥土店的例子<br>&emsp;&emsp;假设你是一个为专门卖泥土的店设计网上商店的设计师。暂且叫作“泥土网店”。店铺生意兴旺。客户订购了各种各样的大量泥浆。他们通过使用用户名和密码来登录网站，浏览订单，购买更多的泥浆。现在非常流行的赤陶土泥正在开卖，少数顾客购买了同样买卖的明亮的红色的泥，这个没有那么流行，所以就放到了网页边缘。顾客的信息记录在数据库中，那么问题来了，为什么不使用Velocity直接给那些喜欢不同泥土的客户推送他们感兴趣的泥土呢？<br>&emsp;&emsp;Velocity可以很容易的为你的用户定制页面。作为泥土屋的网页设计师，你希望用户登录之后就可以看到他们想要的页面。<br>&emsp;&emsp;你在公司见到了开发人员，并且每个人都同意使用<code>$customer</code>来保持用户登录之后用户的相关信息，使用<code>$mudsOnSpecial</code>来表示当前正在买的泥土的所有类型。<code>$flogger</code>对象包含了用来推广的方法。对现在手头上的任务，我们只需要关心这三个引用。记住，你不需要考虑程序员如何从数据库取得这些信息，你只需要知道，他可以工作就可以了。这样你就可以专注于自己的工作，程序员也可以专注于自己的工作。<br>&emsp;&emsp;下面这个例子可能就是你要嵌入网页的的VTL的语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Hello $customer.Name!</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">    #foreach( $mud in $mudsOnSpecial )</span><br><span class=\"line\">      #if ( $customer.hasPurchased($mud) )</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">          &lt;td&gt;</span><br><span class=\"line\">            $flogger.getPromo( $mud )</span><br><span class=\"line\">          &lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">      #end</span><br><span class=\"line\">    #end</span><br><span class=\"line\">    &lt;/table&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>foreach</code>的细节稍后会进行深入的描述；现在重要的是这段脚本对你网页的影响。当一个喜欢明亮红土的人登录网站，将会看到明亮的红土突出显示在网页中售卖。当一个一直购买赤陶土泥的用户登录的时候他将会看见赤陶土泥正在网页的中央。Velocity的潜力和限制只和你的创造力相关。<br>&emsp;&emsp;VTL文档中还有很多其他的Velocity的元素，这些元素可以让你更加轻松的设计网页。当你熟悉了这些元素之后就会释放Velocity所有的强大的能力。</p>\n"}],"Post":[{"title":"Ansible 入门指南","date":"2015-11-09T10:26:35.000Z","_content":"\n[原文地址](http://docs.ansible.com/ansible/intro_getting_started.html)\n\n## 快速入门\n\n### 前言\n\n&emsp;&emsp; 现在你已经知道如何[安装](http://docs.ansible.com/ansible/intro_installation.html)Ansible了，现在可以深入并开始使用Ansible的一些命令了。\n&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。\n&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读[特别命令简介](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。\n\n### 远程连接信息\n\n&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。\n&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。[加速功能](http://docs.ansible.com/ansible/playbooks_acceleration.html)。\n&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。\n&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在[配置文件](http://docs.ansible.com/ansible/intro_configuration.html)中切换到SCP模式。\n&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数`--ask-pass`。如果需要使用sudo权限，那么也要提供`--ask-sudo-pass`参数。\n&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。\n&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。\n\n### 第一个命令\n\n&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。\n&emsp;&emsp; 编辑（或者创建）`/etc/ansible/hosts`文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的`authorized_keys`文件中。\n\n```\n192.168.1.50\naserver.example.org\nbserver.example.org\n```\n\n&emsp;&emsp; 这是一个清单文件，同样会再[主机清单](http://docs.ansible.com/ansible/intro_inventory.html)中介绍。\n&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。\n\n```\nssh-agent bash\nssh-add ~/.ssh/id_rsa\n```\n\n(根据你的设置，你可能需要使用`--private-key`选项来制定一个pem文件)\n&emsp;&emsp; 现在可以ping一下所有的主机了。\n\n```\nansible all -m ping\n```\n\n&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上`-u`的选项。\n&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上`--sudo`选项。\n\n```\n# as bruce\n$ ansible all -m ping -u bruce\n# as bruce sudoing to root\n$ ansible all -m ping -u bruce --sudo\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce --sudo --sudo-user batman\n\n# With latest version of ansible `sudo` is deprecated so use become\n# as bruce, sudoing to root\n$ ansible all -m ping -u bruce -b\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce -b --become-user batman\n```\n\n(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)\n\n&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。\n\n```\n$ ansible all -a \"/bin/echo hello\"\n```\n\n&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读[更多命令介绍](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible [Playbooks](http://docs.ansible.com/ansible/playbooks.html)的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。\n\n### 主机密钥检查\n\n&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。\n&emsp;&emsp; 如果远程主机成新安装并且在`know_hosts`下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在`know_hosts`文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。\n&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改`/etc/ansible/ansible.cfg`或者是`~/.ansible.cfg`来关闭这个功能。\n\n```\n[default]\nhost_key_checking = False\n```\n\n&emsp;&emsp; 同样也可以通过环境变量来修改。\n\n```\n$ export ANSIBLE_HOST_KEY_CHECKING=False\n```\n\n&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。\n&emsp;&emsp; 除非Ansible的任务被标记为\"no_log:True\"，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。\n&emsp;&emsp; 如果要再本机开启log可以查看[配置章节](http://docs.ansible.com/ansible/intro_configuration.html)来设置“log_path”开启。企业用户可能会对[Ansible Tower](http://docs.ansible.com/ansible/tower.html)。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。\n","source":"_posts/Ansible-入门指南.md","raw":"title: Ansible 入门指南\ndate: 2015-11-09 18:26:35\ntags:\n  - Ansible\n  - Translate\n---\n\n[原文地址](http://docs.ansible.com/ansible/intro_getting_started.html)\n\n## 快速入门\n\n### 前言\n\n&emsp;&emsp; 现在你已经知道如何[安装](http://docs.ansible.com/ansible/intro_installation.html)Ansible了，现在可以深入并开始使用Ansible的一些命令了。\n&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。\n&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读[特别命令简介](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。\n\n### 远程连接信息\n\n&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。\n&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。[加速功能](http://docs.ansible.com/ansible/playbooks_acceleration.html)。\n&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。\n&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在[配置文件](http://docs.ansible.com/ansible/intro_configuration.html)中切换到SCP模式。\n&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数`--ask-pass`。如果需要使用sudo权限，那么也要提供`--ask-sudo-pass`参数。\n&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。\n&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。\n\n### 第一个命令\n\n&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。\n&emsp;&emsp; 编辑（或者创建）`/etc/ansible/hosts`文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的`authorized_keys`文件中。\n\n```\n192.168.1.50\naserver.example.org\nbserver.example.org\n```\n\n&emsp;&emsp; 这是一个清单文件，同样会再[主机清单](http://docs.ansible.com/ansible/intro_inventory.html)中介绍。\n&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。\n\n```\nssh-agent bash\nssh-add ~/.ssh/id_rsa\n```\n\n(根据你的设置，你可能需要使用`--private-key`选项来制定一个pem文件)\n&emsp;&emsp; 现在可以ping一下所有的主机了。\n\n```\nansible all -m ping\n```\n\n&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上`-u`的选项。\n&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上`--sudo`选项。\n\n```\n# as bruce\n$ ansible all -m ping -u bruce\n# as bruce sudoing to root\n$ ansible all -m ping -u bruce --sudo\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce --sudo --sudo-user batman\n\n# With latest version of ansible `sudo` is deprecated so use become\n# as bruce, sudoing to root\n$ ansible all -m ping -u bruce -b\n# as bruce, sudoing to batman\n$ ansible all -m ping -u bruce -b --become-user batman\n```\n\n(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)\n\n&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。\n\n```\n$ ansible all -a \"/bin/echo hello\"\n```\n\n&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读[更多命令介绍](http://docs.ansible.com/ansible/intro_adhoc.html)来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible [Playbooks](http://docs.ansible.com/ansible/playbooks.html)的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。\n\n### 主机密钥检查\n\n&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。\n&emsp;&emsp; 如果远程主机成新安装并且在`know_hosts`下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在`know_hosts`文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。\n&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改`/etc/ansible/ansible.cfg`或者是`~/.ansible.cfg`来关闭这个功能。\n\n```\n[default]\nhost_key_checking = False\n```\n\n&emsp;&emsp; 同样也可以通过环境变量来修改。\n\n```\n$ export ANSIBLE_HOST_KEY_CHECKING=False\n```\n\n&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。\n&emsp;&emsp; 除非Ansible的任务被标记为\"no_log:True\"，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。\n&emsp;&emsp; 如果要再本机开启log可以查看[配置章节](http://docs.ansible.com/ansible/intro_configuration.html)来设置“log_path”开启。企业用户可能会对[Ansible Tower](http://docs.ansible.com/ansible/tower.html)。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。\n","slug":"Ansible-入门指南","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds530000mart7ppg4upx","content":"<p><a href=\"http://docs.ansible.com/ansible/intro_getting_started.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&emsp;&emsp; 现在你已经知道如何<a href=\"http://docs.ansible.com/ansible/intro_installation.html\" target=\"_blank\" rel=\"noopener\">安装</a>Ansible了，现在可以深入并开始使用Ansible的一些命令了。<br>&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。<br>&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读<a href=\"http://docs.ansible.com/ansible/intro_adhoc.html\" target=\"_blank\" rel=\"noopener\">特别命令简介</a>来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。</p>\n<h3 id=\"远程连接信息\"><a href=\"#远程连接信息\" class=\"headerlink\" title=\"远程连接信息\"></a>远程连接信息</h3><p>&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。<br>&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。<a href=\"http://docs.ansible.com/ansible/playbooks_acceleration.html\" target=\"_blank\" rel=\"noopener\">加速功能</a>。<br>&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。<br>&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在<a href=\"http://docs.ansible.com/ansible/intro_configuration.html\" target=\"_blank\" rel=\"noopener\">配置文件</a>中切换到SCP模式。<br>&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数<code>--ask-pass</code>。如果需要使用sudo权限，那么也要提供<code>--ask-sudo-pass</code>参数。<br>&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。<br>&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。</p>\n<h3 id=\"第一个命令\"><a href=\"#第一个命令\" class=\"headerlink\" title=\"第一个命令\"></a>第一个命令</h3><p>&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。<br>&emsp;&emsp; 编辑（或者创建）<code>/etc/ansible/hosts</code>文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的<code>authorized_keys</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.1.50</span><br><span class=\"line\">aserver.example.org</span><br><span class=\"line\">bserver.example.org</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这是一个清单文件，同样会再<a href=\"http://docs.ansible.com/ansible/intro_inventory.html\" target=\"_blank\" rel=\"noopener\">主机清单</a>中介绍。<br>&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-agent bash</span><br><span class=\"line\">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>(根据你的设置，你可能需要使用<code>--private-key</code>选项来制定一个pem文件)<br>&emsp;&emsp; 现在可以ping一下所有的主机了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible all -m ping</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上<code>-u</code>的选项。<br>&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上<code>--sudo</code>选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># as bruce</span><br><span class=\"line\">$ ansible all -m ping -u bruce</span><br><span class=\"line\"># as bruce sudoing to root</span><br><span class=\"line\">$ ansible all -m ping -u bruce --sudo</span><br><span class=\"line\"># as bruce, sudoing to batman</span><br><span class=\"line\">$ ansible all -m ping -u bruce --sudo --sudo-user batman</span><br><span class=\"line\"></span><br><span class=\"line\"># With latest version of ansible `sudo` is deprecated so use become</span><br><span class=\"line\"># as bruce, sudoing to root</span><br><span class=\"line\">$ ansible all -m ping -u bruce -b</span><br><span class=\"line\"># as bruce, sudoing to batman</span><br><span class=\"line\">$ ansible all -m ping -u bruce -b --become-user batman</span><br></pre></td></tr></table></figure>\n<p>(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)</p>\n<p>&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ansible all -a &quot;/bin/echo hello&quot;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读<a href=\"http://docs.ansible.com/ansible/intro_adhoc.html\" target=\"_blank\" rel=\"noopener\">更多命令介绍</a>来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible <a href=\"http://docs.ansible.com/ansible/playbooks.html\" target=\"_blank\" rel=\"noopener\">Playbooks</a>的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。</p>\n<h3 id=\"主机密钥检查\"><a href=\"#主机密钥检查\" class=\"headerlink\" title=\"主机密钥检查\"></a>主机密钥检查</h3><p>&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。<br>&emsp;&emsp; 如果远程主机成新安装并且在<code>know_hosts</code>下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在<code>know_hosts</code>文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。<br>&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改<code>/etc/ansible/ansible.cfg</code>或者是<code>~/.ansible.cfg</code>来关闭这个功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[default]</span><br><span class=\"line\">host_key_checking = False</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同样也可以通过环境变量来修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export ANSIBLE_HOST_KEY_CHECKING=False</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。<br>&emsp;&emsp; 除非Ansible的任务被标记为”no_log:True”，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。<br>&emsp;&emsp; 如果要再本机开启log可以查看<a href=\"http://docs.ansible.com/ansible/intro_configuration.html\" target=\"_blank\" rel=\"noopener\">配置章节</a>来设置“log_path”开启。企业用户可能会对<a href=\"http://docs.ansible.com/ansible/tower.html\" target=\"_blank\" rel=\"noopener\">Ansible Tower</a>。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://docs.ansible.com/ansible/intro_getting_started.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&emsp;&emsp; 现在你已经知道如何<a href=\"http://docs.ansible.com/ansible/intro_installation.html\" target=\"_blank\" rel=\"noopener\">安装</a>Ansible了，现在可以深入并开始使用Ansible的一些命令了。<br>&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。<br>&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读<a href=\"http://docs.ansible.com/ansible/intro_adhoc.html\" target=\"_blank\" rel=\"noopener\">特别命令简介</a>来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。</p>\n<h3 id=\"远程连接信息\"><a href=\"#远程连接信息\" class=\"headerlink\" title=\"远程连接信息\"></a>远程连接信息</h3><p>&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。<br>&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。<a href=\"http://docs.ansible.com/ansible/playbooks_acceleration.html\" target=\"_blank\" rel=\"noopener\">加速功能</a>。<br>&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。<br>&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在<a href=\"http://docs.ansible.com/ansible/intro_configuration.html\" target=\"_blank\" rel=\"noopener\">配置文件</a>中切换到SCP模式。<br>&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数<code>--ask-pass</code>。如果需要使用sudo权限，那么也要提供<code>--ask-sudo-pass</code>参数。<br>&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。<br>&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。</p>\n<h3 id=\"第一个命令\"><a href=\"#第一个命令\" class=\"headerlink\" title=\"第一个命令\"></a>第一个命令</h3><p>&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。<br>&emsp;&emsp; 编辑（或者创建）<code>/etc/ansible/hosts</code>文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的<code>authorized_keys</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">192.168.1.50</span><br><span class=\"line\">aserver.example.org</span><br><span class=\"line\">bserver.example.org</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这是一个清单文件，同样会再<a href=\"http://docs.ansible.com/ansible/intro_inventory.html\" target=\"_blank\" rel=\"noopener\">主机清单</a>中介绍。<br>&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-agent bash</span><br><span class=\"line\">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>(根据你的设置，你可能需要使用<code>--private-key</code>选项来制定一个pem文件)<br>&emsp;&emsp; 现在可以ping一下所有的主机了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible all -m ping</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上<code>-u</code>的选项。<br>&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上<code>--sudo</code>选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># as bruce</span><br><span class=\"line\">$ ansible all -m ping -u bruce</span><br><span class=\"line\"># as bruce sudoing to root</span><br><span class=\"line\">$ ansible all -m ping -u bruce --sudo</span><br><span class=\"line\"># as bruce, sudoing to batman</span><br><span class=\"line\">$ ansible all -m ping -u bruce --sudo --sudo-user batman</span><br><span class=\"line\"></span><br><span class=\"line\"># With latest version of ansible `sudo` is deprecated so use become</span><br><span class=\"line\"># as bruce, sudoing to root</span><br><span class=\"line\">$ ansible all -m ping -u bruce -b</span><br><span class=\"line\"># as bruce, sudoing to batman</span><br><span class=\"line\">$ ansible all -m ping -u bruce -b --become-user batman</span><br></pre></td></tr></table></figure>\n<p>(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)</p>\n<p>&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ansible all -a &quot;/bin/echo hello&quot;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读<a href=\"http://docs.ansible.com/ansible/intro_adhoc.html\" target=\"_blank\" rel=\"noopener\">更多命令介绍</a>来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible <a href=\"http://docs.ansible.com/ansible/playbooks.html\" target=\"_blank\" rel=\"noopener\">Playbooks</a>的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。</p>\n<h3 id=\"主机密钥检查\"><a href=\"#主机密钥检查\" class=\"headerlink\" title=\"主机密钥检查\"></a>主机密钥检查</h3><p>&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。<br>&emsp;&emsp; 如果远程主机成新安装并且在<code>know_hosts</code>下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在<code>know_hosts</code>文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。<br>&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改<code>/etc/ansible/ansible.cfg</code>或者是<code>~/.ansible.cfg</code>来关闭这个功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[default]</span><br><span class=\"line\">host_key_checking = False</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同样也可以通过环境变量来修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export ANSIBLE_HOST_KEY_CHECKING=False</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。<br>&emsp;&emsp; 除非Ansible的任务被标记为”no_log:True”，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。<br>&emsp;&emsp; 如果要再本机开启log可以查看<a href=\"http://docs.ansible.com/ansible/intro_configuration.html\" target=\"_blank\" rel=\"noopener\">配置章节</a>来设置“log_path”开启。企业用户可能会对<a href=\"http://docs.ansible.com/ansible/tower.html\" target=\"_blank\" rel=\"noopener\">Ansible Tower</a>。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。</p>\n"},{"title":"Git - 分支管理","date":"2017-03-24T03:32:02.000Z","_content":"\n### 分支概要(Nutshell)\n\n&emsp;&emsp; 几乎每个版本管理系统（*VCS*）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。\n\n&emsp;&emsp; 真正理解分支首先需要明白**Git**是如何存储数据的：**Git**不会储存不同的或变化的点，而是保存一个快照（snapshot）。\n\n&emsp;&emsp; 当你提交一个commit，**Git**会存储一个commit对象，这个对象包含：\n  - 指向当前内容的快照的引用（pointer）\n  - 作者的姓名、邮件地址和提交的信息\n  - 指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）\n\n&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在**Git**的仓库(*repo*)存储文件的版本，同时添加校验码到添加的文件：\n```\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n```\n\n&emsp;&emsp; 当你执行`git commit`后提交这个commit，**Git**会校验和每个子目录（在这个case里，只有项目的根目录），同时在**Git repo**里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 -- 可以再次创建项目快照。\n\n&emsp;&emsp; 你的**Git repo**现在包含5个对象：\n  - 对应3个文件内容的3个二进制对象\n  - 一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系\n  - 一个commit对象，包含指向根树的引用，和commit对象的所有元数据\n\n&emsp;&emsp; 如下图所示：\n\n![Interceptors](https://git-scm.com/book/en/v2/images/commit-and-tree.png)\n\n&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用\n\n![Interceptors](https://git-scm.com/book/en/v2/images/commits-and-parents.png)\n\n&emsp;&emsp; **Git**的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。\n","source":"_posts/Git分支.md","raw":"title: Git - 分支管理\ndate: 2017-03-24 11:32:02\ntags:\n  - Git\n  - Git分支\n---\n\n### 分支概要(Nutshell)\n\n&emsp;&emsp; 几乎每个版本管理系统（*VCS*）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。\n\n&emsp;&emsp; 真正理解分支首先需要明白**Git**是如何存储数据的：**Git**不会储存不同的或变化的点，而是保存一个快照（snapshot）。\n\n&emsp;&emsp; 当你提交一个commit，**Git**会存储一个commit对象，这个对象包含：\n  - 指向当前内容的快照的引用（pointer）\n  - 作者的姓名、邮件地址和提交的信息\n  - 指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）\n\n&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在**Git**的仓库(*repo*)存储文件的版本，同时添加校验码到添加的文件：\n```\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n```\n\n&emsp;&emsp; 当你执行`git commit`后提交这个commit，**Git**会校验和每个子目录（在这个case里，只有项目的根目录），同时在**Git repo**里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 -- 可以再次创建项目快照。\n\n&emsp;&emsp; 你的**Git repo**现在包含5个对象：\n  - 对应3个文件内容的3个二进制对象\n  - 一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系\n  - 一个commit对象，包含指向根树的引用，和commit对象的所有元数据\n\n&emsp;&emsp; 如下图所示：\n\n![Interceptors](https://git-scm.com/book/en/v2/images/commit-and-tree.png)\n\n&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用\n\n![Interceptors](https://git-scm.com/book/en/v2/images/commits-and-parents.png)\n\n&emsp;&emsp; **Git**的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。\n","slug":"Git分支","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5b0002martvp1f2fix","content":"<h3 id=\"分支概要-Nutshell\"><a href=\"#分支概要-Nutshell\" class=\"headerlink\" title=\"分支概要(Nutshell)\"></a>分支概要(Nutshell)</h3><p>&emsp;&emsp; 几乎每个版本管理系统（<em>VCS</em>）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。</p>\n<p>&emsp;&emsp; 真正理解分支首先需要明白<strong>Git</strong>是如何存储数据的：<strong>Git</strong>不会储存不同的或变化的点，而是保存一个快照（snapshot）。</p>\n<p>&emsp;&emsp; 当你提交一个commit，<strong>Git</strong>会存储一个commit对象，这个对象包含：</p>\n<ul>\n<li>指向当前内容的快照的引用（pointer）</li>\n<li>作者的姓名、邮件地址和提交的信息</li>\n<li>指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）</li>\n</ul>\n<p>&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在<strong>Git</strong>的仓库(<em>repo</em>)存储文件的版本，同时添加校验码到添加的文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add README test.rb LICENSE</span><br><span class=\"line\">$ git commit -m &apos;The initial commit of my project&apos;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 当你执行<code>git commit</code>后提交这个commit，<strong>Git</strong>会校验和每个子目录（在这个case里，只有项目的根目录），同时在<strong>Git repo</strong>里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 – 可以再次创建项目快照。</p>\n<p>&emsp;&emsp; 你的<strong>Git repo</strong>现在包含5个对象：</p>\n<ul>\n<li>对应3个文件内容的3个二进制对象</li>\n<li>一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系</li>\n<li>一个commit对象，包含指向根树的引用，和commit对象的所有元数据</li>\n</ul>\n<p>&emsp;&emsp; 如下图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/images/commit-and-tree.png\" alt=\"Interceptors\"></p>\n<p>&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用</p>\n<p><img src=\"https://git-scm.com/book/en/v2/images/commits-and-parents.png\" alt=\"Interceptors\"></p>\n<p>&emsp;&emsp; <strong>Git</strong>的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"分支概要-Nutshell\"><a href=\"#分支概要-Nutshell\" class=\"headerlink\" title=\"分支概要(Nutshell)\"></a>分支概要(Nutshell)</h3><p>&emsp;&emsp; 几乎每个版本管理系统（<em>VCS</em>）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。</p>\n<p>&emsp;&emsp; 真正理解分支首先需要明白<strong>Git</strong>是如何存储数据的：<strong>Git</strong>不会储存不同的或变化的点，而是保存一个快照（snapshot）。</p>\n<p>&emsp;&emsp; 当你提交一个commit，<strong>Git</strong>会存储一个commit对象，这个对象包含：</p>\n<ul>\n<li>指向当前内容的快照的引用（pointer）</li>\n<li>作者的姓名、邮件地址和提交的信息</li>\n<li>指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）</li>\n</ul>\n<p>&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在<strong>Git</strong>的仓库(<em>repo</em>)存储文件的版本，同时添加校验码到添加的文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add README test.rb LICENSE</span><br><span class=\"line\">$ git commit -m &apos;The initial commit of my project&apos;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 当你执行<code>git commit</code>后提交这个commit，<strong>Git</strong>会校验和每个子目录（在这个case里，只有项目的根目录），同时在<strong>Git repo</strong>里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 – 可以再次创建项目快照。</p>\n<p>&emsp;&emsp; 你的<strong>Git repo</strong>现在包含5个对象：</p>\n<ul>\n<li>对应3个文件内容的3个二进制对象</li>\n<li>一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系</li>\n<li>一个commit对象，包含指向根树的引用，和commit对象的所有元数据</li>\n</ul>\n<p>&emsp;&emsp; 如下图所示：</p>\n<p><img src=\"https://git-scm.com/book/en/v2/images/commit-and-tree.png\" alt=\"Interceptors\"></p>\n<p>&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用</p>\n<p><img src=\"https://git-scm.com/book/en/v2/images/commits-and-parents.png\" alt=\"Interceptors\"></p>\n<p>&emsp;&emsp; <strong>Git</strong>的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。</p>\n"},{"title":"Go Web 架构","date":"2015-11-10T11:01:21.000Z","_content":"\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n&emsp;&emsp; `main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n&emsp;&emsp; 因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n&emsp;&emsp; `web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```\n-web/\n|-middleware/\n|-server.go\n```\n\n&emsp;&emsp; `server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n&emsp;&emsp; `Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n&emsp;&emsp; 在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\n&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n&emsp;&emsp; 将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n&emsp;&emsp; 毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n&emsp;&emsp; 同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n&emsp;&emsp; 然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","source":"_posts/Go-Web-架构.md","raw":"title: Go Web 架构\ndate: 2015-11-10 19:01:21\ntags:\n  - Go\n  - Architecture\n  - Translate\n---\n\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n&emsp;&emsp; `main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n&emsp;&emsp; 因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n&emsp;&emsp; `web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```\n-web/\n|-middleware/\n|-server.go\n```\n\n&emsp;&emsp; `server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n&emsp;&emsp; `Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n&emsp;&emsp; 在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\n&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n&emsp;&emsp; 将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n&emsp;&emsp; 毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n&emsp;&emsp; 同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n&emsp;&emsp; 然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","slug":"Go-Web-架构","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5j0005martgvaiov6r","content":"<p><a href=\"https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在<a href=\"https://www.refer-madness.com/\" target=\"_blank\" rel=\"noopener\">Refer Madness</a>中使用了下面这个架构。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-public/</span><br><span class=\"line\">-views/</span><br><span class=\"line\">-models/</span><br><span class=\"line\">-utils/</span><br><span class=\"line\">-controllers/</span><br><span class=\"line\">-web/</span><br><span class=\"line\">-main.go</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着<code>utils</code>只能访问他自己和<code>models</code>，<code>web</code>只能访问它自己，<code>controllers</code>，<code>utils</code>，<code>models</code>。<code>models</code>只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。</p>\n<h4 id=\"main-go\"><a href=\"#main-go\" class=\"headerlink\" title=\"main.go\"></a>main.go</h4><p>&emsp;&emsp; <code>main.go</code>是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/web&quot;</span><br><span class=\"line\">  &quot;github.com/stretchr/graceful&quot;</span><br><span class=\"line\">  &quot;os&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;</span><br><span class=\"line\">  dbURL := os.Getenv(&quot;MONGOLAB_URI&quot;)</span><br><span class=\"line\">  if isDevelopment &#123;</span><br><span class=\"line\">    dbURL = os.Getenv(&quot;DB_PORT_27017_TCP_ADDR&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)</span><br><span class=\"line\">  cuAccessor := utils.NewCurrentUserAccessor(1)</span><br><span class=\"line\">  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_ID&quot;),</span><br><span class=\"line\">    os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_SECRET&quot;), os.Getenv(&quot;SESSION_SECRET&quot;),</span><br><span class=\"line\">    isDevelopment, os.Getenv(&quot;GOOGLE_ANALYTICS_KEY&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  port := os.Getenv(&quot;PORT&quot;)</span><br><span class=\"line\">  if port == &quot;&quot; &#123;</span><br><span class=\"line\">    port = &quot;3000&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  graceful.Run(&quot;:&quot;+port, 0, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 因为<code>main.go</code>实在最低的层级，所以它可以访问所有的目录：在这个例子里是<code>web</code>和<code>utils</code>。在这里获取了所有的环境变量并把它们注入到合适的地方。在<code>main.go</code>中创建了服务器，注入依赖，并且在配置的端口启动服务器。</p>\n<h4 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"web\"></a>web</h4><p>&emsp;&emsp; <code>web</code>目录下是主要的服务代码，同时也包括了中间件代码。下面是<code>web</code>目录的内部结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-web/</span><br><span class=\"line\">|-middleware/</span><br><span class=\"line\">|-server.go</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; <code>server.go</code>包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package web</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/codegangsta/negroni&quot;</span><br><span class=\"line\">  &quot;github.com/goincremental/negroni-sessions&quot;</span><br><span class=\"line\">  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;</span><br><span class=\"line\">  &quot;github.com/gorilla/mux&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/controllers&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/web/middleware&quot;</span><br><span class=\"line\">  &quot;github.com/unrolled/secure&quot;</span><br><span class=\"line\">  &quot;gopkg.in/unrolled/render.v1&quot;</span><br><span class=\"line\">  &quot;html/template&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Server struct &#123;</span><br><span class=\"line\">  *negroni.Negroni</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,</span><br><span class=\"line\">  sessionSecret string, isDevelopment bool, gaKey string) *Server &#123;</span><br><span class=\"line\">  s := Server&#123;negroni.Classic()&#125;</span><br><span class=\"line\">  session := utils.NewSessionManager()</span><br><span class=\"line\">  basePage := utils.NewBasePageCreator(cua, gaKey)</span><br><span class=\"line\">  renderer := render.New()</span><br><span class=\"line\"></span><br><span class=\"line\">  router := mux.NewRouter()</span><br><span class=\"line\"></span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)</span><br><span class=\"line\">  accountController.Register(router)</span><br><span class=\"line\"></span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))</span><br><span class=\"line\">  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())</span><br><span class=\"line\">  s.UseHandler(router)</span><br><span class=\"line\">  return &amp;s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; <code>Server</code>结构体是一个<code>negroni.Negroni</code>的web server，在这个文件里有对<code>utils</code>和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package middleware</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/codegangsta/negroni&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Database struct &#123;</span><br><span class=\"line\">  da utils.DatabaseAccessor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewDatabase(da utils.DatabaseAccessor) *Database &#123;</span><br><span class=\"line\">  return &amp;Database&#123;da&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (d *Database) Middleware() negroni.HandlerFunc &#123;</span><br><span class=\"line\">  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) &#123;</span><br><span class=\"line\">    reqSession := d.da.Clone()</span><br><span class=\"line\">    defer reqSession.Close()</span><br><span class=\"line\">    d.da.Set(r, reqSession)</span><br><span class=\"line\">    next(rw, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从<a href=\"http://modocache.svbtle.com/restful-go\" target=\"_blank\" rel=\"noopener\">Brian Gesiak’s blog post on RESTful Go</a>中得到，将其修改为适合我的文件。</p>\n<h4 id=\"controllers\"><a href=\"#controllers\" class=\"headerlink\" title=\"controllers/\"></a>controllers/</h4><p>&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package controllers</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;encoding/json&quot;</span><br><span class=\"line\">  &quot;errors&quot;</span><br><span class=\"line\">  &quot;github.com/gorilla/mux&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/models&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2/bson&quot;</span><br><span class=\"line\">  &quot;gopkg.in/unrolled/render.v1&quot;</span><br><span class=\"line\">  &quot;html/template&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">  &quot;strings&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type ServiceControllerImpl struct &#123;</span><br><span class=\"line\">  currentUser utils.CurrentUserAccessor</span><br><span class=\"line\">  basePage    utils.BasePageCreator</span><br><span class=\"line\">  renderer    *render.Render</span><br><span class=\"line\">  database    utils.DatabaseAccessor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,</span><br><span class=\"line\">  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl &#123;</span><br><span class=\"line\">  return &amp;ServiceControllerImpl&#123;</span><br><span class=\"line\">    currentUser: currentUser,</span><br><span class=\"line\">    basePage:    basePage,</span><br><span class=\"line\">    renderer:    renderer,</span><br><span class=\"line\">    database:    database,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sc *ServiceControllerImpl) Register(router *mux.Router) &#123;</span><br><span class=\"line\">  router.HandleFunc(&quot;/service/&#123;id&#125;&quot;, sc.single)</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...</span><br><span class=\"line\"></span><br><span class=\"line\">type serviceResult struct &#123;</span><br><span class=\"line\">  *models.Service</span><br><span class=\"line\">  RandomCode *models.ReferralCode</span><br><span class=\"line\">  UserCode   *models.ReferralCode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type servicePage struct &#123;</span><br><span class=\"line\">  utils.BasePage</span><br><span class=\"line\">  ResultString string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">  data, err := sc.get(w, r)</span><br><span class=\"line\"></span><br><span class=\"line\">  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) &#123;</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string&#123;</span><br><span class=\"line\">        &quot;error&quot;: err.Error(),</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sc.renderer.JSON(w, http.StatusOK, data)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125; else if err != nil &#123;</span><br><span class=\"line\">    http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  resultString, _ := json.Marshal(data)</span><br><span class=\"line\">  t, _ := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)</span><br><span class=\"line\">  t.Execute(w, servicePage&#123;sc.basePage.Get(r), string(resultString)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"utils\"><a href=\"#utils\" class=\"headerlink\" title=\"utils/\"></a>utils/</h4><p>&emsp;&emsp; 在<code>utils</code>目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package utils</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/gorilla/context&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/models&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type CurrentUserAccessor struct &#123;</span><br><span class=\"line\">  key int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewCurrentUserAccessor(key int) *CurrentUserAccessor &#123;</span><br><span class=\"line\">  return &amp;CurrentUserAccessor&#123;key&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) &#123;</span><br><span class=\"line\">  context.Set(r, cua.key, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Clear(r *http.Request) &#123;</span><br><span class=\"line\">  context.Delete(r, cua.key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Get(r *http.Request) *models.User &#123;</span><br><span class=\"line\">  if rv := context.Get(r, cua.key); rv != nil &#123;</span><br><span class=\"line\">    return rv.(*models.User)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"models\"><a href=\"#models\" class=\"headerlink\" title=\"models/\"></a>models/</h4><p>&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package models</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2&quot;</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2/bson&quot;</span><br><span class=\"line\">  &quot;strings&quot;</span><br><span class=\"line\">  &quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Service struct &#123;</span><br><span class=\"line\">  // identification information</span><br><span class=\"line\">  ID          bson.ObjectId `bson:&quot;_id&quot;`</span><br><span class=\"line\">  Name        string        `bson:&quot;name&quot;`</span><br><span class=\"line\">  Description string        `bson:&quot;description&quot;`</span><br><span class=\"line\">  URL         string        `bson:&quot;url&quot;`</span><br><span class=\"line\">  Search      string        `bson:&quot;search&quot;`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewService(name, description, url string, creatorID bson.ObjectId) *Service &#123;</span><br><span class=\"line\">  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)</span><br><span class=\"line\">  return &amp;Service&#123;</span><br><span class=\"line\">    ID:            bson.NewObjectId(),</span><br><span class=\"line\">    Name:          name,</span><br><span class=\"line\">    URL:           url,</span><br><span class=\"line\">    Description:   description,</span><br><span class=\"line\">    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Service) Save(db *mgo.Database) error &#123;</span><br><span class=\"line\">  _, err := s.coll(db).UpsertId(s.ID, s)</span><br><span class=\"line\">  return err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error &#123;</span><br><span class=\"line\">  return s.coll(db).FindId(id).One(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (*Service) coll(db *mgo.Database) *mgo.Collection &#123;</span><br><span class=\"line\">  return db.C(&quot;service&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Services []Service</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error &#123;</span><br><span class=\"line\">  return s.coll(db).Find(bson.M&#123;&quot;_id&quot;: bson.M&#123;&quot;$in&quot;: ids&#125;&#125;).Sort(&quot;name&quot;).All(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (*Services) coll(db *mgo.Database) *mgo.Collection &#123;</span><br><span class=\"line\">  return db.C(&quot;service&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a>views/</h4><p>&emsp;&emsp; 将Golang的模板文件放到<code>views</code>目录下。这样，不管用什么样的模板引擎都可以直接放到<code>views</code>下。</p>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public/\"></a>public/</h4><p>&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如<code>css</code>,<code>img</code>,<code>scripts</code>。</p>\n<h4 id=\"如何运行\"><a href=\"#如何运行\" class=\"headerlink\" title=\"如何运行\"></a>如何运行</h4><p>&emsp;&emsp; 毫无疑问，我最喜欢的就是<a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">docker</a>，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到<code>$GOPATH/src/github.com/larryprice/refermadness</code>,运行<code>go get</code>来获取所有的依赖，然后运行 <code>go run main.go</code>或者<code>go build; ./refermadness</code>运行程序。如果你也喜欢使用docker，那么可以直接通过<code>Dockerfile</code>来运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM golang:1.4</span><br><span class=\"line\"></span><br><span class=\"line\">RUN go get github.com/codegangsta/gin</span><br><span class=\"line\"></span><br><span class=\"line\">ADD . /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">WORKDIR /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">RUN go get</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同时我也很喜欢<a href=\"https://github.com/docker/compose\" target=\"_blank\" rel=\"noopener\">compose</a>，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的<code>docker-compose.yml</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">  build: .</span><br><span class=\"line\">  command: gin run</span><br><span class=\"line\">  env_file: .env</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./:/go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">  working_dir: /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">    - &quot;3000:3000&quot;</span><br><span class=\"line\">  links:</span><br><span class=\"line\">    - db</span><br><span class=\"line\">sass:</span><br><span class=\"line\">  image: larryprice/sass</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./public/css:/src</span><br><span class=\"line\">jsx:</span><br><span class=\"line\">  image: larryprice/jsx</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./public/scripts:/src</span><br><span class=\"line\">db:</span><br><span class=\"line\">  image: mongo:3.0</span><br><span class=\"line\">  command: mongod --smallfiles --quiet --logpath=/dev/null</span><br><span class=\"line\">  volumes_from:</span><br><span class=\"line\">    - dbvolume</span><br><span class=\"line\">dbvolume:</span><br><span class=\"line\">  image: busybox:ubuntu-14.04</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - /data/db</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 然后运行<code>docker-compose up</code>来运行所有的容器并启动服务器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在<a href=\"https://www.refer-madness.com/\" target=\"_blank\" rel=\"noopener\">Refer Madness</a>中使用了下面这个架构。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-public/</span><br><span class=\"line\">-views/</span><br><span class=\"line\">-models/</span><br><span class=\"line\">-utils/</span><br><span class=\"line\">-controllers/</span><br><span class=\"line\">-web/</span><br><span class=\"line\">-main.go</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着<code>utils</code>只能访问他自己和<code>models</code>，<code>web</code>只能访问它自己，<code>controllers</code>，<code>utils</code>，<code>models</code>。<code>models</code>只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。</p>\n<h4 id=\"main-go\"><a href=\"#main-go\" class=\"headerlink\" title=\"main.go\"></a>main.go</h4><p>&emsp;&emsp; <code>main.go</code>是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/web&quot;</span><br><span class=\"line\">  &quot;github.com/stretchr/graceful&quot;</span><br><span class=\"line\">  &quot;os&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;</span><br><span class=\"line\">  dbURL := os.Getenv(&quot;MONGOLAB_URI&quot;)</span><br><span class=\"line\">  if isDevelopment &#123;</span><br><span class=\"line\">    dbURL = os.Getenv(&quot;DB_PORT_27017_TCP_ADDR&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)</span><br><span class=\"line\">  cuAccessor := utils.NewCurrentUserAccessor(1)</span><br><span class=\"line\">  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_ID&quot;),</span><br><span class=\"line\">    os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_SECRET&quot;), os.Getenv(&quot;SESSION_SECRET&quot;),</span><br><span class=\"line\">    isDevelopment, os.Getenv(&quot;GOOGLE_ANALYTICS_KEY&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  port := os.Getenv(&quot;PORT&quot;)</span><br><span class=\"line\">  if port == &quot;&quot; &#123;</span><br><span class=\"line\">    port = &quot;3000&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  graceful.Run(&quot;:&quot;+port, 0, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 因为<code>main.go</code>实在最低的层级，所以它可以访问所有的目录：在这个例子里是<code>web</code>和<code>utils</code>。在这里获取了所有的环境变量并把它们注入到合适的地方。在<code>main.go</code>中创建了服务器，注入依赖，并且在配置的端口启动服务器。</p>\n<h4 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"web\"></a>web</h4><p>&emsp;&emsp; <code>web</code>目录下是主要的服务代码，同时也包括了中间件代码。下面是<code>web</code>目录的内部结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-web/</span><br><span class=\"line\">|-middleware/</span><br><span class=\"line\">|-server.go</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; <code>server.go</code>包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package web</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/codegangsta/negroni&quot;</span><br><span class=\"line\">  &quot;github.com/goincremental/negroni-sessions&quot;</span><br><span class=\"line\">  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;</span><br><span class=\"line\">  &quot;github.com/gorilla/mux&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/controllers&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/web/middleware&quot;</span><br><span class=\"line\">  &quot;github.com/unrolled/secure&quot;</span><br><span class=\"line\">  &quot;gopkg.in/unrolled/render.v1&quot;</span><br><span class=\"line\">  &quot;html/template&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Server struct &#123;</span><br><span class=\"line\">  *negroni.Negroni</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,</span><br><span class=\"line\">  sessionSecret string, isDevelopment bool, gaKey string) *Server &#123;</span><br><span class=\"line\">  s := Server&#123;negroni.Classic()&#125;</span><br><span class=\"line\">  session := utils.NewSessionManager()</span><br><span class=\"line\">  basePage := utils.NewBasePageCreator(cua, gaKey)</span><br><span class=\"line\">  renderer := render.New()</span><br><span class=\"line\"></span><br><span class=\"line\">  router := mux.NewRouter()</span><br><span class=\"line\"></span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)</span><br><span class=\"line\">  accountController.Register(router)</span><br><span class=\"line\"></span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))</span><br><span class=\"line\">  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())</span><br><span class=\"line\">  s.UseHandler(router)</span><br><span class=\"line\">  return &amp;s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; <code>Server</code>结构体是一个<code>negroni.Negroni</code>的web server，在这个文件里有对<code>utils</code>和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package middleware</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/codegangsta/negroni&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Database struct &#123;</span><br><span class=\"line\">  da utils.DatabaseAccessor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewDatabase(da utils.DatabaseAccessor) *Database &#123;</span><br><span class=\"line\">  return &amp;Database&#123;da&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (d *Database) Middleware() negroni.HandlerFunc &#123;</span><br><span class=\"line\">  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) &#123;</span><br><span class=\"line\">    reqSession := d.da.Clone()</span><br><span class=\"line\">    defer reqSession.Close()</span><br><span class=\"line\">    d.da.Set(r, reqSession)</span><br><span class=\"line\">    next(rw, r)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从<a href=\"http://modocache.svbtle.com/restful-go\" target=\"_blank\" rel=\"noopener\">Brian Gesiak’s blog post on RESTful Go</a>中得到，将其修改为适合我的文件。</p>\n<h4 id=\"controllers\"><a href=\"#controllers\" class=\"headerlink\" title=\"controllers/\"></a>controllers/</h4><p>&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package controllers</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;encoding/json&quot;</span><br><span class=\"line\">  &quot;errors&quot;</span><br><span class=\"line\">  &quot;github.com/gorilla/mux&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/models&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/utils&quot;</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2/bson&quot;</span><br><span class=\"line\">  &quot;gopkg.in/unrolled/render.v1&quot;</span><br><span class=\"line\">  &quot;html/template&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">  &quot;strings&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type ServiceControllerImpl struct &#123;</span><br><span class=\"line\">  currentUser utils.CurrentUserAccessor</span><br><span class=\"line\">  basePage    utils.BasePageCreator</span><br><span class=\"line\">  renderer    *render.Render</span><br><span class=\"line\">  database    utils.DatabaseAccessor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,</span><br><span class=\"line\">  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl &#123;</span><br><span class=\"line\">  return &amp;ServiceControllerImpl&#123;</span><br><span class=\"line\">    currentUser: currentUser,</span><br><span class=\"line\">    basePage:    basePage,</span><br><span class=\"line\">    renderer:    renderer,</span><br><span class=\"line\">    database:    database,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sc *ServiceControllerImpl) Register(router *mux.Router) &#123;</span><br><span class=\"line\">  router.HandleFunc(&quot;/service/&#123;id&#125;&quot;, sc.single)</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...</span><br><span class=\"line\"></span><br><span class=\"line\">type serviceResult struct &#123;</span><br><span class=\"line\">  *models.Service</span><br><span class=\"line\">  RandomCode *models.ReferralCode</span><br><span class=\"line\">  UserCode   *models.ReferralCode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type servicePage struct &#123;</span><br><span class=\"line\">  utils.BasePage</span><br><span class=\"line\">  ResultString string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">  data, err := sc.get(w, r)</span><br><span class=\"line\"></span><br><span class=\"line\">  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) &#123;</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string&#123;</span><br><span class=\"line\">        &quot;error&quot;: err.Error(),</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sc.renderer.JSON(w, http.StatusOK, data)</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125; else if err != nil &#123;</span><br><span class=\"line\">    http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  resultString, _ := json.Marshal(data)</span><br><span class=\"line\">  t, _ := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)</span><br><span class=\"line\">  t.Execute(w, servicePage&#123;sc.basePage.Get(r), string(resultString)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"utils\"><a href=\"#utils\" class=\"headerlink\" title=\"utils/\"></a>utils/</h4><p>&emsp;&emsp; 在<code>utils</code>目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package utils</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;github.com/gorilla/context&quot;</span><br><span class=\"line\">  &quot;github.com/larryprice/refermadness/models&quot;</span><br><span class=\"line\">  &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type CurrentUserAccessor struct &#123;</span><br><span class=\"line\">  key int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewCurrentUserAccessor(key int) *CurrentUserAccessor &#123;</span><br><span class=\"line\">  return &amp;CurrentUserAccessor&#123;key&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) &#123;</span><br><span class=\"line\">  context.Set(r, cua.key, user)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Clear(r *http.Request) &#123;</span><br><span class=\"line\">  context.Delete(r, cua.key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (cua *CurrentUserAccessor) Get(r *http.Request) *models.User &#123;</span><br><span class=\"line\">  if rv := context.Get(r, cua.key); rv != nil &#123;</span><br><span class=\"line\">    return rv.(*models.User)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"models\"><a href=\"#models\" class=\"headerlink\" title=\"models/\"></a>models/</h4><p>&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package models</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2&quot;</span><br><span class=\"line\">  &quot;gopkg.in/mgo.v2/bson&quot;</span><br><span class=\"line\">  &quot;strings&quot;</span><br><span class=\"line\">  &quot;time&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type Service struct &#123;</span><br><span class=\"line\">  // identification information</span><br><span class=\"line\">  ID          bson.ObjectId `bson:&quot;_id&quot;`</span><br><span class=\"line\">  Name        string        `bson:&quot;name&quot;`</span><br><span class=\"line\">  Description string        `bson:&quot;description&quot;`</span><br><span class=\"line\">  URL         string        `bson:&quot;url&quot;`</span><br><span class=\"line\">  Search      string        `bson:&quot;search&quot;`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewService(name, description, url string, creatorID bson.ObjectId) *Service &#123;</span><br><span class=\"line\">  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)</span><br><span class=\"line\">  return &amp;Service&#123;</span><br><span class=\"line\">    ID:            bson.NewObjectId(),</span><br><span class=\"line\">    Name:          name,</span><br><span class=\"line\">    URL:           url,</span><br><span class=\"line\">    Description:   description,</span><br><span class=\"line\">    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Service) Save(db *mgo.Database) error &#123;</span><br><span class=\"line\">  _, err := s.coll(db).UpsertId(s.ID, s)</span><br><span class=\"line\">  return err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error &#123;</span><br><span class=\"line\">  return s.coll(db).FindId(id).One(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (*Service) coll(db *mgo.Database) *mgo.Collection &#123;</span><br><span class=\"line\">  return db.C(&quot;service&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Services []Service</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error &#123;</span><br><span class=\"line\">  return s.coll(db).Find(bson.M&#123;&quot;_id&quot;: bson.M&#123;&quot;$in&quot;: ids&#125;&#125;).Sort(&quot;name&quot;).All(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (*Services) coll(db *mgo.Database) *mgo.Collection &#123;</span><br><span class=\"line\">  return db.C(&quot;service&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a>views/</h4><p>&emsp;&emsp; 将Golang的模板文件放到<code>views</code>目录下。这样，不管用什么样的模板引擎都可以直接放到<code>views</code>下。</p>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public/\"></a>public/</h4><p>&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如<code>css</code>,<code>img</code>,<code>scripts</code>。</p>\n<h4 id=\"如何运行\"><a href=\"#如何运行\" class=\"headerlink\" title=\"如何运行\"></a>如何运行</h4><p>&emsp;&emsp; 毫无疑问，我最喜欢的就是<a href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\">docker</a>，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到<code>$GOPATH/src/github.com/larryprice/refermadness</code>,运行<code>go get</code>来获取所有的依赖，然后运行 <code>go run main.go</code>或者<code>go build; ./refermadness</code>运行程序。如果你也喜欢使用docker，那么可以直接通过<code>Dockerfile</code>来运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM golang:1.4</span><br><span class=\"line\"></span><br><span class=\"line\">RUN go get github.com/codegangsta/gin</span><br><span class=\"line\"></span><br><span class=\"line\">ADD . /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">WORKDIR /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">RUN go get</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 同时我也很喜欢<a href=\"https://github.com/docker/compose\" target=\"_blank\" rel=\"noopener\">compose</a>，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的<code>docker-compose.yml</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">  build: .</span><br><span class=\"line\">  command: gin run</span><br><span class=\"line\">  env_file: .env</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./:/go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">  working_dir: /go/src/github.com/larryprice/refermadness</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">    - &quot;3000:3000&quot;</span><br><span class=\"line\">  links:</span><br><span class=\"line\">    - db</span><br><span class=\"line\">sass:</span><br><span class=\"line\">  image: larryprice/sass</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./public/css:/src</span><br><span class=\"line\">jsx:</span><br><span class=\"line\">  image: larryprice/jsx</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - ./public/scripts:/src</span><br><span class=\"line\">db:</span><br><span class=\"line\">  image: mongo:3.0</span><br><span class=\"line\">  command: mongod --smallfiles --quiet --logpath=/dev/null</span><br><span class=\"line\">  volumes_from:</span><br><span class=\"line\">    - dbvolume</span><br><span class=\"line\">dbvolume:</span><br><span class=\"line\">  image: busybox:ubuntu-14.04</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - /data/db</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 然后运行<code>docker-compose up</code>来运行所有的容器并启动服务器。</p>\n"},{"title":"HTTP/2 和GO","date":"2015-11-12T03:39:21.000Z","_content":"[原文地址](https://www.ianlewis.org/en/http2-and-go)\n&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n&emsp;&emsp; Brad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。\n","source":"_posts/HTTP-2-和GO.md","raw":"title: HTTP/2 和GO\ndate: 2015-11-12 11:39:21\ntags:\n  - HTTP/2\n  - Translate\n  - Go\n---\n[原文地址](https://www.ianlewis.org/en/http2-and-go)\n&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n&emsp;&emsp; Brad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。\n","slug":"HTTP-2-和GO","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5n0006mart0cmmumlz","content":"<p><a href=\"https://www.ianlewis.org/en/http2-and-go\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。<br>&emsp;&emsp; Brad Fitzpatrick实现了一个<a href=\"https://godoc.org/golang.org/x/net/http2\" target=\"_blank\" rel=\"noopener\">golang.org/x/net/http2</a>的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。</p>\n<h3 id=\"创建HTTP-2服务器\"><a href=\"#创建HTTP-2服务器\" class=\"headerlink\" title=\"创建HTTP/2服务器\"></a>创建HTTP/2服务器</h3><p>&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用<code>http2.ConfigureServer()</code>来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;os&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;golang.org/x/net/http2&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    cwd, err := os.Getwd()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    srv := &amp;http.Server&#123;</span><br><span class=\"line\">        Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;</span><br><span class=\"line\">        Handler: http.FileServer(http.Dir(cwd)),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    http2.ConfigureServer(srv, &amp;http2.Server&#123;&#125;)</span><br><span class=\"line\">    log.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建HTTP-2-客户端\"><a href=\"#创建HTTP-2-客户端\" class=\"headerlink\" title=\"创建HTTP/2 客户端\"></a>创建HTTP/2 客户端</h3><p>&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用<code>http2.Transport</code>对象，将他传给<code>http</code>包的client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;io/ioutil&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;golang.org/x/net/http2&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    client := http.Client&#123;</span><br><span class=\"line\">        // InsecureTLSDial is temporary and will likely be</span><br><span class=\"line\">        // replaced by a different API later.</span><br><span class=\"line\">        Transport: &amp;http2.Transport&#123;InsecureTLSDial: true&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    resp, err := client.Get(&quot;https://localhost:8000/&quot;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(string(body))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"更多阅读\"><a href=\"#更多阅读\" class=\"headerlink\" title=\"更多阅读\"></a>更多阅读</h3><p>&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考<a href=\"https://http2.github.io/\" target=\"_blank\" rel=\"noopener\">HTTP/2 主页</a>，这个页面有很多其他资料的连接还有其他语言的实现。<br>&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么<a href=\"https://github.com/Jxck/http2\" target=\"_blank\" rel=\"noopener\">Jxck’s http2 implementation</a>的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些<a href=\"https://github.com/Jxck/http2/blob/master/sample/http.go\" target=\"_blank\" rel=\"noopener\">示例</a>。<br>&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.ianlewis.org/en/http2-and-go\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。<br>&emsp;&emsp; Brad Fitzpatrick实现了一个<a href=\"https://godoc.org/golang.org/x/net/http2\" target=\"_blank\" rel=\"noopener\">golang.org/x/net/http2</a>的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。</p>\n<h3 id=\"创建HTTP-2服务器\"><a href=\"#创建HTTP-2服务器\" class=\"headerlink\" title=\"创建HTTP/2服务器\"></a>创建HTTP/2服务器</h3><p>&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用<code>http2.ConfigureServer()</code>来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;os&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;golang.org/x/net/http2&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    cwd, err := os.Getwd()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    srv := &amp;http.Server&#123;</span><br><span class=\"line\">        Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;</span><br><span class=\"line\">        Handler: http.FileServer(http.Dir(cwd)),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    http2.ConfigureServer(srv, &amp;http2.Server&#123;&#125;)</span><br><span class=\"line\">    log.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建HTTP-2-客户端\"><a href=\"#创建HTTP-2-客户端\" class=\"headerlink\" title=\"创建HTTP/2 客户端\"></a>创建HTTP/2 客户端</h3><p>&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用<code>http2.Transport</code>对象，将他传给<code>http</code>包的client。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">    &quot;io/ioutil&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;golang.org/x/net/http2&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    client := http.Client&#123;</span><br><span class=\"line\">        // InsecureTLSDial is temporary and will likely be</span><br><span class=\"line\">        // replaced by a different API later.</span><br><span class=\"line\">        Transport: &amp;http2.Transport&#123;InsecureTLSDial: true&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    resp, err := client.Get(&quot;https://localhost:8000/&quot;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(string(body))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"更多阅读\"><a href=\"#更多阅读\" class=\"headerlink\" title=\"更多阅读\"></a>更多阅读</h3><p>&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考<a href=\"https://http2.github.io/\" target=\"_blank\" rel=\"noopener\">HTTP/2 主页</a>，这个页面有很多其他资料的连接还有其他语言的实现。<br>&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么<a href=\"https://github.com/Jxck/http2\" target=\"_blank\" rel=\"noopener\">Jxck’s http2 implementation</a>的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些<a href=\"https://github.com/Jxck/http2/blob/master/sample/http.go\" target=\"_blank\" rel=\"noopener\">示例</a>。<br>&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。</p>\n"},{"title":"Vagrant & Ansible 快速入门教程","date":"2015-11-07T16:39:10.000Z","_content":"\n[原文地址](https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html)  \n\n&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于[Chef](https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html)的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。  \n&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  \n\n## 为什么使用Ansible\n\n&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。  \n&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。\n\n## Ansible 和 Vagrant\n\n&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。\n\n## 基础\n\n&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。\n\n```\nmkdir -p ~/Projects/vagrant-ansible\ncd ~/Projects/vagrant-ansible\n```\n\n&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。\n\n```\nvagrant init ubuntu/trusty64\n```\n\n&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫`Vagrantfile`的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：\n\n```\nVAGRANTFILE_API_VERSION = \"2\"\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\nend\n```\n\n&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到`end`之前。\n\n```\nconfig.vm.network \"forworded_port\", guest: 80, host:8080\n```\n\n&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到`Vagrantfile`的`end`之前。\n\n```\nconfig.vm.provision :ansible do |ansible|\n  ansible.playbook = \"playbook.yml\"\nend\n```\n\n&emsp;&emsp; 以上所有的任务完成之后你的`Vagrantfile`将会是一下的配置。  \n\n```\nVAGRANTFILE_API_VERSION = \"2\"\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\n\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\n## 基本术语\n\n&emsp;&emsp; Ansible再你的服务器上运行一系列的*Tasks*。把Task想象成一个单一的Bash命令。接着是*playbook*，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的*Module*，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  \n\n## 第一个Playbook\n\n&emsp;&emsp; 创建一个叫`playbook.yml`的文件，这个名字必须和`Vagrantfile`的`ansible.playbook`相同。\n&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。  \n&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到`playbook.yml`文件中。\n\n```\n---\n- host: all\n  sudo: true\n  tasks:\n```\n\n&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值`all`，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 `tasks:` 用来添加Task。\n\n&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  \n1. 更新 Apt Cache\n2. 安装 Apache\n3. 安装 MySQL\n4. 安装 PHP\n\n&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。\n&emsp;&emsp; 首先我们给每一个task一个`name:`，这个可以是任何描述，它用来描述这个任务，如下:\n\n```\n- name: this should be some descriptive text\n```\n\n&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。\n\n```\napt\n```\n\n&emsp;&emsp; 紧随其后的是一些`key=value`的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。\n\n&emsp;&emsp; 安装Apache的任务如下：\n\n```\n- name: install apache\n  apt: name=apache2 state=present\n```\n\n&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到`playbook.yml`中，最后代码如下：\n\n```\n---\n- hosts: all\n  sudo: true\n  tasks:\n    - name: update apt cache\n      apt: update_cache=yes\n    - name: install apache\n      apt: name=apache2 state=present\n    - name: install mysql\n      apt: name=mysql-server state=present\n    - name: install php\n      apt: name=php5 state=present\n```\n\n&emsp;&emsp; 现在我们已经配置完了，然后运行`vagrant up`，你将会看到如下图所示：\n![result](https://adamcod.es/img/posts/vagrant-ansible-lamp.gif)  \n\n&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将`info.php`文件添加到`/var/www/html`下。\n```\n<?php phpinfo();?>\n```\n\n&emsp;&emsp; 然后在本机浏览器打开[http://localhost:8080/info.php](http://localhost:8080/info.php)，就会看到你想要看到的。\n\n**翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习**\n\n","source":"_posts/Vagrant-Ansible-快速入门教程.md","raw":"title: 'Vagrant & Ansible 快速入门教程'\ndate: 2015-11-08 00:39:10\ntags:\n  - Ansible\n  - Translate\n  - Vagrant\n---\n\n[原文地址](https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html)  \n\n&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于[Chef](https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html)的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。  \n&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  \n\n## 为什么使用Ansible\n\n&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。  \n&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。\n\n## Ansible 和 Vagrant\n\n&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。\n\n## 基础\n\n&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。\n\n```\nmkdir -p ~/Projects/vagrant-ansible\ncd ~/Projects/vagrant-ansible\n```\n\n&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。\n\n```\nvagrant init ubuntu/trusty64\n```\n\n&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫`Vagrantfile`的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：\n\n```\nVAGRANTFILE_API_VERSION = \"2\"\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\nend\n```\n\n&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到`end`之前。\n\n```\nconfig.vm.network \"forworded_port\", guest: 80, host:8080\n```\n\n&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到`Vagrantfile`的`end`之前。\n\n```\nconfig.vm.provision :ansible do |ansible|\n  ansible.playbook = \"playbook.yml\"\nend\n```\n\n&emsp;&emsp; 以上所有的任务完成之后你的`Vagrantfile`将会是一下的配置。  \n\n```\nVAGRANTFILE_API_VERSION = \"2\"\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\n\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\n## 基本术语\n\n&emsp;&emsp; Ansible再你的服务器上运行一系列的*Tasks*。把Task想象成一个单一的Bash命令。接着是*playbook*，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的*Module*，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  \n\n## 第一个Playbook\n\n&emsp;&emsp; 创建一个叫`playbook.yml`的文件，这个名字必须和`Vagrantfile`的`ansible.playbook`相同。\n&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。  \n&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到`playbook.yml`文件中。\n\n```\n---\n- host: all\n  sudo: true\n  tasks:\n```\n\n&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值`all`，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 `tasks:` 用来添加Task。\n\n&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  \n1. 更新 Apt Cache\n2. 安装 Apache\n3. 安装 MySQL\n4. 安装 PHP\n\n&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。\n&emsp;&emsp; 首先我们给每一个task一个`name:`，这个可以是任何描述，它用来描述这个任务，如下:\n\n```\n- name: this should be some descriptive text\n```\n\n&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。\n\n```\napt\n```\n\n&emsp;&emsp; 紧随其后的是一些`key=value`的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。\n\n&emsp;&emsp; 安装Apache的任务如下：\n\n```\n- name: install apache\n  apt: name=apache2 state=present\n```\n\n&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到`playbook.yml`中，最后代码如下：\n\n```\n---\n- hosts: all\n  sudo: true\n  tasks:\n    - name: update apt cache\n      apt: update_cache=yes\n    - name: install apache\n      apt: name=apache2 state=present\n    - name: install mysql\n      apt: name=mysql-server state=present\n    - name: install php\n      apt: name=php5 state=present\n```\n\n&emsp;&emsp; 现在我们已经配置完了，然后运行`vagrant up`，你将会看到如下图所示：\n![result](https://adamcod.es/img/posts/vagrant-ansible-lamp.gif)  \n\n&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将`info.php`文件添加到`/var/www/html`下。\n```\n<?php phpinfo();?>\n```\n\n&emsp;&emsp; 然后在本机浏览器打开[http://localhost:8080/info.php](http://localhost:8080/info.php)，就会看到你想要看到的。\n\n**翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习**\n\n","slug":"Vagrant-Ansible-快速入门教程","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5q0007martzqfjbvki","content":"<p><a href=\"https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<p>&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于<a href=\"https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html\" target=\"_blank\" rel=\"noopener\">Chef</a>的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。<br>&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  </p>\n<h2 id=\"为什么使用Ansible\"><a href=\"#为什么使用Ansible\" class=\"headerlink\" title=\"为什么使用Ansible\"></a>为什么使用Ansible</h2><p>&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。<br>&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。</p>\n<h2 id=\"Ansible-和-Vagrant\"><a href=\"#Ansible-和-Vagrant\" class=\"headerlink\" title=\"Ansible 和 Vagrant\"></a>Ansible 和 Vagrant</h2><p>&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p ~/Projects/vagrant-ansible</span><br><span class=\"line\">cd ~/Projects/vagrant-ansible</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant init ubuntu/trusty64</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫<code>Vagrantfile</code>的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VAGRANTFILE_API_VERSION = &quot;2&quot;</span><br><span class=\"line\">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;ubuntu/trusty64&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到<code>end</code>之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.vm.network &quot;forworded_port&quot;, guest: 80, host:8080</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到<code>Vagrantfile</code>的<code>end</code>之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.vm.provision :ansible do |ansible|</span><br><span class=\"line\">  ansible.playbook = &quot;playbook.yml&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 以上所有的任务完成之后你的<code>Vagrantfile</code>将会是一下的配置。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VAGRANTFILE_API_VERSION = &quot;2&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;ubuntu/trusty64&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080</span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision :ansible do |ansible|</span><br><span class=\"line\">    ansible.playbook = &quot;playbook.yml&quot;</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h2><p>&emsp;&emsp; Ansible再你的服务器上运行一系列的<em>Tasks</em>。把Task想象成一个单一的Bash命令。接着是<em>playbook</em>，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的<em>Module</em>，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  </p>\n<h2 id=\"第一个Playbook\"><a href=\"#第一个Playbook\" class=\"headerlink\" title=\"第一个Playbook\"></a>第一个Playbook</h2><p>&emsp;&emsp; 创建一个叫<code>playbook.yml</code>的文件，这个名字必须和<code>Vagrantfile</code>的<code>ansible.playbook</code>相同。<br>&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。<br>&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到<code>playbook.yml</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- host: all</span><br><span class=\"line\">  sudo: true</span><br><span class=\"line\">  tasks:</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值<code>all</code>，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 <code>tasks:</code> 用来添加Task。</p>\n<p>&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  </p>\n<ol>\n<li>更新 Apt Cache</li>\n<li>安装 Apache</li>\n<li>安装 MySQL</li>\n<li>安装 PHP</li>\n</ol>\n<p>&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。<br>&emsp;&emsp; 首先我们给每一个task一个<code>name:</code>，这个可以是任何描述，它用来描述这个任务，如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: this should be some descriptive text</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 紧随其后的是一些<code>key=value</code>的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。</p>\n<p>&emsp;&emsp; 安装Apache的任务如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: install apache</span><br><span class=\"line\">  apt: name=apache2 state=present</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到<code>playbook.yml</code>中，最后代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: all</span><br><span class=\"line\">  sudo: true</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: update apt cache</span><br><span class=\"line\">      apt: update_cache=yes</span><br><span class=\"line\">    - name: install apache</span><br><span class=\"line\">      apt: name=apache2 state=present</span><br><span class=\"line\">    - name: install mysql</span><br><span class=\"line\">      apt: name=mysql-server state=present</span><br><span class=\"line\">    - name: install php</span><br><span class=\"line\">      apt: name=php5 state=present</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 现在我们已经配置完了，然后运行<code>vagrant up</code>，你将会看到如下图所示：<br><img src=\"https://adamcod.es/img/posts/vagrant-ansible-lamp.gif\" alt=\"result\">  </p>\n<p>&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将<code>info.php</code>文件添加到<code>/var/www/html</code>下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 然后在本机浏览器打开<a href=\"http://localhost:8080/info.php\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/info.php</a>，就会看到你想要看到的。</p>\n<p><strong>翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://adamcod.es/2014/09/23/vagrant-ansible-quickstart-tutorial.html\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<p>&emsp;&emsp; 就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于<a href=\"https://adamcod.es/2013/01/15/vagrant-is-easy-chef-is-hard-part2.html\" target=\"_blank\" rel=\"noopener\">Chef</a>的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。<br>&emsp;&emsp; 看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  </p>\n<h2 id=\"为什么使用Ansible\"><a href=\"#为什么使用Ansible\" class=\"headerlink\" title=\"为什么使用Ansible\"></a>为什么使用Ansible</h2><p>&emsp;&emsp; Ansible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。<br>&emsp;&emsp; 为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。</p>\n<h2 id=\"Ansible-和-Vagrant\"><a href=\"#Ansible-和-Vagrant\" class=\"headerlink\" title=\"Ansible 和 Vagrant\"></a>Ansible 和 Vagrant</h2><p>&emsp;&emsp; 首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>&emsp;&emsp; 我们将会创建一个新的文件夹来开始我们的项目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p ~/Projects/vagrant-ansible</span><br><span class=\"line\">cd ~/Projects/vagrant-ansible</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 接着我们创建一个基于最新的Ubuntu的Vagrantfile。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant init ubuntu/trusty64</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行完这个命令后在项目目录下会有一个叫<code>Vagrantfile</code>的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VAGRANTFILE_API_VERSION = &quot;2&quot;</span><br><span class=\"line\">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;ubuntu/trusty64&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到<code>end</code>之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.vm.network &quot;forworded_port&quot;, guest: 80, host:8080</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到<code>Vagrantfile</code>的<code>end</code>之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.vm.provision :ansible do |ansible|</span><br><span class=\"line\">  ansible.playbook = &quot;playbook.yml&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 以上所有的任务完成之后你的<code>Vagrantfile</code>将会是一下的配置。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VAGRANTFILE_API_VERSION = &quot;2&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;ubuntu/trusty64&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080</span><br><span class=\"line\"></span><br><span class=\"line\">  config.vm.provision :ansible do |ansible|</span><br><span class=\"line\">    ansible.playbook = &quot;playbook.yml&quot;</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h2><p>&emsp;&emsp; Ansible再你的服务器上运行一系列的<em>Tasks</em>。把Task想象成一个单一的Bash命令。接着是<em>playbook</em>，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的<em>Module</em>，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  </p>\n<h2 id=\"第一个Playbook\"><a href=\"#第一个Playbook\" class=\"headerlink\" title=\"第一个Playbook\"></a>第一个Playbook</h2><p>&emsp;&emsp; 创建一个叫<code>playbook.yml</code>的文件，这个名字必须和<code>Vagrantfile</code>的<code>ansible.playbook</code>相同。<br>&emsp;&emsp; 所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。<br>&emsp;&emsp; 新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到<code>playbook.yml</code>文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- host: all</span><br><span class=\"line\">  sudo: true</span><br><span class=\"line\">  tasks:</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值<code>all</code>，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 <code>tasks:</code> 用来添加Task。</p>\n<p>&emsp;&emsp; 要安装LAMP技术栈的基本步骤是：  </p>\n<ol>\n<li>更新 Apt Cache</li>\n<li>安装 Apache</li>\n<li>安装 MySQL</li>\n<li>安装 PHP</li>\n</ol>\n<p>&emsp;&emsp; 这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。<br>&emsp;&emsp; 首先我们给每一个task一个<code>name:</code>，这个可以是任何描述，它用来描述这个任务，如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: this should be some descriptive text</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 紧随其后的是一些<code>key=value</code>的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。</p>\n<p>&emsp;&emsp; 安装Apache的任务如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: install apache</span><br><span class=\"line\">  apt: name=apache2 state=present</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到<code>playbook.yml</code>中，最后代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: all</span><br><span class=\"line\">  sudo: true</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: update apt cache</span><br><span class=\"line\">      apt: update_cache=yes</span><br><span class=\"line\">    - name: install apache</span><br><span class=\"line\">      apt: name=apache2 state=present</span><br><span class=\"line\">    - name: install mysql</span><br><span class=\"line\">      apt: name=mysql-server state=present</span><br><span class=\"line\">    - name: install php</span><br><span class=\"line\">      apt: name=php5 state=present</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 现在我们已经配置完了，然后运行<code>vagrant up</code>，你将会看到如下图所示：<br><img src=\"https://adamcod.es/img/posts/vagrant-ansible-lamp.gif\" alt=\"result\">  </p>\n<p>&emsp;&emsp; 这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将<code>info.php</code>文件添加到<code>/var/www/html</code>下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 然后在本机浏览器打开<a href=\"http://localhost:8080/info.php\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/info.php</a>，就会看到你想要看到的。</p>\n<p><strong>翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习</strong></p>\n"},{"title":"Vagrant 入门指南","date":"2015-11-06T08:49:47.000Z","_content":"[原文地址](https://docs.vagrantup.com/v2/getting-started/index.html)\n## 开始\n\n&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。  \n&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下[Why Vagrant](https://docs.vagrantup.com/v2/why-vagrant/)。  \n&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的[提供商](https://docs.vagrantup.com/v2/getting-started/providers.html)\n\n> 更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O'Reilly 出版的[Vagrant: Up and Running](http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449335837&linkCode=as2&tag=vagrant-20) 更感兴趣，\n\n## 启动运行\n\n```\n$ vagrant init hashicorp/precise32\n$ vagrant up\n```\n\n&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过`vagrant ssh` 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用`vagrant destory`来删除所有的痕迹。  \n&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。    \n&emsp;&emsp;通过使用Vagrant,对于任何项目来说`vagrant up` 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。    \n&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  \n\n## 项目配置\n\n&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个[Vagrantfile](https://docs.vagrantup.com/v2/vagrantfile/)。该文件的作用有两个:  \n1. 指定项目的根目录。很多Vagrant的配置跟这个目录有关。  \n2. 描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  \n\n&emsp;&emsp; Vagrant 有一个内建的命令`vagrant init`用来初始化项目。出于本指南的目的，请在终端输入一下命令  \n\n```\n$ mkdir vagrant_getting_started\n$ cd vagrant_getting_started\n$ vagrant init\n```\n\n&emsp;&emsp; 以上命令将在你的当前目录下创建`Vagrantfile`。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。  \n&emsp;&emsp; 同样也可以在一个已存在的目录下运行`vagrant init`，来未一个已有项目设置Vagrant环境。\n&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。\n\n## Boxes\n\n&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  \n\n###  安装box\n\n&emsp;&emsp; 如果你运行了[开始指南](https://docs.vagrantup.com/v2/getting-started/)的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。  \n&emsp;&emsp; Boxes 由Vagrant的`vagrant box add`命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  \n\n```\n$ vagrant box add hashicorp/precise32\n```\n\n&emsp;&emsp; 这个将从[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)下载一个名字为`hashicorp/precise32`的box。你可以从HashiCorp's Atlas box catalog中找到各种box。很容易从HashiCorp's Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。\n&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的`hashicorp/precise32`的box，其中一个主机添加文件并不会影响另一个主机。  \n\n### 使用box\n\n&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\nend\n```\n&emsp;&emsp; 在这个例子中，\"hashicorp/precise32\" 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。  \n&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  \n\n### 寻找更多box\n\n&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的\"hashicorp/precise32\"的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。  \n&emsp;&emsp; 寻找更多box的最好的地方是[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。  \n&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。  \n&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  \n\n## 启动并且SSH登陆\n\n&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  \n\n```\nvagrant up\n```\n\n&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：\n\n```\nvagrant ssh\n```\n\n&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心`rm -rf /` 这种命令，因为Vagrant的`/vagrant`目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。  \n&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。  \n&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用`vagrant destory`来清除你再虚拟机的痕迹。\n\n## 同步文件夹\n\n&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用*同步文件夹*Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。  \n&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的`/vagrant`的。再次运行`vagrant up` 并且ssh到虚拟机。\n\n```\n$ vagrant up\n...\n$ vagrant ssh\n...\nvagrant@precise32:~$ ls /vagrant\nVagrantfile\n```\n\n&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：\n\n```\nvagrant@precise32:~$ touch /vagrant/foo\nvagrant@precise32:~$ exit\n$ ls\nfoo Vagrantfile\n```\n\n&emsp;&emsp; 哇！`foo`已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。  \n&emsp;&emsp; 通过使用[同步文件夹](https://docs.vagrantup.com/v2/synced-folders/)，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。\n\n## 配置\n\n&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。  \n&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你`vagrant up`的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  \n\n### 安装Apache\n\n&emsp;&emsp; 对于我们的项目来说可以仅仅使用[Apache](http://httpd.apache.org/)，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为`bootstrap.sh`的文件。  \n\n```\n#!/usr/bin/env bash\n\napt-get update\napt-get install -y apache2\nif ! [ -L /var/www ]; then\n  rm -rf /var/www\n  ln -fs /vagrant /var/www\nfi \n```\n\n&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\nend\n```\n\n&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用`shell`配置器运行`bootstrap.sh`脚本启动机器。脚本的路径是项目更目录的相对路径。\n\n### 配置\n\n&emsp;&emsp; 在所有的事情都配置好好，运行`vagrant up`来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行`vagrant reload --provision`, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。`--provision`表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。\n&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。\n\n```\n$ vagrant ssh\n...\nvagrant@precise32:~$ wget -qO- 127.0.0.1\n```\n\n&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的`DocumentRoot`指向了`/vagrant`。\n&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。\n\n## 网络\n\n&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。\n\n### 端口转发\n\n&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。\n&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\n  config.vm.network :forwarded_port, guest: 80, host: 4567\nend\n```\n\n&emsp;&emsp; 运行`vagrant reload`，或者如果没有启动过虚拟机运行`vagrant up`。使配置生效。\n\n### 其他的网络配置\n\n&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读[networking](https://docs.vagrantup.com/v2/networking/)章节。\n\n## 共享\n\n&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做[Vagrant Share](https://docs.vagrantup.com/v2/share/)。\n&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。\n\n### 登录Harshicorp's Altas\n\n&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个[HashiCorp's Altas](https://atlas.hashicorp.com/)的账号。不必担心，它是免费的。\n&emsp;&emsp; 当你有了账号后，你就可以使用`vagrant login`来登陆\n\n```\n$ vagrant login\nUsername or Email: mitchellh\nPassword (will be hidden):\nYou're now logged in!\n```\n\n### 共享\n\n&emsp;&emsp; 当你登录之后，你就可以使用`vagrant share`来共享环境了。\n\n```\n$ vagrant share\n...\n==> default: Your Vagrant Share is running!\n==> default: URL: http://frosty-weasel-0857.vagrantshare.com\n...\n```\n\n&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面`vagrant share`生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。\n&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。\n&emsp;&emsp; 关闭共享只需要使用`Ctrl+C`即可，重新刷新URL，你会发现你的环境已经不再被共享了。\n&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的[Vagrant Share](https://docs.vagrantup.com/v2/share/)文档。\n\n## 关闭\n\n&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。\n&emsp;&emsp; 通过Vagrant，我们可以*suspend*,*halt*或者*destory*虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  \n* **suspend** 使用`vagrant suspend`命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用`vagrant up`命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  \n* **halting** 使用`vagrant halt`命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行`vagrant up`命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。\n* **destory** 使用`vagrant destory`命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用`vagrant up`的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是`vagrant up`将会从头开始，这样会花费更长的时间。\n\n## 重新构建\n\n&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过`vagrant up`来轻松运行他。\n&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行`vagrant up`即可重新创建相同的环境。\n\n### Provider\n\n&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如[VMware](https://docs.vagrantup.com/v2/vmware/),[AWS](http://github.com/mitchellh/vagrant-aws)等。继续阅读来了解如何它们的更多信息以及如何使用它们。\n&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：\n\n```\n$ vagrant up --provider=vmware_fusion\n```\n\n准备转移到云端了？使用AWS：\n\n```\n$ vagrant up --provider=aws\n```\n\n&emsp;&emsp; 当你使用其他Provider运行`vagrant up`的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：`vagrant destory`，无需额外的参数。\n&emsp;&emsp; 更多信息请参考[provider](https://docs.vagrantup.com/v2/providers/)。\n[1]: https://www.virtualbox.org/\n\n\n","source":"_posts/Vagrant-入门指南.md","raw":"title: Vagrant 入门指南\ndate: 2015-11-06 16:49:47\ntags:\n  - Vagrant \n  - Translate\n---\n[原文地址](https://docs.vagrantup.com/v2/getting-started/index.html)\n## 开始\n\n&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。  \n&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下[Why Vagrant](https://docs.vagrantup.com/v2/why-vagrant/)。  \n&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的[提供商](https://docs.vagrantup.com/v2/getting-started/providers.html)\n\n> 更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O'Reilly 出版的[Vagrant: Up and Running](http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1449335837&linkCode=as2&tag=vagrant-20) 更感兴趣，\n\n## 启动运行\n\n```\n$ vagrant init hashicorp/precise32\n$ vagrant up\n```\n\n&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过`vagrant ssh` 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用`vagrant destory`来删除所有的痕迹。  \n&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。    \n&emsp;&emsp;通过使用Vagrant,对于任何项目来说`vagrant up` 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。    \n&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  \n\n## 项目配置\n\n&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个[Vagrantfile](https://docs.vagrantup.com/v2/vagrantfile/)。该文件的作用有两个:  \n1. 指定项目的根目录。很多Vagrant的配置跟这个目录有关。  \n2. 描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  \n\n&emsp;&emsp; Vagrant 有一个内建的命令`vagrant init`用来初始化项目。出于本指南的目的，请在终端输入一下命令  \n\n```\n$ mkdir vagrant_getting_started\n$ cd vagrant_getting_started\n$ vagrant init\n```\n\n&emsp;&emsp; 以上命令将在你的当前目录下创建`Vagrantfile`。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。  \n&emsp;&emsp; 同样也可以在一个已存在的目录下运行`vagrant init`，来未一个已有项目设置Vagrant环境。\n&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。\n\n## Boxes\n\n&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  \n\n###  安装box\n\n&emsp;&emsp; 如果你运行了[开始指南](https://docs.vagrantup.com/v2/getting-started/)的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。  \n&emsp;&emsp; Boxes 由Vagrant的`vagrant box add`命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  \n\n```\n$ vagrant box add hashicorp/precise32\n```\n\n&emsp;&emsp; 这个将从[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)下载一个名字为`hashicorp/precise32`的box。你可以从HashiCorp's Atlas box catalog中找到各种box。很容易从HashiCorp's Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。\n&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的`hashicorp/precise32`的box，其中一个主机添加文件并不会影响另一个主机。  \n\n### 使用box\n\n&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\nend\n```\n&emsp;&emsp; 在这个例子中，\"hashicorp/precise32\" 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。  \n&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  \n\n### 寻找更多box\n\n&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的\"hashicorp/precise32\"的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。  \n&emsp;&emsp; 寻找更多box的最好的地方是[HashiCorp's Atlas box catalog](https://atlas.hashicorp.com/boxes/search)。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。  \n&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。  \n&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  \n\n## 启动并且SSH登陆\n\n&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  \n\n```\nvagrant up\n```\n\n&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：\n\n```\nvagrant ssh\n```\n\n&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心`rm -rf /` 这种命令，因为Vagrant的`/vagrant`目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。  \n&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。  \n&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用`vagrant destory`来清除你再虚拟机的痕迹。\n\n## 同步文件夹\n\n&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用*同步文件夹*Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。  \n&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的`/vagrant`的。再次运行`vagrant up` 并且ssh到虚拟机。\n\n```\n$ vagrant up\n...\n$ vagrant ssh\n...\nvagrant@precise32:~$ ls /vagrant\nVagrantfile\n```\n\n&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：\n\n```\nvagrant@precise32:~$ touch /vagrant/foo\nvagrant@precise32:~$ exit\n$ ls\nfoo Vagrantfile\n```\n\n&emsp;&emsp; 哇！`foo`已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。  \n&emsp;&emsp; 通过使用[同步文件夹](https://docs.vagrantup.com/v2/synced-folders/)，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。\n\n## 配置\n\n&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。  \n&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你`vagrant up`的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  \n\n### 安装Apache\n\n&emsp;&emsp; 对于我们的项目来说可以仅仅使用[Apache](http://httpd.apache.org/)，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为`bootstrap.sh`的文件。  \n\n```\n#!/usr/bin/env bash\n\napt-get update\napt-get install -y apache2\nif ! [ -L /var/www ]; then\n  rm -rf /var/www\n  ln -fs /vagrant /var/www\nfi \n```\n\n&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\nend\n```\n\n&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用`shell`配置器运行`bootstrap.sh`脚本启动机器。脚本的路径是项目更目录的相对路径。\n\n### 配置\n\n&emsp;&emsp; 在所有的事情都配置好好，运行`vagrant up`来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行`vagrant reload --provision`, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。`--provision`表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。\n&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。\n\n```\n$ vagrant ssh\n...\nvagrant@precise32:~$ wget -qO- 127.0.0.1\n```\n\n&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的`DocumentRoot`指向了`/vagrant`。\n&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。\n\n## 网络\n\n&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。\n\n### 端口转发\n\n&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。\n&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：\n\n```\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise32\"\n  config.vm.provision :shell, path: \"bootstrap.sh\"\n  config.vm.network :forwarded_port, guest: 80, host: 4567\nend\n```\n\n&emsp;&emsp; 运行`vagrant reload`，或者如果没有启动过虚拟机运行`vagrant up`。使配置生效。\n\n### 其他的网络配置\n\n&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读[networking](https://docs.vagrantup.com/v2/networking/)章节。\n\n## 共享\n\n&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做[Vagrant Share](https://docs.vagrantup.com/v2/share/)。\n&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。\n\n### 登录Harshicorp's Altas\n\n&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个[HashiCorp's Altas](https://atlas.hashicorp.com/)的账号。不必担心，它是免费的。\n&emsp;&emsp; 当你有了账号后，你就可以使用`vagrant login`来登陆\n\n```\n$ vagrant login\nUsername or Email: mitchellh\nPassword (will be hidden):\nYou're now logged in!\n```\n\n### 共享\n\n&emsp;&emsp; 当你登录之后，你就可以使用`vagrant share`来共享环境了。\n\n```\n$ vagrant share\n...\n==> default: Your Vagrant Share is running!\n==> default: URL: http://frosty-weasel-0857.vagrantshare.com\n...\n```\n\n&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面`vagrant share`生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。\n&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。\n&emsp;&emsp; 关闭共享只需要使用`Ctrl+C`即可，重新刷新URL，你会发现你的环境已经不再被共享了。\n&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的[Vagrant Share](https://docs.vagrantup.com/v2/share/)文档。\n\n## 关闭\n\n&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。\n&emsp;&emsp; 通过Vagrant，我们可以*suspend*,*halt*或者*destory*虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  \n* **suspend** 使用`vagrant suspend`命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用`vagrant up`命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  \n* **halting** 使用`vagrant halt`命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行`vagrant up`命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。\n* **destory** 使用`vagrant destory`命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用`vagrant up`的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是`vagrant up`将会从头开始，这样会花费更长的时间。\n\n## 重新构建\n\n&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过`vagrant up`来轻松运行他。\n&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行`vagrant up`即可重新创建相同的环境。\n\n### Provider\n\n&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如[VMware](https://docs.vagrantup.com/v2/vmware/),[AWS](http://github.com/mitchellh/vagrant-aws)等。继续阅读来了解如何它们的更多信息以及如何使用它们。\n&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：\n\n```\n$ vagrant up --provider=vmware_fusion\n```\n\n准备转移到云端了？使用AWS：\n\n```\n$ vagrant up --provider=aws\n```\n\n&emsp;&emsp; 当你使用其他Provider运行`vagrant up`的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：`vagrant destory`，无需额外的参数。\n&emsp;&emsp; 更多信息请参考[provider](https://docs.vagrantup.com/v2/providers/)。\n[1]: https://www.virtualbox.org/\n\n\n","slug":"Vagrant-入门指南","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5t0009mart1fz1gv3b","content":"<p><a href=\"https://docs.vagrantup.com/v2/getting-started/index.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。<br>&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下<a href=\"https://docs.vagrantup.com/v2/why-vagrant/\" target=\"_blank\" rel=\"noopener\">Why Vagrant</a>。<br>&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的<a href=\"https://docs.vagrantup.com/v2/getting-started/providers.html\" target=\"_blank\" rel=\"noopener\">提供商</a></p>\n<blockquote>\n<p>更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O’Reilly 出版的<a href=\"http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449335837&amp;linkCode=as2&amp;tag=vagrant-20\" target=\"_blank\" rel=\"noopener\">Vagrant: Up and Running</a> 更感兴趣，</p>\n</blockquote>\n<h2 id=\"启动运行\"><a href=\"#启动运行\" class=\"headerlink\" title=\"启动运行\"></a>启动运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant init hashicorp/precise32</span><br><span class=\"line\">$ vagrant up</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过<code>vagrant ssh</code> 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用<code>vagrant destory</code>来删除所有的痕迹。<br>&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。<br>&emsp;&emsp;通过使用Vagrant,对于任何项目来说<code>vagrant up</code> 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。<br>&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  </p>\n<h2 id=\"项目配置\"><a href=\"#项目配置\" class=\"headerlink\" title=\"项目配置\"></a>项目配置</h2><p>&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个<a href=\"https://docs.vagrantup.com/v2/vagrantfile/\" target=\"_blank\" rel=\"noopener\">Vagrantfile</a>。该文件的作用有两个:  </p>\n<ol>\n<li>指定项目的根目录。很多Vagrant的配置跟这个目录有关。  </li>\n<li>描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  </li>\n</ol>\n<p>&emsp;&emsp; Vagrant 有一个内建的命令<code>vagrant init</code>用来初始化项目。出于本指南的目的，请在终端输入一下命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir vagrant_getting_started</span><br><span class=\"line\">$ cd vagrant_getting_started</span><br><span class=\"line\">$ vagrant init</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 以上命令将在你的当前目录下创建<code>Vagrantfile</code>。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。<br>&emsp;&emsp; 同样也可以在一个已存在的目录下运行<code>vagrant init</code>，来未一个已有项目设置Vagrant环境。<br>&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。</p>\n<h2 id=\"Boxes\"><a href=\"#Boxes\" class=\"headerlink\" title=\"Boxes\"></a>Boxes</h2><p>&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  </p>\n<h3 id=\"安装box\"><a href=\"#安装box\" class=\"headerlink\" title=\"安装box\"></a>安装box</h3><p>&emsp;&emsp; 如果你运行了<a href=\"https://docs.vagrantup.com/v2/getting-started/\" target=\"_blank\" rel=\"noopener\">开始指南</a>的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。<br>&emsp;&emsp; Boxes 由Vagrant的<code>vagrant box add</code>命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant box add hashicorp/precise32</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个将从<a href=\"https://atlas.hashicorp.com/boxes/search\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Atlas box catalog</a>下载一个名字为<code>hashicorp/precise32</code>的box。你可以从HashiCorp’s Atlas box catalog中找到各种box。很容易从HashiCorp’s Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。<br>&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的<code>hashicorp/precise32</code>的box，其中一个主机添加文件并不会影响另一个主机。  </p>\n<h3 id=\"使用box\"><a href=\"#使用box\" class=\"headerlink\" title=\"使用box\"></a>使用box</h3><p>&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 在这个例子中，”hashicorp/precise32” 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。<br>&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  </p>\n<h3 id=\"寻找更多box\"><a href=\"#寻找更多box\" class=\"headerlink\" title=\"寻找更多box\"></a>寻找更多box</h3><p>&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的”hashicorp/precise32”的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。<br>&emsp;&emsp; 寻找更多box的最好的地方是<a href=\"https://atlas.hashicorp.com/boxes/search\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Atlas box catalog</a>。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。<br>&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。<br>&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  </p>\n<h2 id=\"启动并且SSH登陆\"><a href=\"#启动并且SSH登陆\" class=\"headerlink\" title=\"启动并且SSH登陆\"></a>启动并且SSH登陆</h2><p>&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant up</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant ssh</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心<code>rm -rf /</code> 这种命令，因为Vagrant的<code>/vagrant</code>目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。<br>&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。<br>&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用<code>vagrant destory</code>来清除你再虚拟机的痕迹。</p>\n<h2 id=\"同步文件夹\"><a href=\"#同步文件夹\" class=\"headerlink\" title=\"同步文件夹\"></a>同步文件夹</h2><p>&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用<em>同步文件夹</em>Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。<br>&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的<code>/vagrant</code>的。再次运行<code>vagrant up</code> 并且ssh到虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up</span><br><span class=\"line\">...</span><br><span class=\"line\">$ vagrant ssh</span><br><span class=\"line\">...</span><br><span class=\"line\">vagrant@precise32:~$ ls /vagrant</span><br><span class=\"line\">Vagrantfile</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant@precise32:~$ touch /vagrant/foo</span><br><span class=\"line\">vagrant@precise32:~$ exit</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo Vagrantfile</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 哇！<code>foo</code>已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。<br>&emsp;&emsp; 通过使用<a href=\"https://docs.vagrantup.com/v2/synced-folders/\" target=\"_blank\" rel=\"noopener\">同步文件夹</a>，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。<br>&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你<code>vagrant up</code>的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  </p>\n<h3 id=\"安装Apache\"><a href=\"#安装Apache\" class=\"headerlink\" title=\"安装Apache\"></a>安装Apache</h3><p>&emsp;&emsp; 对于我们的项目来说可以仅仅使用<a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache</a>，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为<code>bootstrap.sh</code>的文件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env bash</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\">apt-get install -y apache2</span><br><span class=\"line\">if ! [ -L /var/www ]; then</span><br><span class=\"line\">  rm -rf /var/www</span><br><span class=\"line\">  ln -fs /vagrant /var/www</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用<code>shell</code>配置器运行<code>bootstrap.sh</code>脚本启动机器。脚本的路径是项目更目录的相对路径。</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>&emsp;&emsp; 在所有的事情都配置好好，运行<code>vagrant up</code>来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行<code>vagrant reload --provision</code>, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。<code>--provision</code>表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。<br>&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant ssh</span><br><span class=\"line\">...</span><br><span class=\"line\">vagrant@precise32:~$ wget -qO- 127.0.0.1</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的<code>DocumentRoot</code>指向了<code>/vagrant</code>。<br>&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。</p>\n<h3 id=\"端口转发\"><a href=\"#端口转发\" class=\"headerlink\" title=\"端口转发\"></a>端口转发</h3><p>&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。<br>&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class=\"line\">  config.vm.network :forwarded_port, guest: 80, host: 4567</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行<code>vagrant reload</code>，或者如果没有启动过虚拟机运行<code>vagrant up</code>。使配置生效。</p>\n<h3 id=\"其他的网络配置\"><a href=\"#其他的网络配置\" class=\"headerlink\" title=\"其他的网络配置\"></a>其他的网络配置</h3><p>&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读<a href=\"https://docs.vagrantup.com/v2/networking/\" target=\"_blank\" rel=\"noopener\">networking</a>章节。</p>\n<h2 id=\"共享\"><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h2><p>&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做<a href=\"https://docs.vagrantup.com/v2/share/\" target=\"_blank\" rel=\"noopener\">Vagrant Share</a>。<br>&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。</p>\n<h3 id=\"登录Harshicorp’s-Altas\"><a href=\"#登录Harshicorp’s-Altas\" class=\"headerlink\" title=\"登录Harshicorp’s Altas\"></a>登录Harshicorp’s Altas</h3><p>&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个<a href=\"https://atlas.hashicorp.com/\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Altas</a>的账号。不必担心，它是免费的。<br>&emsp;&emsp; 当你有了账号后，你就可以使用<code>vagrant login</code>来登陆</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant login</span><br><span class=\"line\">Username or Email: mitchellh</span><br><span class=\"line\">Password (will be hidden):</span><br><span class=\"line\">You&apos;re now logged in!</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享-1\"><a href=\"#共享-1\" class=\"headerlink\" title=\"共享\"></a>共享</h3><p>&emsp;&emsp; 当你登录之后，你就可以使用<code>vagrant share</code>来共享环境了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant share</span><br><span class=\"line\">...</span><br><span class=\"line\">==&gt; default: Your Vagrant Share is running!</span><br><span class=\"line\">==&gt; default: URL: http://frosty-weasel-0857.vagrantshare.com</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面<code>vagrant share</code>生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。<br>&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。<br>&emsp;&emsp; 关闭共享只需要使用<code>Ctrl+C</code>即可，重新刷新URL，你会发现你的环境已经不再被共享了。<br>&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的<a href=\"https://docs.vagrantup.com/v2/share/\" target=\"_blank\" rel=\"noopener\">Vagrant Share</a>文档。</p>\n<h2 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h2><p>&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。<br>&emsp;&emsp; 通过Vagrant，我们可以<em>suspend</em>,<em>halt</em>或者<em>destory</em>虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  </p>\n<ul>\n<li><strong>suspend</strong> 使用<code>vagrant suspend</code>命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用<code>vagrant up</code>命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  </li>\n<li><strong>halting</strong> 使用<code>vagrant halt</code>命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行<code>vagrant up</code>命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。</li>\n<li><strong>destory</strong> 使用<code>vagrant destory</code>命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用<code>vagrant up</code>的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是<code>vagrant up</code>将会从头开始，这样会花费更长的时间。</li>\n</ul>\n<h2 id=\"重新构建\"><a href=\"#重新构建\" class=\"headerlink\" title=\"重新构建\"></a>重新构建</h2><p>&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过<code>vagrant up</code>来轻松运行他。<br>&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行<code>vagrant up</code>即可重新创建相同的环境。</p>\n<h3 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h3><p>&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如<a href=\"https://docs.vagrantup.com/v2/vmware/\" target=\"_blank\" rel=\"noopener\">VMware</a>,<a href=\"http://github.com/mitchellh/vagrant-aws\" target=\"_blank\" rel=\"noopener\">AWS</a>等。继续阅读来了解如何它们的更多信息以及如何使用它们。<br>&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up --provider=vmware_fusion</span><br></pre></td></tr></table></figure>\n<p>准备转移到云端了？使用AWS：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up --provider=aws</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 当你使用其他Provider运行<code>vagrant up</code>的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：<code>vagrant destory</code>，无需额外的参数。<br>&emsp;&emsp; 更多信息请参考<a href=\"https://docs.vagrantup.com/v2/providers/\" target=\"_blank\" rel=\"noopener\">provider</a>。<br>[1]: <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://docs.vagrantup.com/v2/getting-started/index.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>&emsp;&emsp;Vagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。<br>&emsp;&emsp;如果你好奇Vagrant提供了什么好的功能，你可以阅读一下<a href=\"https://docs.vagrantup.com/v2/why-vagrant/\" target=\"_blank\" rel=\"noopener\">Why Vagrant</a>。<br>&emsp;&emsp;这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的<a href=\"https://docs.vagrantup.com/v2/getting-started/providers.html\" target=\"_blank\" rel=\"noopener\">提供商</a></p>\n<blockquote>\n<p>更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O’Reilly 出版的<a href=\"http://www.amazon.com/gp/product/1449335837/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449335837&amp;linkCode=as2&amp;tag=vagrant-20\" target=\"_blank\" rel=\"noopener\">Vagrant: Up and Running</a> 更感兴趣，</p>\n</blockquote>\n<h2 id=\"启动运行\"><a href=\"#启动运行\" class=\"headerlink\" title=\"启动运行\"></a>启动运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant init hashicorp/precise32</span><br><span class=\"line\">$ vagrant up</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过<code>vagrant ssh</code> 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用<code>vagrant destory</code>来删除所有的痕迹。<br>&emsp;&emsp;现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。<br>&emsp;&emsp;通过使用Vagrant,对于任何项目来说<code>vagrant up</code> 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。<br>&emsp;&emsp;指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  </p>\n<h2 id=\"项目配置\"><a href=\"#项目配置\" class=\"headerlink\" title=\"项目配置\"></a>项目配置</h2><p>&emsp;&emsp; 任何Vagrant项目配置的第一步都是创建一个<a href=\"https://docs.vagrantup.com/v2/vagrantfile/\" target=\"_blank\" rel=\"noopener\">Vagrantfile</a>。该文件的作用有两个:  </p>\n<ol>\n<li>指定项目的根目录。很多Vagrant的配置跟这个目录有关。  </li>\n<li>描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  </li>\n</ol>\n<p>&emsp;&emsp; Vagrant 有一个内建的命令<code>vagrant init</code>用来初始化项目。出于本指南的目的，请在终端输入一下命令  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir vagrant_getting_started</span><br><span class=\"line\">$ cd vagrant_getting_started</span><br><span class=\"line\">$ vagrant init</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 以上命令将在你的当前目录下创建<code>Vagrantfile</code>。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。<br>&emsp;&emsp; 同样也可以在一个已存在的目录下运行<code>vagrant init</code>，来未一个已有项目设置Vagrant环境。<br>&emsp;&emsp; 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。</p>\n<h2 id=\"Boxes\"><a href=\"#Boxes\" class=\"headerlink\" title=\"Boxes\"></a>Boxes</h2><p>&emsp;&emsp; 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  </p>\n<h3 id=\"安装box\"><a href=\"#安装box\" class=\"headerlink\" title=\"安装box\"></a>安装box</h3><p>&emsp;&emsp; 如果你运行了<a href=\"https://docs.vagrantup.com/v2/getting-started/\" target=\"_blank\" rel=\"noopener\">开始指南</a>的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。<br>&emsp;&emsp; Boxes 由Vagrant的<code>vagrant box add</code>命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant box add hashicorp/precise32</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个将从<a href=\"https://atlas.hashicorp.com/boxes/search\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Atlas box catalog</a>下载一个名字为<code>hashicorp/precise32</code>的box。你可以从HashiCorp’s Atlas box catalog中找到各种box。很容易从HashiCorp’s Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。<br>&emsp;&emsp; 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的<code>hashicorp/precise32</code>的box，其中一个主机添加文件并不会影响另一个主机。  </p>\n<h3 id=\"使用box\"><a href=\"#使用box\" class=\"headerlink\" title=\"使用box\"></a>使用box</h3><p>&emsp;&emsp; 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 在这个例子中，”hashicorp/precise32” 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。<br>&emsp;&emsp; 在下一节中我们将启动Vagrant并且与其进行交互。  </p>\n<h3 id=\"寻找更多box\"><a href=\"#寻找更多box\" class=\"headerlink\" title=\"寻找更多box\"></a>寻找更多box</h3><p>&emsp;&emsp; 在本入门指南的后半部分，我们只会使用之前添加的”hashicorp/precise32”的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。<br>&emsp;&emsp; 寻找更多box的最好的地方是<a href=\"https://atlas.hashicorp.com/boxes/search\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Atlas box catalog</a>。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。<br>&emsp;&emsp; HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。<br>&emsp;&emsp; 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  </p>\n<h2 id=\"启动并且SSH登陆\"><a href=\"#启动并且SSH登陆\" class=\"headerlink\" title=\"启动并且SSH登陆\"></a>启动并且SSH登陆</h2><p>&emsp;&emsp; 是时候启动你第一个Vagrant环境了。运行一下命令:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant up</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant ssh</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心<code>rm -rf /</code> 这种命令，因为Vagrant的<code>/vagrant</code>目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。<br>&emsp;&emsp; 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。<br>&emsp;&emsp; 当你用完虚拟机的时候，你可以在主机上使用<code>vagrant destory</code>来清除你再虚拟机的痕迹。</p>\n<h2 id=\"同步文件夹\"><a href=\"#同步文件夹\" class=\"headerlink\" title=\"同步文件夹\"></a>同步文件夹</h2><p>&emsp;&emsp;虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用<em>同步文件夹</em>Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。<br>&emsp;&emsp; 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的<code>/vagrant</code>的。再次运行<code>vagrant up</code> 并且ssh到虚拟机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up</span><br><span class=\"line\">...</span><br><span class=\"line\">$ vagrant ssh</span><br><span class=\"line\">...</span><br><span class=\"line\">vagrant@precise32:~$ ls /vagrant</span><br><span class=\"line\">Vagrantfile</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vagrant@precise32:~$ touch /vagrant/foo</span><br><span class=\"line\">vagrant@precise32:~$ exit</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo Vagrantfile</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 哇！<code>foo</code>已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。<br>&emsp;&emsp; 通过使用<a href=\"https://docs.vagrantup.com/v2/synced-folders/\" target=\"_blank\" rel=\"noopener\">同步文件夹</a>，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>&emsp;&emsp; 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。<br>&emsp;&emsp; 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你<code>vagrant up</code>的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  </p>\n<h3 id=\"安装Apache\"><a href=\"#安装Apache\" class=\"headerlink\" title=\"安装Apache\"></a>安装Apache</h3><p>&emsp;&emsp; 对于我们的项目来说可以仅仅使用<a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache</a>，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为<code>bootstrap.sh</code>的文件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env bash</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\">apt-get install -y apache2</span><br><span class=\"line\">if ! [ -L /var/www ]; then</span><br><span class=\"line\">  rm -rf /var/www</span><br><span class=\"line\">  ln -fs /vagrant /var/www</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; “provision”这一行是新添加的，告诉Vagrant使用<code>shell</code>配置器运行<code>bootstrap.sh</code>脚本启动机器。脚本的路径是项目更目录的相对路径。</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>&emsp;&emsp; 在所有的事情都配置好好，运行<code>vagrant up</code>来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行<code>vagrant reload --provision</code>, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。<code>--provision</code>表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。<br>&emsp;&emsp; 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant ssh</span><br><span class=\"line\">...</span><br><span class=\"line\">vagrant@precise32:~$ wget -qO- 127.0.0.1</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的<code>DocumentRoot</code>指向了<code>/vagrant</code>。<br>&emsp;&emsp; 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>&emsp;&emsp; 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。</p>\n<h3 id=\"端口转发\"><a href=\"#端口转发\" class=\"headerlink\" title=\"端口转发\"></a>端口转发</h3><p>&emsp;&emsp; 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。<br>&emsp;&emsp; 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class=\"line\">  config.vm.box = &quot;hashicorp/precise32&quot;</span><br><span class=\"line\">  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;</span><br><span class=\"line\">  config.vm.network :forwarded_port, guest: 80, host: 4567</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 运行<code>vagrant reload</code>，或者如果没有启动过虚拟机运行<code>vagrant up</code>。使配置生效。</p>\n<h3 id=\"其他的网络配置\"><a href=\"#其他的网络配置\" class=\"headerlink\" title=\"其他的网络配置\"></a>其他的网络配置</h3><p>&emsp;&emsp; Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读<a href=\"https://docs.vagrantup.com/v2/networking/\" target=\"_blank\" rel=\"noopener\">networking</a>章节。</p>\n<h2 id=\"共享\"><a href=\"#共享\" class=\"headerlink\" title=\"共享\"></a>共享</h2><p>&emsp;&emsp; 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做<a href=\"https://docs.vagrantup.com/v2/share/\" target=\"_blank\" rel=\"noopener\">Vagrant Share</a>。<br>&emsp;&emsp; Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。</p>\n<h3 id=\"登录Harshicorp’s-Altas\"><a href=\"#登录Harshicorp’s-Altas\" class=\"headerlink\" title=\"登录Harshicorp’s Altas\"></a>登录Harshicorp’s Altas</h3><p>&emsp;&emsp; 在分享你的Vagrant环境之前，你需要一个<a href=\"https://atlas.hashicorp.com/\" target=\"_blank\" rel=\"noopener\">HashiCorp’s Altas</a>的账号。不必担心，它是免费的。<br>&emsp;&emsp; 当你有了账号后，你就可以使用<code>vagrant login</code>来登陆</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant login</span><br><span class=\"line\">Username or Email: mitchellh</span><br><span class=\"line\">Password (will be hidden):</span><br><span class=\"line\">You&apos;re now logged in!</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享-1\"><a href=\"#共享-1\" class=\"headerlink\" title=\"共享\"></a>共享</h3><p>&emsp;&emsp; 当你登录之后，你就可以使用<code>vagrant share</code>来共享环境了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant share</span><br><span class=\"line\">...</span><br><span class=\"line\">==&gt; default: Your Vagrant Share is running!</span><br><span class=\"line\">==&gt; default: URL: http://frosty-weasel-0857.vagrantshare.com</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 你的URL会是不同的，无需上面的URL。复制上面<code>vagrant share</code>生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。<br>&emsp;&emsp; 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。<br>&emsp;&emsp; 关闭共享只需要使用<code>Ctrl+C</code>即可，重新刷新URL，你会发现你的环境已经不再被共享了。<br>&emsp;&emsp; Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的<a href=\"https://docs.vagrantup.com/v2/share/\" target=\"_blank\" rel=\"noopener\">Vagrant Share</a>文档。</p>\n<h2 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h2><p>&emsp;&emsp; 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。<br>&emsp;&emsp; 通过Vagrant，我们可以<em>suspend</em>,<em>halt</em>或者<em>destory</em>虚拟机。每一个都有他们的优缺点，选择最适合你的那个。  </p>\n<ul>\n<li><strong>suspend</strong> 使用<code>vagrant suspend</code>命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用<code>vagrant up</code>命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。  </li>\n<li><strong>halting</strong> 使用<code>vagrant halt</code>命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行<code>vagrant up</code>命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。</li>\n<li><strong>destory</strong> 使用<code>vagrant destory</code>命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用<code>vagrant up</code>的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是<code>vagrant up</code>将会从头开始，这样会花费更长的时间。</li>\n</ul>\n<h2 id=\"重新构建\"><a href=\"#重新构建\" class=\"headerlink\" title=\"重新构建\"></a>重新构建</h2><p>&emsp;&emsp; 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过<code>vagrant up</code>来轻松运行他。<br>&emsp;&emsp; 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行<code>vagrant up</code>即可重新创建相同的环境。</p>\n<h3 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h3><p>&emsp;&emsp; 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如<a href=\"https://docs.vagrantup.com/v2/vmware/\" target=\"_blank\" rel=\"noopener\">VMware</a>,<a href=\"http://github.com/mitchellh/vagrant-aws\" target=\"_blank\" rel=\"noopener\">AWS</a>等。继续阅读来了解如何它们的更多信息以及如何使用它们。<br>&emsp;&emsp; 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up --provider=vmware_fusion</span><br></pre></td></tr></table></figure>\n<p>准备转移到云端了？使用AWS：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vagrant up --provider=aws</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 当你使用其他Provider运行<code>vagrant up</code>的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：<code>vagrant destory</code>，无需额外的参数。<br>&emsp;&emsp; 更多信息请参考<a href=\"https://docs.vagrantup.com/v2/providers/\" target=\"_blank\" rel=\"noopener\">provider</a>。<br>[1]: <a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/</a></p>\n"},{"title":"Java8 Date Time API","date":"2018-04-05T16:39:10.000Z","_content":"\n[原文地址](http://www.studytrails.com/java/java8/java8_date_and_time/)  \n#### 简介\nJava8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循[公历](http://en.wikipedia.org/wiki/Gregorian_calendar)规则。表示时间和日期的类放在`java.time`包中。在这个包里比较重要的API有：  \n    * **java.time.Period**: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n    * **java.time.Duration**: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n    * **java.time.Instant**: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n    * **java.time.LocalDate**: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n    * **java.time.LocalTime**: 保存日期时间中的时间，不包含时区。\n    * **java.time.LocalDateTime**: 保存LocalDate和LocalTime，不包含时区。\n    * **java.time.ZoneDateTime**: 保存LocalDateTIme，使用`ZoneOffset`保存时区信息。可以访问ZoneRule来转换本地时间。\n    * **java.time.ZoneOffset**: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n    * **java.time.OffsetDateTime**: 通过位移来表示本地时间。这个类不包含时区规则。    \n\n##### 创建本地日期\n\n```\nInstant now = Instant.now();\n//2014-09-20T14:32:33.646Z\n```\n这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  \n##### 打印Unix时间戳\n```\nSystem.out.Println(now.getEpochSecond());\n// prints 1411137153\n```\nUnix时间戳是从1970-01-01T00:00:00Z开始的。\n#####  Instant 加时间\n```\nInstant tomorrow = now.plus(1, ChronoUnit.DAYS);\n// prints 2014-09-20T14:32:33.646Z\n```\n这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。\n##### Instant 减时间\n```\nInstant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);\n// prints 2014-09-20T03:38:33.860Z\n```\n这个minus函数允许从Instant中减时间，时间间隔同plus。\n##### 对比两个Instant\n```\nSystem.out.println(now.compareTo(tomorrow)); // prints -1\n```\n对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。\n##### 检查Instant是否在另一个Instant之后\n```\nSystem.out.println(now.isAfter(yesterday));// prints true\n```\n##### 创建LocalDateTime\n```\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime); // prints 2014-09-28T13:01:40.556\n```\n注意，这个得到的是本地时区的时间\n##### 将LocalDateTime转换成其他时区时间\n```\nSystem.out.println(localDateTime.atZone(ZoneId.of(\"America/New_York\")));\n// prints 2014-09-28T13:07:31.207-04:00[America/New_York]\n```\n这个将会创建一个新的ZonedDateTime\n##### 从DateTime中获取星期\n```\nSystem.out.println(DayOfWeek.from(localDateTime));\n// prints SUNDAY.\n// (yes, i am working on a sunday :-( ) ))\n```\n##### 从DateTime中获取一年中第几天\n```\nSystem.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));\n// prints 271\n```\n其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）\n##### 从LocalDateTime中获取LocalDate\n```\nSystem.out.println(localDateTime.toLocalDate());\n// prints 2014-09-29\n```\n##### 从LocalDateTIme中获取LocalTime\n```\nSystem.out.println(localDateTime.toLocalTime());\n// prints 22:26:30.146\n```\n##### 通过年月日时分创建LocalDateTime\n```\nSystem.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));\n// prints 2014-10-01T10:00\n```\n##### 通过解析字符串创建LocalDateTime\n```\nLocalDateTime parsedLocalDateTime = LocalDateTime.parse(\"2014-01-01T11:00\");\n```\n##### 创建另一个时区的LocalDateTime\n```\nSystem.out.println(LocalDateTime.now(ZoneId.of(\"UTC\")));\n// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)\n```\n##### 通过Instant和时区创建LocalDateTime\n```\nInstant now = Instant.now();\nSystem.out.println(LocalDateTime.ofInstant(now, ZoneId.of(\"UTC\")));\n//2014-09-29T17:09:19.644\n```\n##### 创建ZonedDateTime\n```\nZonedDateTime zonedDateTime = ZonedDateTime.now();\n//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]\n```\n##### 获取两个不同时间在不同单位之差\n```\nSystem.out.println(zonedDateTime.until(ZonedDateTime.parse(\"2014-09-29T22:41:00-10:00\"), ChronoUnit.HOURS));\n// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string\n```\n##### 获取当前ZoneDateTime的位移\n```\nSystem.out.println(zonedDateTime.getOffset());\n// prints the offset e.g. +10:00\n```\n##### 使用DateTimeFormatter解析或者格式化时间\n```\nSystem.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(\"'The' dd 'day of' MMM 'in year' YYYY 'and zone is' z\")));\n// prints The 29 day of Sep in year 2014 and zone is IST\n```\n##### 将ZoneDateTime更改时区\n有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime\n```\n        System.out.println(zonedDateTime);\n        System.out.println(zonedDateTime.toInstant());\n        System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n        \n        // prints \n        //System.out.println(zonedDateTime);\n        //System.out.println(zonedDateTime.toInstant());\n        //System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        //System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n```\n","source":"_posts/java8-date-time-api.md","raw":"title: 'Java8 Date Time API'\ndate: 2018-04-06 00:39:10\ntags:\n  - Java\n  - Java8\n  - Translate\n---\n\n[原文地址](http://www.studytrails.com/java/java8/java8_date_and_time/)  \n#### 简介\nJava8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循[公历](http://en.wikipedia.org/wiki/Gregorian_calendar)规则。表示时间和日期的类放在`java.time`包中。在这个包里比较重要的API有：  \n    * **java.time.Period**: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n    * **java.time.Duration**: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n    * **java.time.Instant**: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n    * **java.time.LocalDate**: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n    * **java.time.LocalTime**: 保存日期时间中的时间，不包含时区。\n    * **java.time.LocalDateTime**: 保存LocalDate和LocalTime，不包含时区。\n    * **java.time.ZoneDateTime**: 保存LocalDateTIme，使用`ZoneOffset`保存时区信息。可以访问ZoneRule来转换本地时间。\n    * **java.time.ZoneOffset**: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n    * **java.time.OffsetDateTime**: 通过位移来表示本地时间。这个类不包含时区规则。    \n\n##### 创建本地日期\n\n```\nInstant now = Instant.now();\n//2014-09-20T14:32:33.646Z\n```\n这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  \n##### 打印Unix时间戳\n```\nSystem.out.Println(now.getEpochSecond());\n// prints 1411137153\n```\nUnix时间戳是从1970-01-01T00:00:00Z开始的。\n#####  Instant 加时间\n```\nInstant tomorrow = now.plus(1, ChronoUnit.DAYS);\n// prints 2014-09-20T14:32:33.646Z\n```\n这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。\n##### Instant 减时间\n```\nInstant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);\n// prints 2014-09-20T03:38:33.860Z\n```\n这个minus函数允许从Instant中减时间，时间间隔同plus。\n##### 对比两个Instant\n```\nSystem.out.println(now.compareTo(tomorrow)); // prints -1\n```\n对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。\n##### 检查Instant是否在另一个Instant之后\n```\nSystem.out.println(now.isAfter(yesterday));// prints true\n```\n##### 创建LocalDateTime\n```\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime); // prints 2014-09-28T13:01:40.556\n```\n注意，这个得到的是本地时区的时间\n##### 将LocalDateTime转换成其他时区时间\n```\nSystem.out.println(localDateTime.atZone(ZoneId.of(\"America/New_York\")));\n// prints 2014-09-28T13:07:31.207-04:00[America/New_York]\n```\n这个将会创建一个新的ZonedDateTime\n##### 从DateTime中获取星期\n```\nSystem.out.println(DayOfWeek.from(localDateTime));\n// prints SUNDAY.\n// (yes, i am working on a sunday :-( ) ))\n```\n##### 从DateTime中获取一年中第几天\n```\nSystem.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));\n// prints 271\n```\n其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）\n##### 从LocalDateTime中获取LocalDate\n```\nSystem.out.println(localDateTime.toLocalDate());\n// prints 2014-09-29\n```\n##### 从LocalDateTIme中获取LocalTime\n```\nSystem.out.println(localDateTime.toLocalTime());\n// prints 22:26:30.146\n```\n##### 通过年月日时分创建LocalDateTime\n```\nSystem.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));\n// prints 2014-10-01T10:00\n```\n##### 通过解析字符串创建LocalDateTime\n```\nLocalDateTime parsedLocalDateTime = LocalDateTime.parse(\"2014-01-01T11:00\");\n```\n##### 创建另一个时区的LocalDateTime\n```\nSystem.out.println(LocalDateTime.now(ZoneId.of(\"UTC\")));\n// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)\n```\n##### 通过Instant和时区创建LocalDateTime\n```\nInstant now = Instant.now();\nSystem.out.println(LocalDateTime.ofInstant(now, ZoneId.of(\"UTC\")));\n//2014-09-29T17:09:19.644\n```\n##### 创建ZonedDateTime\n```\nZonedDateTime zonedDateTime = ZonedDateTime.now();\n//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]\n```\n##### 获取两个不同时间在不同单位之差\n```\nSystem.out.println(zonedDateTime.until(ZonedDateTime.parse(\"2014-09-29T22:41:00-10:00\"), ChronoUnit.HOURS));\n// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string\n```\n##### 获取当前ZoneDateTime的位移\n```\nSystem.out.println(zonedDateTime.getOffset());\n// prints the offset e.g. +10:00\n```\n##### 使用DateTimeFormatter解析或者格式化时间\n```\nSystem.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(\"'The' dd 'day of' MMM 'in year' YYYY 'and zone is' z\")));\n// prints The 29 day of Sep in year 2014 and zone is IST\n```\n##### 将ZoneDateTime更改时区\n有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime\n```\n        System.out.println(zonedDateTime);\n        System.out.println(zonedDateTime.toInstant());\n        System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n        \n        // prints \n        //System.out.println(zonedDateTime);\n        //System.out.println(zonedDateTime.toInstant());\n        //System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        //System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n```\n","slug":"java8-date-time-api","published":1,"updated":"2018-04-06T14:47:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5v000amarttqg5nlt6","content":"<p><a href=\"http://www.studytrails.com/java/java8/java8_date_and_time/\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>Java8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循<a href=\"http://en.wikipedia.org/wiki/Gregorian_calendar\" target=\"_blank\" rel=\"noopener\">公历</a>规则。表示时间和日期的类放在<code>java.time</code>包中。在这个包里比较重要的API有：  </p>\n<pre><code>* **java.time.Period**: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n* **java.time.Duration**: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n* **java.time.Instant**: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n* **java.time.LocalDate**: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n* **java.time.LocalTime**: 保存日期时间中的时间，不包含时区。\n* **java.time.LocalDateTime**: 保存LocalDate和LocalTime，不包含时区。\n* **java.time.ZoneDateTime**: 保存LocalDateTIme，使用`ZoneOffset`保存时区信息。可以访问ZoneRule来转换本地时间。\n* **java.time.ZoneOffset**: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n* **java.time.OffsetDateTime**: 通过位移来表示本地时间。这个类不包含时区规则。    \n</code></pre><h5 id=\"创建本地日期\"><a href=\"#创建本地日期\" class=\"headerlink\" title=\"创建本地日期\"></a>创建本地日期</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant now = Instant.now();</span><br><span class=\"line\">//2014-09-20T14:32:33.646Z</span><br></pre></td></tr></table></figure>\n<p>这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  </p>\n<h5 id=\"打印Unix时间戳\"><a href=\"#打印Unix时间戳\" class=\"headerlink\" title=\"打印Unix时间戳\"></a>打印Unix时间戳</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.Println(now.getEpochSecond());</span><br><span class=\"line\">// prints 1411137153</span><br></pre></td></tr></table></figure>\n<p>Unix时间戳是从1970-01-01T00:00:00Z开始的。</p>\n<h5 id=\"Instant-加时间\"><a href=\"#Instant-加时间\" class=\"headerlink\" title=\"Instant 加时间\"></a>Instant 加时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant tomorrow = now.plus(1, ChronoUnit.DAYS);</span><br><span class=\"line\">// prints 2014-09-20T14:32:33.646Z</span><br></pre></td></tr></table></figure>\n<p>这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。</p>\n<h5 id=\"Instant-减时间\"><a href=\"#Instant-减时间\" class=\"headerlink\" title=\"Instant 减时间\"></a>Instant 减时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);</span><br><span class=\"line\">// prints 2014-09-20T03:38:33.860Z</span><br></pre></td></tr></table></figure>\n<p>这个minus函数允许从Instant中减时间，时间间隔同plus。</p>\n<h5 id=\"对比两个Instant\"><a href=\"#对比两个Instant\" class=\"headerlink\" title=\"对比两个Instant\"></a>对比两个Instant</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(now.compareTo(tomorrow)); // prints -1</span><br></pre></td></tr></table></figure>\n<p>对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。</p>\n<h5 id=\"检查Instant是否在另一个Instant之后\"><a href=\"#检查Instant是否在另一个Instant之后\" class=\"headerlink\" title=\"检查Instant是否在另一个Instant之后\"></a>检查Instant是否在另一个Instant之后</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(now.isAfter(yesterday));// prints true</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建LocalDateTime\"><a href=\"#创建LocalDateTime\" class=\"headerlink\" title=\"创建LocalDateTime\"></a>创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class=\"line\">System.out.println(localDateTime); // prints 2014-09-28T13:01:40.556</span><br></pre></td></tr></table></figure>\n<p>注意，这个得到的是本地时区的时间</p>\n<h5 id=\"将LocalDateTime转换成其他时区时间\"><a href=\"#将LocalDateTime转换成其他时区时间\" class=\"headerlink\" title=\"将LocalDateTime转换成其他时区时间\"></a>将LocalDateTime转换成其他时区时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.atZone(ZoneId.of(&quot;America/New_York&quot;)));</span><br><span class=\"line\">// prints 2014-09-28T13:07:31.207-04:00[America/New_York]</span><br></pre></td></tr></table></figure>\n<p>这个将会创建一个新的ZonedDateTime</p>\n<h5 id=\"从DateTime中获取星期\"><a href=\"#从DateTime中获取星期\" class=\"headerlink\" title=\"从DateTime中获取星期\"></a>从DateTime中获取星期</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(DayOfWeek.from(localDateTime));</span><br><span class=\"line\">// prints SUNDAY.</span><br><span class=\"line\">// (yes, i am working on a sunday :-( ) ))</span><br></pre></td></tr></table></figure>\n<h5 id=\"从DateTime中获取一年中第几天\"><a href=\"#从DateTime中获取一年中第几天\" class=\"headerlink\" title=\"从DateTime中获取一年中第几天\"></a>从DateTime中获取一年中第几天</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));</span><br><span class=\"line\">// prints 271</span><br></pre></td></tr></table></figure>\n<p>其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）</p>\n<h5 id=\"从LocalDateTime中获取LocalDate\"><a href=\"#从LocalDateTime中获取LocalDate\" class=\"headerlink\" title=\"从LocalDateTime中获取LocalDate\"></a>从LocalDateTime中获取LocalDate</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.toLocalDate());</span><br><span class=\"line\">// prints 2014-09-29</span><br></pre></td></tr></table></figure>\n<h5 id=\"从LocalDateTIme中获取LocalTime\"><a href=\"#从LocalDateTIme中获取LocalTime\" class=\"headerlink\" title=\"从LocalDateTIme中获取LocalTime\"></a>从LocalDateTIme中获取LocalTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.toLocalTime());</span><br><span class=\"line\">// prints 22:26:30.146</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过年月日时分创建LocalDateTime\"><a href=\"#通过年月日时分创建LocalDateTime\" class=\"headerlink\" title=\"通过年月日时分创建LocalDateTime\"></a>通过年月日时分创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));</span><br><span class=\"line\">// prints 2014-10-01T10:00</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过解析字符串创建LocalDateTime\"><a href=\"#通过解析字符串创建LocalDateTime\" class=\"headerlink\" title=\"通过解析字符串创建LocalDateTime\"></a>通过解析字符串创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime parsedLocalDateTime = LocalDateTime.parse(&quot;2014-01-01T11:00&quot;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建另一个时区的LocalDateTime\"><a href=\"#创建另一个时区的LocalDateTime\" class=\"headerlink\" title=\"创建另一个时区的LocalDateTime\"></a>创建另一个时区的LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now(ZoneId.of(&quot;UTC&quot;)));</span><br><span class=\"line\">// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过Instant和时区创建LocalDateTime\"><a href=\"#通过Instant和时区创建LocalDateTime\" class=\"headerlink\" title=\"通过Instant和时区创建LocalDateTime\"></a>通过Instant和时区创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant now = Instant.now();</span><br><span class=\"line\">System.out.println(LocalDateTime.ofInstant(now, ZoneId.of(&quot;UTC&quot;)));</span><br><span class=\"line\">//2014-09-29T17:09:19.644</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建ZonedDateTime\"><a href=\"#创建ZonedDateTime\" class=\"headerlink\" title=\"创建ZonedDateTime\"></a>创建ZonedDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class=\"line\">//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]</span><br></pre></td></tr></table></figure>\n<h5 id=\"获取两个不同时间在不同单位之差\"><a href=\"#获取两个不同时间在不同单位之差\" class=\"headerlink\" title=\"获取两个不同时间在不同单位之差\"></a>获取两个不同时间在不同单位之差</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));</span><br><span class=\"line\">// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string</span><br></pre></td></tr></table></figure>\n<h5 id=\"获取当前ZoneDateTime的位移\"><a href=\"#获取当前ZoneDateTime的位移\" class=\"headerlink\" title=\"获取当前ZoneDateTime的位移\"></a>获取当前ZoneDateTime的位移</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.getOffset());</span><br><span class=\"line\">// prints the offset e.g. +10:00</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用DateTimeFormatter解析或者格式化时间\"><a href=\"#使用DateTimeFormatter解析或者格式化时间\" class=\"headerlink\" title=\"使用DateTimeFormatter解析或者格式化时间\"></a>使用DateTimeFormatter解析或者格式化时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(&quot;&apos;The&apos; dd &apos;day of&apos; MMM &apos;in year&apos; YYYY &apos;and zone is&apos; z&quot;)));</span><br><span class=\"line\">// prints The 29 day of Sep in year 2014 and zone is IST</span><br></pre></td></tr></table></figure>\n<h5 id=\"将ZoneDateTime更改时区\"><a href=\"#将ZoneDateTime更改时区\" class=\"headerlink\" title=\"将ZoneDateTime更改时区\"></a>将ZoneDateTime更改时区</h5><p>有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime);</span><br><span class=\"line\">System.out.println(zonedDateTime.toInstant());</span><br><span class=\"line\">System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\">System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\"></span><br><span class=\"line\">// prints </span><br><span class=\"line\">//System.out.println(zonedDateTime);</span><br><span class=\"line\">//System.out.println(zonedDateTime.toInstant());</span><br><span class=\"line\">//System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\">//System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.studytrails.com/java/java8/java8_date_and_time/\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>Java8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循<a href=\"http://en.wikipedia.org/wiki/Gregorian_calendar\" target=\"_blank\" rel=\"noopener\">公历</a>规则。表示时间和日期的类放在<code>java.time</code>包中。在这个包里比较重要的API有：  </p>\n<pre><code>* **java.time.Period**: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n* **java.time.Duration**: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n* **java.time.Instant**: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n* **java.time.LocalDate**: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n* **java.time.LocalTime**: 保存日期时间中的时间，不包含时区。\n* **java.time.LocalDateTime**: 保存LocalDate和LocalTime，不包含时区。\n* **java.time.ZoneDateTime**: 保存LocalDateTIme，使用`ZoneOffset`保存时区信息。可以访问ZoneRule来转换本地时间。\n* **java.time.ZoneOffset**: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n* **java.time.OffsetDateTime**: 通过位移来表示本地时间。这个类不包含时区规则。    \n</code></pre><h5 id=\"创建本地日期\"><a href=\"#创建本地日期\" class=\"headerlink\" title=\"创建本地日期\"></a>创建本地日期</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant now = Instant.now();</span><br><span class=\"line\">//2014-09-20T14:32:33.646Z</span><br></pre></td></tr></table></figure>\n<p>这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  </p>\n<h5 id=\"打印Unix时间戳\"><a href=\"#打印Unix时间戳\" class=\"headerlink\" title=\"打印Unix时间戳\"></a>打印Unix时间戳</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.Println(now.getEpochSecond());</span><br><span class=\"line\">// prints 1411137153</span><br></pre></td></tr></table></figure>\n<p>Unix时间戳是从1970-01-01T00:00:00Z开始的。</p>\n<h5 id=\"Instant-加时间\"><a href=\"#Instant-加时间\" class=\"headerlink\" title=\"Instant 加时间\"></a>Instant 加时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant tomorrow = now.plus(1, ChronoUnit.DAYS);</span><br><span class=\"line\">// prints 2014-09-20T14:32:33.646Z</span><br></pre></td></tr></table></figure>\n<p>这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。</p>\n<h5 id=\"Instant-减时间\"><a href=\"#Instant-减时间\" class=\"headerlink\" title=\"Instant 减时间\"></a>Instant 减时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);</span><br><span class=\"line\">// prints 2014-09-20T03:38:33.860Z</span><br></pre></td></tr></table></figure>\n<p>这个minus函数允许从Instant中减时间，时间间隔同plus。</p>\n<h5 id=\"对比两个Instant\"><a href=\"#对比两个Instant\" class=\"headerlink\" title=\"对比两个Instant\"></a>对比两个Instant</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(now.compareTo(tomorrow)); // prints -1</span><br></pre></td></tr></table></figure>\n<p>对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。</p>\n<h5 id=\"检查Instant是否在另一个Instant之后\"><a href=\"#检查Instant是否在另一个Instant之后\" class=\"headerlink\" title=\"检查Instant是否在另一个Instant之后\"></a>检查Instant是否在另一个Instant之后</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(now.isAfter(yesterday));// prints true</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建LocalDateTime\"><a href=\"#创建LocalDateTime\" class=\"headerlink\" title=\"创建LocalDateTime\"></a>创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class=\"line\">System.out.println(localDateTime); // prints 2014-09-28T13:01:40.556</span><br></pre></td></tr></table></figure>\n<p>注意，这个得到的是本地时区的时间</p>\n<h5 id=\"将LocalDateTime转换成其他时区时间\"><a href=\"#将LocalDateTime转换成其他时区时间\" class=\"headerlink\" title=\"将LocalDateTime转换成其他时区时间\"></a>将LocalDateTime转换成其他时区时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.atZone(ZoneId.of(&quot;America/New_York&quot;)));</span><br><span class=\"line\">// prints 2014-09-28T13:07:31.207-04:00[America/New_York]</span><br></pre></td></tr></table></figure>\n<p>这个将会创建一个新的ZonedDateTime</p>\n<h5 id=\"从DateTime中获取星期\"><a href=\"#从DateTime中获取星期\" class=\"headerlink\" title=\"从DateTime中获取星期\"></a>从DateTime中获取星期</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(DayOfWeek.from(localDateTime));</span><br><span class=\"line\">// prints SUNDAY.</span><br><span class=\"line\">// (yes, i am working on a sunday :-( ) ))</span><br></pre></td></tr></table></figure>\n<h5 id=\"从DateTime中获取一年中第几天\"><a href=\"#从DateTime中获取一年中第几天\" class=\"headerlink\" title=\"从DateTime中获取一年中第几天\"></a>从DateTime中获取一年中第几天</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));</span><br><span class=\"line\">// prints 271</span><br></pre></td></tr></table></figure>\n<p>其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）</p>\n<h5 id=\"从LocalDateTime中获取LocalDate\"><a href=\"#从LocalDateTime中获取LocalDate\" class=\"headerlink\" title=\"从LocalDateTime中获取LocalDate\"></a>从LocalDateTime中获取LocalDate</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.toLocalDate());</span><br><span class=\"line\">// prints 2014-09-29</span><br></pre></td></tr></table></figure>\n<h5 id=\"从LocalDateTIme中获取LocalTime\"><a href=\"#从LocalDateTIme中获取LocalTime\" class=\"headerlink\" title=\"从LocalDateTIme中获取LocalTime\"></a>从LocalDateTIme中获取LocalTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(localDateTime.toLocalTime());</span><br><span class=\"line\">// prints 22:26:30.146</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过年月日时分创建LocalDateTime\"><a href=\"#通过年月日时分创建LocalDateTime\" class=\"headerlink\" title=\"通过年月日时分创建LocalDateTime\"></a>通过年月日时分创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));</span><br><span class=\"line\">// prints 2014-10-01T10:00</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过解析字符串创建LocalDateTime\"><a href=\"#通过解析字符串创建LocalDateTime\" class=\"headerlink\" title=\"通过解析字符串创建LocalDateTime\"></a>通过解析字符串创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime parsedLocalDateTime = LocalDateTime.parse(&quot;2014-01-01T11:00&quot;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建另一个时区的LocalDateTime\"><a href=\"#创建另一个时区的LocalDateTime\" class=\"headerlink\" title=\"创建另一个时区的LocalDateTime\"></a>创建另一个时区的LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now(ZoneId.of(&quot;UTC&quot;)));</span><br><span class=\"line\">// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过Instant和时区创建LocalDateTime\"><a href=\"#通过Instant和时区创建LocalDateTime\" class=\"headerlink\" title=\"通过Instant和时区创建LocalDateTime\"></a>通过Instant和时区创建LocalDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant now = Instant.now();</span><br><span class=\"line\">System.out.println(LocalDateTime.ofInstant(now, ZoneId.of(&quot;UTC&quot;)));</span><br><span class=\"line\">//2014-09-29T17:09:19.644</span><br></pre></td></tr></table></figure>\n<h5 id=\"创建ZonedDateTime\"><a href=\"#创建ZonedDateTime\" class=\"headerlink\" title=\"创建ZonedDateTime\"></a>创建ZonedDateTime</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class=\"line\">//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]</span><br></pre></td></tr></table></figure>\n<h5 id=\"获取两个不同时间在不同单位之差\"><a href=\"#获取两个不同时间在不同单位之差\" class=\"headerlink\" title=\"获取两个不同时间在不同单位之差\"></a>获取两个不同时间在不同单位之差</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));</span><br><span class=\"line\">// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string</span><br></pre></td></tr></table></figure>\n<h5 id=\"获取当前ZoneDateTime的位移\"><a href=\"#获取当前ZoneDateTime的位移\" class=\"headerlink\" title=\"获取当前ZoneDateTime的位移\"></a>获取当前ZoneDateTime的位移</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.getOffset());</span><br><span class=\"line\">// prints the offset e.g. +10:00</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用DateTimeFormatter解析或者格式化时间\"><a href=\"#使用DateTimeFormatter解析或者格式化时间\" class=\"headerlink\" title=\"使用DateTimeFormatter解析或者格式化时间\"></a>使用DateTimeFormatter解析或者格式化时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(&quot;&apos;The&apos; dd &apos;day of&apos; MMM &apos;in year&apos; YYYY &apos;and zone is&apos; z&quot;)));</span><br><span class=\"line\">// prints The 29 day of Sep in year 2014 and zone is IST</span><br></pre></td></tr></table></figure>\n<h5 id=\"将ZoneDateTime更改时区\"><a href=\"#将ZoneDateTime更改时区\" class=\"headerlink\" title=\"将ZoneDateTime更改时区\"></a>将ZoneDateTime更改时区</h5><p>有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(zonedDateTime);</span><br><span class=\"line\">System.out.println(zonedDateTime.toInstant());</span><br><span class=\"line\">System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\">System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\"></span><br><span class=\"line\">// prints </span><br><span class=\"line\">//System.out.println(zonedDateTime);</span><br><span class=\"line\">//System.out.println(zonedDateTime.toInstant());</span><br><span class=\"line\">//System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));</span><br><span class=\"line\">//System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Linux 如何查找Java 程序CPU负载过高","date":"2017-03-25T03:20:26.000Z","_content":"\n\n&emsp;&emsp;准备程序：\n```\npackage test;\n\npublic class Test{\n    public static void main(String[] args){\n        new Thread(new Runnable(){\n            public void run(){\n                while(true){\n\n                }\n            }\n        }).start();\n    }\n}\n```\n&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过`top` 获取CPU占用信息\n![top cpu](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png)\n可以看到占用最高的 pid是 25955\n通过`top -p 25955 -H` 获取进程内部线程的CPU使用率。\n![topph](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png)\n可以发现占用最高的线程ID是 `25965` 将其转换为16进制`python -c 'print hex(25965)'` 得到的值是`0x656d` \n使用 `jstack -l 25955 > jstack.log` 得到Java进程的Thread dump，通过 `grep -i 0x656d -A 30 jstack.log` 获取Java Thread id为0x656d的线程的thread dump。\n![jstack](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png)\n然后就可以定位相应代码查找代码占用CPU过高问题。","source":"_posts/cup-load-high.md","raw":"title: Linux 如何查找Java 程序CPU负载过高\ndate: 2017-3-25 11:20:26\ntags:\n    - CPU\n    - Java\n    - Linux\n---\n\n\n&emsp;&emsp;准备程序：\n```\npackage test;\n\npublic class Test{\n    public static void main(String[] args){\n        new Thread(new Runnable(){\n            public void run(){\n                while(true){\n\n                }\n            }\n        }).start();\n    }\n}\n```\n&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过`top` 获取CPU占用信息\n![top cpu](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png)\n可以看到占用最高的 pid是 25955\n通过`top -p 25955 -H` 获取进程内部线程的CPU使用率。\n![topph](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png)\n可以发现占用最高的线程ID是 `25965` 将其转换为16进制`python -c 'print hex(25965)'` 得到的值是`0x656d` \n使用 `jstack -l 25955 > jstack.log` 得到Java进程的Thread dump，通过 `grep -i 0x656d -A 30 jstack.log` 获取Java Thread id为0x656d的线程的thread dump。\n![jstack](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png)\n然后就可以定位相应代码查找代码占用CPU过高问题。","slug":"cup-load-high","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds5y000cmartzfk9jkpb","content":"<p>&emsp;&emsp;准备程序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package test;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        new Thread(new Runnable()&#123;</span><br><span class=\"line\">            public void run()&#123;</span><br><span class=\"line\">                while(true)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过<code>top</code> 获取CPU占用信息<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png\" alt=\"top cpu\"><br>可以看到占用最高的 pid是 25955<br>通过<code>top -p 25955 -H</code> 获取进程内部线程的CPU使用率。<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png\" alt=\"topph\"><br>可以发现占用最高的线程ID是 <code>25965</code> 将其转换为16进制<code>python -c &#39;print hex(25965)&#39;</code> 得到的值是<code>0x656d</code><br>使用 <code>jstack -l 25955 &gt; jstack.log</code> 得到Java进程的Thread dump，通过 <code>grep -i 0x656d -A 30 jstack.log</code> 获取Java Thread id为0x656d的线程的thread dump。<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png\" alt=\"jstack\"><br>然后就可以定位相应代码查找代码占用CPU过高问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;&emsp;准备程序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package test;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\">        new Thread(new Runnable()&#123;</span><br><span class=\"line\">            public void run()&#123;</span><br><span class=\"line\">                while(true)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过<code>top</code> 获取CPU占用信息<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png\" alt=\"top cpu\"><br>可以看到占用最高的 pid是 25955<br>通过<code>top -p 25955 -H</code> 获取进程内部线程的CPU使用率。<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png\" alt=\"topph\"><br>可以发现占用最高的线程ID是 <code>25965</code> 将其转换为16进制<code>python -c &#39;print hex(25965)&#39;</code> 得到的值是<code>0x656d</code><br>使用 <code>jstack -l 25955 &gt; jstack.log</code> 得到Java进程的Thread dump，通过 <code>grep -i 0x656d -A 30 jstack.log</code> 获取Java Thread id为0x656d的线程的thread dump。<br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png\" alt=\"jstack\"><br>然后就可以定位相应代码查找代码占用CPU过高问题。</p>\n"},{"title":"http.Handler 与Go的错误处理","date":"2015-11-12T13:24:57.000Z","_content":"\n[原文地址](http://elithrar.github.io/article/http-handler-error-handling-revisited/)\n\n&emsp;&emsp; 在之前我写过一篇关于通过使用`http.HandlerFunc`来实现一个定制handler类型用来避免一些平常的错误的[文章](http://elithrar.github.io/article/custom-handlers-avoiding-globals/)。`func MyHandler(w http.ResponseWriter, r *http.Request)`的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n* 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n* 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用`log.Printf`，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n&emsp;&emsp; 我以前的方法中使用了`func(http.ResponseWriter, *http.Request)`签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n```\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\n    if user.LoggedIn {\n        http.Redirect(w, r, \"/dashboard\", 302)\n        // Superfluous! Our http.Redirect function handles the 302, not \n        // our return value (which is effectively ignored).\n        return 302, nil\n    }\n\n}\n```\n\n&emsp;&emsp;看起来还行，但是我们可以做的更好\n\n### 一些区别\n\n&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：\n\n```\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n```\n\n&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n* 我们自定义了一个`Error`类型（接口），他内嵌了Go的内建的error接口，同时提供了一个`Status() int`方法。\n* 我们提供了一个简单的`StatusError`类型（结构体），它满足`handler.Error`的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。\n* 我们的`ServeHTTP`方法包好了一个\"e := err.(type)\"的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个`handler.Error`类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。\n\n&emsp;&emsp; 如果我们不想捕捉那些错误，那么`default`将会默认捕捉到。记住一点，`ServeHTTP`可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n### 所有示例\n\n&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n```\npackage handler\n\nimport (\n    \"net/http\"\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It's also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\n    fmt.Fprintf(w, \"%+v\", users)\n    return nil\n}\n```\n\n&emsp;&emsp; main包：\n\n```\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/you/somepkg/handler\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"connectionstringhere\")\n    if err != nil {\n          log.Fatal(err)\n    }\n\n    // Initialise our app-wide environment with the services/info we need.\n    env := &handler.Env{\n        DB: db,\n        Port: os.Getenv(\"PORT\"),\n        Host: os.Getenv(\"HOST\"),\n        // We might also have a custom log.Logger, our \n        // template instance, and a config struct as fields \n        // in our Env struct.\n    }\n\n    // Note that we're using http.Handle, not http.HandleFunc. The \n    // latter only accepts the http.HandlerFunc type, which is not \n    // what we have here.\n    http.Handle(\"/\", handler.Handler{env, handler.GetIndex})\n\n    // Logs the error if ListenAndServe fails.\n    log.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n```\n\n&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。\n\n","source":"_posts/http-Handler-与Go的错误处理.md","raw":"title: http.Handler 与Go的错误处理\ndate: 2015-11-12 21:24:57\ntags:\n  - Go\n  - Translate\n---\n\n[原文地址](http://elithrar.github.io/article/http-handler-error-handling-revisited/)\n\n&emsp;&emsp; 在之前我写过一篇关于通过使用`http.HandlerFunc`来实现一个定制handler类型用来避免一些平常的错误的[文章](http://elithrar.github.io/article/custom-handlers-avoiding-globals/)。`func MyHandler(w http.ResponseWriter, r *http.Request)`的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n* 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n* 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用`log.Printf`，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n&emsp;&emsp; 我以前的方法中使用了`func(http.ResponseWriter, *http.Request)`签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n```\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\n    if user.LoggedIn {\n        http.Redirect(w, r, \"/dashboard\", 302)\n        // Superfluous! Our http.Redirect function handles the 302, not \n        // our return value (which is effectively ignored).\n        return 302, nil\n    }\n\n}\n```\n\n&emsp;&emsp;看起来还行，但是我们可以做的更好\n\n### 一些区别\n\n&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：\n\n```\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n```\n\n&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n* 我们自定义了一个`Error`类型（接口），他内嵌了Go的内建的error接口，同时提供了一个`Status() int`方法。\n* 我们提供了一个简单的`StatusError`类型（结构体），它满足`handler.Error`的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。\n* 我们的`ServeHTTP`方法包好了一个\"e := err.(type)\"的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个`handler.Error`类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。\n\n&emsp;&emsp; 如果我们不想捕捉那些错误，那么`default`将会默认捕捉到。记住一点，`ServeHTTP`可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n### 所有示例\n\n&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n```\npackage handler\n\nimport (\n    \"net/http\"\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It's also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\n    fmt.Fprintf(w, \"%+v\", users)\n    return nil\n}\n```\n\n&emsp;&emsp; main包：\n\n```\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/you/somepkg/handler\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"connectionstringhere\")\n    if err != nil {\n          log.Fatal(err)\n    }\n\n    // Initialise our app-wide environment with the services/info we need.\n    env := &handler.Env{\n        DB: db,\n        Port: os.Getenv(\"PORT\"),\n        Host: os.Getenv(\"HOST\"),\n        // We might also have a custom log.Logger, our \n        // template instance, and a config struct as fields \n        // in our Env struct.\n    }\n\n    // Note that we're using http.Handle, not http.HandleFunc. The \n    // latter only accepts the http.HandlerFunc type, which is not \n    // what we have here.\n    http.Handle(\"/\", handler.Handler{env, handler.GetIndex})\n\n    // Logs the error if ListenAndServe fails.\n    log.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n```\n\n&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。\n\n","slug":"http-Handler-与Go的错误处理","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds62000emartsc1yfgl1","content":"<p><a href=\"http://elithrar.github.io/article/http-handler-error-handling-revisited/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 在之前我写过一篇关于通过使用<code>http.HandlerFunc</code>来实现一个定制handler类型用来避免一些平常的错误的<a href=\"http://elithrar.github.io/article/custom-handlers-avoiding-globals/\" target=\"_blank\" rel=\"noopener\">文章</a>。<code>func MyHandler(w http.ResponseWriter, r *http.Request)</code>的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：</p>\n<ul>\n<li>当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。</li>\n<li>不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。</li>\n<li>一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用<code>log.Printf</code>，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。</li>\n</ul>\n<p>&emsp;&emsp; 我以前的方法中使用了<code>func(http.ResponseWriter, *http.Request)</code>签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) &#123;</span><br><span class=\"line\">    db, err := someDBcall()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        // This makes sense.</span><br><span class=\"line\">        return 500, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if user.LoggedIn &#123;</span><br><span class=\"line\">        http.Redirect(w, r, &quot;/dashboard&quot;, 302)</span><br><span class=\"line\">        // Superfluous! Our http.Redirect function handles the 302, not </span><br><span class=\"line\">        // our return value (which is effectively ignored).</span><br><span class=\"line\">        return 302, nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;看起来还行，但是我们可以做的更好</p>\n<h3 id=\"一些区别\"><a href=\"#一些区别\" class=\"headerlink\" title=\"一些区别\"></a>一些区别</h3><p>&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package handler</span><br><span class=\"line\"></span><br><span class=\"line\">// Error represents a handler error. It provides methods for a HTTP status </span><br><span class=\"line\">// code and embeds the built-in error interface.</span><br><span class=\"line\">type Error interface &#123;</span><br><span class=\"line\">    error</span><br><span class=\"line\">    Status() int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// StatusError represents an error with an associated HTTP status code.</span><br><span class=\"line\">type StatusError struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">    Err  error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Allows StatusError to satisfy the error interface.</span><br><span class=\"line\">func (se StatusError) Error() string &#123;</span><br><span class=\"line\">    return se.Err.Error()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns our HTTP status code.</span><br><span class=\"line\">func (se StatusError) Status() int &#123;</span><br><span class=\"line\">    return se.Code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A (simple) example of our application-wide configuration.</span><br><span class=\"line\">type Env struct &#123;</span><br><span class=\"line\">    DB   *sql.DB</span><br><span class=\"line\">    Port string</span><br><span class=\"line\">    Host string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The Handler struct that takes a configured Env and a function matching</span><br><span class=\"line\">// our useful signature.</span><br><span class=\"line\">type Handler struct &#123;</span><br><span class=\"line\">    *Env</span><br><span class=\"line\">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ServeHTTP allows our Handler type to satisfy http.Handler.</span><br><span class=\"line\">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    err := h.H(h.Env, w, r)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        switch e := err.(type) &#123;</span><br><span class=\"line\">        case Error:</span><br><span class=\"line\">            // We can retrieve the status here and write out a specific</span><br><span class=\"line\">            // HTTP status code.</span><br><span class=\"line\">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</span><br><span class=\"line\">            http.Error(w, e.Error(), e.Status())</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            // Any error types we don&apos;t specifically look out for default</span><br><span class=\"line\">            // to serving a HTTP 500</span><br><span class=\"line\">            http.Error(w, http.StatusText(http.StatusInternalServerError),</span><br><span class=\"line\">                http.StatusInternalServerError)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：</p>\n<ul>\n<li>我们自定义了一个<code>Error</code>类型（接口），他内嵌了Go的内建的error接口，同时提供了一个<code>Status() int</code>方法。</li>\n<li>我们提供了一个简单的<code>StatusError</code>类型（结构体），它满足<code>handler.Error</code>的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。</li>\n<li>我们的<code>ServeHTTP</code>方法包好了一个”e := err.(type)”的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个<code>handler.Error</code>类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。</li>\n</ul>\n<p>&emsp;&emsp; 如果我们不想捕捉那些错误，那么<code>default</code>将会默认捕捉到。记住一点，<code>ServeHTTP</code>可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。<br>&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。</p>\n<h3 id=\"所有示例\"><a href=\"#所有示例\" class=\"headerlink\" title=\"所有示例\"></a>所有示例</h3><p>&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package handler</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// Error represents a handler error. It provides methods for a HTTP status </span><br><span class=\"line\">// code and embeds the built-in error interface.</span><br><span class=\"line\">type Error interface &#123;</span><br><span class=\"line\">    error</span><br><span class=\"line\">    Status() int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// StatusError represents an error with an associated HTTP status code.</span><br><span class=\"line\">type StatusError struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">    Err  error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Allows StatusError to satisfy the error interface.</span><br><span class=\"line\">func (se StatusError) Error() string &#123;</span><br><span class=\"line\">    return se.Err.Error()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns our HTTP status code.</span><br><span class=\"line\">func (se StatusError) Status() int &#123;</span><br><span class=\"line\">    return se.Code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A (simple) example of our application-wide configuration.</span><br><span class=\"line\">type Env struct &#123;</span><br><span class=\"line\">    DB   *sql.DB</span><br><span class=\"line\">    Port string</span><br><span class=\"line\">    Host string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The Handler struct that takes a configured Env and a function matching</span><br><span class=\"line\">// our useful signature.</span><br><span class=\"line\">type Handler struct &#123;</span><br><span class=\"line\">    *Env</span><br><span class=\"line\">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ServeHTTP allows our Handler type to satisfy http.Handler.</span><br><span class=\"line\">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    err := h.H(h.Env, w, r)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        switch e := err.(type) &#123;</span><br><span class=\"line\">        case Error:</span><br><span class=\"line\">            // We can retrieve the status here and write out a specific</span><br><span class=\"line\">            // HTTP status code.</span><br><span class=\"line\">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</span><br><span class=\"line\">            http.Error(w, e.Error(), e.Status())</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            // Any error types we don&apos;t specifically look out for default</span><br><span class=\"line\">            // to serving a HTTP 500</span><br><span class=\"line\">            http.Error(w, http.StatusText(http.StatusInternalServerError),</span><br><span class=\"line\">                http.StatusInternalServerError)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error &#123;</span><br><span class=\"line\">    users, err := env.DB.GetAllUsers()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        // We return a status error here, which conveniently wraps the error</span><br><span class=\"line\">        // returned from our DB queries. We can clearly define which errors </span><br><span class=\"line\">        // are worth raising a HTTP 500 over vs. which might just be a HTTP </span><br><span class=\"line\">        // 404, 403 or 401 (as appropriate). It&apos;s also clear where our </span><br><span class=\"line\">        // handler should stop processing by returning early.</span><br><span class=\"line\">        return StatusError&#123;500, err&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Fprintf(w, &quot;%+v&quot;, users)</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; main包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;github.com/you/somepkg/handler&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    db, err := sql.Open(&quot;connectionstringhere&quot;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">          log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Initialise our app-wide environment with the services/info we need.</span><br><span class=\"line\">    env := &amp;handler.Env&#123;</span><br><span class=\"line\">        DB: db,</span><br><span class=\"line\">        Port: os.Getenv(&quot;PORT&quot;),</span><br><span class=\"line\">        Host: os.Getenv(&quot;HOST&quot;),</span><br><span class=\"line\">        // We might also have a custom log.Logger, our </span><br><span class=\"line\">        // template instance, and a config struct as fields </span><br><span class=\"line\">        // in our Env struct.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Note that we&apos;re using http.Handle, not http.HandleFunc. The </span><br><span class=\"line\">    // latter only accepts the http.HandlerFunc type, which is not </span><br><span class=\"line\">    // what we have here.</span><br><span class=\"line\">    http.Handle(&quot;/&quot;, handler.Handler&#123;env, handler.GetIndex&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // Logs the error if ListenAndServe fails.</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://elithrar.github.io/article/http-handler-error-handling-revisited/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 在之前我写过一篇关于通过使用<code>http.HandlerFunc</code>来实现一个定制handler类型用来避免一些平常的错误的<a href=\"http://elithrar.github.io/article/custom-handlers-avoiding-globals/\" target=\"_blank\" rel=\"noopener\">文章</a>。<code>func MyHandler(w http.ResponseWriter, r *http.Request)</code>的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：</p>\n<ul>\n<li>当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。</li>\n<li>不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。</li>\n<li>一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用<code>log.Printf</code>，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。</li>\n</ul>\n<p>&emsp;&emsp; 我以前的方法中使用了<code>func(http.ResponseWriter, *http.Request)</code>签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) &#123;</span><br><span class=\"line\">    db, err := someDBcall()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        // This makes sense.</span><br><span class=\"line\">        return 500, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if user.LoggedIn &#123;</span><br><span class=\"line\">        http.Redirect(w, r, &quot;/dashboard&quot;, 302)</span><br><span class=\"line\">        // Superfluous! Our http.Redirect function handles the 302, not </span><br><span class=\"line\">        // our return value (which is effectively ignored).</span><br><span class=\"line\">        return 302, nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;看起来还行，但是我们可以做的更好</p>\n<h3 id=\"一些区别\"><a href=\"#一些区别\" class=\"headerlink\" title=\"一些区别\"></a>一些区别</h3><p>&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package handler</span><br><span class=\"line\"></span><br><span class=\"line\">// Error represents a handler error. It provides methods for a HTTP status </span><br><span class=\"line\">// code and embeds the built-in error interface.</span><br><span class=\"line\">type Error interface &#123;</span><br><span class=\"line\">    error</span><br><span class=\"line\">    Status() int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// StatusError represents an error with an associated HTTP status code.</span><br><span class=\"line\">type StatusError struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">    Err  error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Allows StatusError to satisfy the error interface.</span><br><span class=\"line\">func (se StatusError) Error() string &#123;</span><br><span class=\"line\">    return se.Err.Error()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns our HTTP status code.</span><br><span class=\"line\">func (se StatusError) Status() int &#123;</span><br><span class=\"line\">    return se.Code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A (simple) example of our application-wide configuration.</span><br><span class=\"line\">type Env struct &#123;</span><br><span class=\"line\">    DB   *sql.DB</span><br><span class=\"line\">    Port string</span><br><span class=\"line\">    Host string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The Handler struct that takes a configured Env and a function matching</span><br><span class=\"line\">// our useful signature.</span><br><span class=\"line\">type Handler struct &#123;</span><br><span class=\"line\">    *Env</span><br><span class=\"line\">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ServeHTTP allows our Handler type to satisfy http.Handler.</span><br><span class=\"line\">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    err := h.H(h.Env, w, r)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        switch e := err.(type) &#123;</span><br><span class=\"line\">        case Error:</span><br><span class=\"line\">            // We can retrieve the status here and write out a specific</span><br><span class=\"line\">            // HTTP status code.</span><br><span class=\"line\">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</span><br><span class=\"line\">            http.Error(w, e.Error(), e.Status())</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            // Any error types we don&apos;t specifically look out for default</span><br><span class=\"line\">            // to serving a HTTP 500</span><br><span class=\"line\">            http.Error(w, http.StatusText(http.StatusInternalServerError),</span><br><span class=\"line\">                http.StatusInternalServerError)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：</p>\n<ul>\n<li>我们自定义了一个<code>Error</code>类型（接口），他内嵌了Go的内建的error接口，同时提供了一个<code>Status() int</code>方法。</li>\n<li>我们提供了一个简单的<code>StatusError</code>类型（结构体），它满足<code>handler.Error</code>的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。</li>\n<li>我们的<code>ServeHTTP</code>方法包好了一个”e := err.(type)”的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个<code>handler.Error</code>类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。</li>\n</ul>\n<p>&emsp;&emsp; 如果我们不想捕捉那些错误，那么<code>default</code>将会默认捕捉到。记住一点，<code>ServeHTTP</code>可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。<br>&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。</p>\n<h3 id=\"所有示例\"><a href=\"#所有示例\" class=\"headerlink\" title=\"所有示例\"></a>所有示例</h3><p>&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package handler</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// Error represents a handler error. It provides methods for a HTTP status </span><br><span class=\"line\">// code and embeds the built-in error interface.</span><br><span class=\"line\">type Error interface &#123;</span><br><span class=\"line\">    error</span><br><span class=\"line\">    Status() int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// StatusError represents an error with an associated HTTP status code.</span><br><span class=\"line\">type StatusError struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">    Err  error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Allows StatusError to satisfy the error interface.</span><br><span class=\"line\">func (se StatusError) Error() string &#123;</span><br><span class=\"line\">    return se.Err.Error()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Returns our HTTP status code.</span><br><span class=\"line\">func (se StatusError) Status() int &#123;</span><br><span class=\"line\">    return se.Code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A (simple) example of our application-wide configuration.</span><br><span class=\"line\">type Env struct &#123;</span><br><span class=\"line\">    DB   *sql.DB</span><br><span class=\"line\">    Port string</span><br><span class=\"line\">    Host string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The Handler struct that takes a configured Env and a function matching</span><br><span class=\"line\">// our useful signature.</span><br><span class=\"line\">type Handler struct &#123;</span><br><span class=\"line\">    *Env</span><br><span class=\"line\">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ServeHTTP allows our Handler type to satisfy http.Handler.</span><br><span class=\"line\">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    err := h.H(h.Env, w, r)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        switch e := err.(type) &#123;</span><br><span class=\"line\">        case Error:</span><br><span class=\"line\">            // We can retrieve the status here and write out a specific</span><br><span class=\"line\">            // HTTP status code.</span><br><span class=\"line\">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</span><br><span class=\"line\">            http.Error(w, e.Error(), e.Status())</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            // Any error types we don&apos;t specifically look out for default</span><br><span class=\"line\">            // to serving a HTTP 500</span><br><span class=\"line\">            http.Error(w, http.StatusText(http.StatusInternalServerError),</span><br><span class=\"line\">                http.StatusInternalServerError)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error &#123;</span><br><span class=\"line\">    users, err := env.DB.GetAllUsers()</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        // We return a status error here, which conveniently wraps the error</span><br><span class=\"line\">        // returned from our DB queries. We can clearly define which errors </span><br><span class=\"line\">        // are worth raising a HTTP 500 over vs. which might just be a HTTP </span><br><span class=\"line\">        // 404, 403 or 401 (as appropriate). It&apos;s also clear where our </span><br><span class=\"line\">        // handler should stop processing by returning early.</span><br><span class=\"line\">        return StatusError&#123;500, err&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Fprintf(w, &quot;%+v&quot;, users)</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; main包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;github.com/you/somepkg/handler&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    db, err := sql.Open(&quot;connectionstringhere&quot;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">          log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Initialise our app-wide environment with the services/info we need.</span><br><span class=\"line\">    env := &amp;handler.Env&#123;</span><br><span class=\"line\">        DB: db,</span><br><span class=\"line\">        Port: os.Getenv(&quot;PORT&quot;),</span><br><span class=\"line\">        Host: os.Getenv(&quot;HOST&quot;),</span><br><span class=\"line\">        // We might also have a custom log.Logger, our </span><br><span class=\"line\">        // template instance, and a config struct as fields </span><br><span class=\"line\">        // in our Env struct.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Note that we&apos;re using http.Handle, not http.HandleFunc. The </span><br><span class=\"line\">    // latter only accepts the http.HandlerFunc type, which is not </span><br><span class=\"line\">    // what we have here.</span><br><span class=\"line\">    http.Handle(&quot;/&quot;, handler.Handler&#123;env, handler.GetIndex&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // Logs the error if ListenAndServe fails.</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。</p>\n"},{"title":"MyBatis 配置","date":"2017-06-28T06:13:32.000Z","_content":"\n[原文链接](http://www.mybatis.org/mybatis-3/configuration.html)\n\nMyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：\n* configuration\n    * properties\n    * settings\n    * typeAliases\n    * typeHandlers\n    * objectFactory\n    * plugins\n    * environments\n        * environment\n            * transactionManager\n            * dataSource\n    * databaseIdProvider\n    * mappers\n\n### properties\n可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <property name=\"username\" value=\"dev_user\"/>\n  <property name=\"password\" value=\"F2Fa3!33TYyg\"/>\n</properties>\n```\n然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：\n```\n<dataSource type=\"POOLED\">\n  <property name=\"driver\" value=\"${driver}\"/>\n  <property name=\"url\" value=\"${url}\"/>\n  <property name=\"username\" value=\"${username}\"/>\n  <property name=\"password\" value=\"${password}\"/>\n</dataSource>\n```\n在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。    \nProperties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：\n```\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);\n\n// ... or ...\n\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);\n```\n如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    \n1. 在Properties内的子元素首先被加载。     \n2. 其次从resource classpath和url中加载属性并覆盖已存在的属性。    \n3. 作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。\n\n因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。    \nMyBatis 3.4.2 之后可以如下使用默认占位符。\n```\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${username:ut_user}\"/> <!-- If 'username' property not present, username become 'ut_user' -->\n</dataSource>\n```\n这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.enable-default-value\" value=\"true\"/> <!-- Enable this feature -->\n</properties>\n```\n注意：如果已经使用了“：”作为属性的键例如：`db:username`，或者是在sql的定义中使用了OGNL的三元符，例如：`${tableName != null ? tableName : 'global_constants'}`那么就需要修改默认的分隔符，如下：\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.default-value-separator\" value=\"?:\"/> <!-- Change default value of separator -->\n</properties>\n```\n```\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${db:username?:ut_user}\"/>\n</dataSource>\n```","source":"_posts/mybaits-configuration.md","raw":"title: MyBatis 配置\ndate: 2017-06-28 14:13:32\ntags:\n    - Java\n    - Mybatis\n    - Translate\n---\n\n[原文链接](http://www.mybatis.org/mybatis-3/configuration.html)\n\nMyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：\n* configuration\n    * properties\n    * settings\n    * typeAliases\n    * typeHandlers\n    * objectFactory\n    * plugins\n    * environments\n        * environment\n            * transactionManager\n            * dataSource\n    * databaseIdProvider\n    * mappers\n\n### properties\n可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <property name=\"username\" value=\"dev_user\"/>\n  <property name=\"password\" value=\"F2Fa3!33TYyg\"/>\n</properties>\n```\n然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：\n```\n<dataSource type=\"POOLED\">\n  <property name=\"driver\" value=\"${driver}\"/>\n  <property name=\"url\" value=\"${url}\"/>\n  <property name=\"username\" value=\"${username}\"/>\n  <property name=\"password\" value=\"${password}\"/>\n</dataSource>\n```\n在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。    \nProperties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：\n```\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);\n\n// ... or ...\n\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);\n```\n如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    \n1. 在Properties内的子元素首先被加载。     \n2. 其次从resource classpath和url中加载属性并覆盖已存在的属性。    \n3. 作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。\n\n因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。    \nMyBatis 3.4.2 之后可以如下使用默认占位符。\n```\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${username:ut_user}\"/> <!-- If 'username' property not present, username become 'ut_user' -->\n</dataSource>\n```\n这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.enable-default-value\" value=\"true\"/> <!-- Enable this feature -->\n</properties>\n```\n注意：如果已经使用了“：”作为属性的键例如：`db:username`，或者是在sql的定义中使用了OGNL的三元符，例如：`${tableName != null ? tableName : 'global_constants'}`那么就需要修改默认的分隔符，如下：\n```\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.default-value-separator\" value=\"?:\"/> <!-- Change default value of separator -->\n</properties>\n```\n```\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${db:username?:ut_user}\"/>\n</dataSource>\n```","slug":"mybaits-configuration","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds64000hmart49n8v13h","content":"<p><a href=\"http://www.mybatis.org/mybatis-3/configuration.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>MyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：</p>\n<ul>\n<li>configuration<ul>\n<li>properties</li>\n<li>settings</li>\n<li>typeAliases</li>\n<li>typeHandlers</li>\n<li>objectFactory</li>\n<li>plugins</li>\n<li>environments<ul>\n<li>environment<ul>\n<li>transactionManager</li>\n<li>dataSource</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>databaseIdProvider</li>\n<li>mappers</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h3><p>可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。<br>Properties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</span><br><span class=\"line\"></span><br><span class=\"line\">// ... or ...</span><br><span class=\"line\"></span><br><span class=\"line\">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure></p>\n<p>如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    </p>\n<ol>\n<li>在Properties内的子元素首先被加载。     </li>\n<li>其次从resource classpath和url中加载属性并覆盖已存在的属性。    </li>\n<li>作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。</li>\n</ol>\n<p>因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。<br>MyBatis 3.4.2 之后可以如下使用默认占位符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- If &apos;username&apos; property not present, username become &apos;ut_user&apos; --&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果已经使用了“：”作为属性的键例如：<code>db:username</code>，或者是在sql的定义中使用了OGNL的三元符，例如：<code>${tableName != null ? tableName : &#39;global_constants&#39;}</code>那么就需要修改默认的分隔符，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.mybatis.org/mybatis-3/configuration.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>MyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：</p>\n<ul>\n<li>configuration<ul>\n<li>properties</li>\n<li>settings</li>\n<li>typeAliases</li>\n<li>typeHandlers</li>\n<li>objectFactory</li>\n<li>plugins</li>\n<li>environments<ul>\n<li>environment<ul>\n<li>transactionManager</li>\n<li>dataSource</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>databaseIdProvider</li>\n<li>mappers</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h3><p>可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。<br>Properties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</span><br><span class=\"line\"></span><br><span class=\"line\">// ... or ...</span><br><span class=\"line\"></span><br><span class=\"line\">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure></p>\n<p>如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    </p>\n<ol>\n<li>在Properties内的子元素首先被加载。     </li>\n<li>其次从resource classpath和url中加载属性并覆盖已存在的属性。    </li>\n<li>作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。</li>\n</ol>\n<p>因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。<br>MyBatis 3.4.2 之后可以如下使用默认占位符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- If &apos;username&apos; property not present, username become &apos;ut_user&apos; --&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果已经使用了“：”作为属性的键例如：<code>db:username</code>，或者是在sql的定义中使用了OGNL的三元符，例如：<code>${tableName != null ? tableName : &#39;global_constants&#39;}</code>那么就需要修改默认的分隔符，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;</span><br><span class=\"line\">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">  &lt;!-- ... --&gt;</span><br><span class=\"line\">  &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;</span><br><span class=\"line\">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure>"},{"title":"使用Go开发HTTP中间件","date":"2015-11-12T04:07:49.000Z","_content":"[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n&emsp;&emsp; 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n&emsp;&emsp; 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n&emsp;&emsp; 首先我们定义一个结构体，叫做`SingleHost`\n\n```\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n&emsp;&emsp; 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n&emsp;&emsp; 实现如下：\n\n```\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n```\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n&emsp;&emsp; 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n&emsp;&emsp; 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n&emsp;&emsp; 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n&emsp;&emsp; 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n&emsp;&emsp;最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n&emsp;&emsp; 数据由Token设置：\n\n```\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n&emsp;&emsp;源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","source":"_posts/使用Go开发HTTP中间件.md","raw":"title: 使用Go开发HTTP中间件\ndate: 2015-11-12 12:07:49\ntags:\n  - HTTP\n  - Go\n  - Middleware\n---\n[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n&emsp;&emsp; 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n&emsp;&emsp; 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n&emsp;&emsp; 首先我们定义一个结构体，叫做`SingleHost`\n\n```\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n&emsp;&emsp; 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n&emsp;&emsp; 实现如下：\n\n```\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n```\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n&emsp;&emsp; 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n&emsp;&emsp; 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n&emsp;&emsp; 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n&emsp;&emsp; 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n&emsp;&emsp;最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n&emsp;&emsp; 数据由Token设置：\n\n```\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n&emsp;&emsp;源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","slug":"使用Go开发HTTP中间件","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds68000imartn2mlxbr4","content":"<p><a href=\"https://justinas.org/writing-http-middleware-in-go/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。<br>&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。<br>&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库<code>net/http</code>中的函数<code>StripText</code>或者<code>TimeoutHandler</code>就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。<br>&emsp;&emsp; 我最近写的Go包<a href=\"https://github.com/justinas/nosurf\" target=\"_blank\" rel=\"noopener\">nosurf</a>同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和<code>net/http</code>的接口无缝衔接。<br>&emsp;&emsp; 同样你还可以使用中间件做：</p>\n<ul>\n<li>隐藏长度防止缓冲攻击</li>\n<li>速度限制</li>\n<li>屏蔽爬虫</li>\n<li>提供调试信息</li>\n<li>添加HSTS，X-Frame-Options头</li>\n<li>从错误中恢复</li>\n<li>等等</li>\n</ul>\n<h3 id=\"编写一个简单的中间件\"><a href=\"#编写一个简单的中间件\" class=\"headerlink\" title=\"编写一个简单的中间件\"></a>编写一个简单的中间件</h3><p>&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的<code>HOST</code>header实现。这样的中间件可以防止<a href=\"http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html\" target=\"_blank\" rel=\"noopener\">主机欺骗攻击</a>。</p>\n<h3 id=\"类型的机构\"><a href=\"#类型的机构\" class=\"headerlink\" title=\"类型的机构\"></a>类型的机构</h3><p>&emsp;&emsp; 首先我们定义一个结构体，叫做<code>SingleHost</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type SingleHost struct &#123;</span><br><span class=\"line\">    handler     http.Handler</span><br><span class=\"line\">    allowedHost string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 它只包含两个field。</p>\n<ul>\n<li>如果是一个可用的Host，那么我们会调用嵌入的handler。</li>\n<li>allowedHost 就是允许的Host。<br>&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost &#123;</span><br><span class=\"line\">    return &amp;SingleHost&#123;handler: handler, allowedHost: allowedHost&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><p>&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现<code>http.Handler</code>，我们只需要实现他的一个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Handler interface &#123;</span><br><span class=\"line\">        ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    host := r.Host</span><br><span class=\"line\">    if host == s.allowedHost &#123;</span><br><span class=\"line\">        s.handler.ServeHTTP(w, r)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        w.WriteHeader(403)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ServeHTTP</code>只是检查请求的Host：</p>\n<ul>\n<li>如果Host和配置的allowed一直，那么调用handler的ServeHTTP。</li>\n<li>如果不一直返回403<br>&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。<br>&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)</span><br><span class=\"line\">http.ListenAndServe(&quot;:8080&quot;, singleHosted)</span><br></pre></td></tr></table></figure>\n<h3 id=\"另一种方式\"><a href=\"#另一种方式\" class=\"headerlink\" title=\"另一种方式\"></a>另一种方式</h3><p>&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有<code>http.HandlerFunc</code>包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func SingleHost(handler http.Handler, allowedHost string) http.Handler &#123;</span><br><span class=\"line\">    ourFunc := func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        host := r.Host</span><br><span class=\"line\">        if host == allowedHost &#123;</span><br><span class=\"line\">            handler.ServeHTTP(w, r)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            w.WriteHeader(403)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return http.HandlerFunc(ourFunc)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 我们定义了一个简单的函数<code>SingleHost</code>，它包装了<code>Handler</code>和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。<br>&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。<br>&emsp;&emsp; 同时标准库同时使用了两种功能。<code>StripPrefix</code>使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。</p>\n<h3 id=\"一个更复杂的例子\"><a href=\"#一个更复杂的例子\" class=\"headerlink\" title=\"一个更复杂的例子\"></a>一个更复杂的例子</h3><p>&emsp;&emsp; 我们的<code>SingleHost</code>并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。</p>\n<h3 id=\"添加数据是简单的\"><a href=\"#添加数据是简单的\" class=\"headerlink\" title=\"添加数据是简单的\"></a>添加数据是简单的</h3><p>&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type AppendMiddleware struct &#123;</span><br><span class=\"line\">    handler http.Handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    a.handler.ServeHTTP(w, r)</span><br><span class=\"line\">    w.Write([]byte(&quot;Middleware says hello.&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 返回的结构肯定会包含<code>Middleware says hello.</code></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。<br>&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。<br>&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。<br>&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在<code>net/http/httptest</code>包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ModifierMiddleware struct &#123;</span><br><span class=\"line\">    handler http.Handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    rec := httptest.NewRecorder()</span><br><span class=\"line\">    // passing a ResponseRecorder instead of the original RW</span><br><span class=\"line\">    m.handler.ServeHTTP(rec, r)</span><br><span class=\"line\">    // after this finishes, we have the response recorded</span><br><span class=\"line\">    // and can modify it before copying it to the original RW</span><br><span class=\"line\"></span><br><span class=\"line\">    // we copy the original headers first</span><br><span class=\"line\">    for k, v := range rec.Header() &#123;</span><br><span class=\"line\">        w.Header()[k] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // and set an additional one</span><br><span class=\"line\">    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)</span><br><span class=\"line\">    // only then the status code, as this call writes out the headers </span><br><span class=\"line\">    w.WriteHeader(418)</span><br><span class=\"line\"></span><br><span class=\"line\">    // The body hasn&apos;t been written (to the real RW) yet,</span><br><span class=\"line\">    // so we can prepend some data.</span><br><span class=\"line\">    data := []byte(&quot;Middleware says hello again. &quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // But the Content-Length might have been set already,</span><br><span class=\"line\">    // we should modify it by adding the length</span><br><span class=\"line\">    // of our own data.</span><br><span class=\"line\">    // Ignoring the error is fine here:</span><br><span class=\"line\">    // if Content-Length is empty or otherwise invalid,</span><br><span class=\"line\">    // Atoi() will return zero,</span><br><span class=\"line\">    // which is just what we&apos;d want in that case.</span><br><span class=\"line\">    clen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))</span><br><span class=\"line\">    clen += len(data)</span><br><span class=\"line\">    r.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))</span><br><span class=\"line\"></span><br><span class=\"line\">    // finally, write out our data</span><br><span class=\"line\">    w.Write(data)</span><br><span class=\"line\">    // then write out the original body</span><br><span class=\"line\">    w.Write(rec.Body.Bytes())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后僵尸我们中间件的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 418 I&apos;m a teapot</span><br><span class=\"line\">X-We-Modified-This: Yup</span><br><span class=\"line\">Content-Type: text/plain; charset=utf-8</span><br><span class=\"line\">Content-Length: 37</span><br><span class=\"line\">Date: Tue, 03 Sep 2013 18:41:39 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Middleware says hello again. Success!</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。</p>\n<h3 id=\"和其他handler分享数据\"><a href=\"#和其他handler分享数据\" class=\"headerlink\" title=\"和其他handler分享数据\"></a>和其他handler分享数据</h3><p>&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。<br>&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type csrfContext struct &#123;</span><br><span class=\"line\">    token string</span><br><span class=\"line\">    reason error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var (</span><br><span class=\"line\">    contextMap = make(map[*http.Request]*csrfContext)</span><br><span class=\"line\">    cmMutex    = new(sync.RWMutex)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 数据由Token设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Token(req *http.Request) string &#123;</span><br><span class=\"line\">    cmMutex.RLock()</span><br><span class=\"line\">    defer cmMutex.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx, ok := contextMap[req]</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">            return &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ctx.token</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;源码可以再nosurf的项目的<a href=\"https://github.com/justinas/nosurf/blob/master/context.go\" target=\"_blank\" rel=\"noopener\">context.go</a>中找到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://justinas.org/writing-http-middleware-in-go/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。<br>&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。<br>&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库<code>net/http</code>中的函数<code>StripText</code>或者<code>TimeoutHandler</code>就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。<br>&emsp;&emsp; 我最近写的Go包<a href=\"https://github.com/justinas/nosurf\" target=\"_blank\" rel=\"noopener\">nosurf</a>同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和<code>net/http</code>的接口无缝衔接。<br>&emsp;&emsp; 同样你还可以使用中间件做：</p>\n<ul>\n<li>隐藏长度防止缓冲攻击</li>\n<li>速度限制</li>\n<li>屏蔽爬虫</li>\n<li>提供调试信息</li>\n<li>添加HSTS，X-Frame-Options头</li>\n<li>从错误中恢复</li>\n<li>等等</li>\n</ul>\n<h3 id=\"编写一个简单的中间件\"><a href=\"#编写一个简单的中间件\" class=\"headerlink\" title=\"编写一个简单的中间件\"></a>编写一个简单的中间件</h3><p>&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的<code>HOST</code>header实现。这样的中间件可以防止<a href=\"http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html\" target=\"_blank\" rel=\"noopener\">主机欺骗攻击</a>。</p>\n<h3 id=\"类型的机构\"><a href=\"#类型的机构\" class=\"headerlink\" title=\"类型的机构\"></a>类型的机构</h3><p>&emsp;&emsp; 首先我们定义一个结构体，叫做<code>SingleHost</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type SingleHost struct &#123;</span><br><span class=\"line\">    handler     http.Handler</span><br><span class=\"line\">    allowedHost string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 它只包含两个field。</p>\n<ul>\n<li>如果是一个可用的Host，那么我们会调用嵌入的handler。</li>\n<li>allowedHost 就是允许的Host。<br>&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost &#123;</span><br><span class=\"line\">    return &amp;SingleHost&#123;handler: handler, allowedHost: allowedHost&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求处理\"><a href=\"#请求处理\" class=\"headerlink\" title=\"请求处理\"></a>请求处理</h3><p>&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现<code>http.Handler</code>，我们只需要实现他的一个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Handler interface &#123;</span><br><span class=\"line\">        ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    host := r.Host</span><br><span class=\"line\">    if host == s.allowedHost &#123;</span><br><span class=\"line\">        s.handler.ServeHTTP(w, r)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        w.WriteHeader(403)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ServeHTTP</code>只是检查请求的Host：</p>\n<ul>\n<li>如果Host和配置的allowed一直，那么调用handler的ServeHTTP。</li>\n<li>如果不一直返回403<br>&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。<br>&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)</span><br><span class=\"line\">http.ListenAndServe(&quot;:8080&quot;, singleHosted)</span><br></pre></td></tr></table></figure>\n<h3 id=\"另一种方式\"><a href=\"#另一种方式\" class=\"headerlink\" title=\"另一种方式\"></a>另一种方式</h3><p>&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有<code>http.HandlerFunc</code>包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func SingleHost(handler http.Handler, allowedHost string) http.Handler &#123;</span><br><span class=\"line\">    ourFunc := func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        host := r.Host</span><br><span class=\"line\">        if host == allowedHost &#123;</span><br><span class=\"line\">            handler.ServeHTTP(w, r)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            w.WriteHeader(403)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return http.HandlerFunc(ourFunc)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp; 我们定义了一个简单的函数<code>SingleHost</code>，它包装了<code>Handler</code>和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。<br>&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。<br>&emsp;&emsp; 同时标准库同时使用了两种功能。<code>StripPrefix</code>使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。</p>\n<h3 id=\"一个更复杂的例子\"><a href=\"#一个更复杂的例子\" class=\"headerlink\" title=\"一个更复杂的例子\"></a>一个更复杂的例子</h3><p>&emsp;&emsp; 我们的<code>SingleHost</code>并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。</p>\n<h3 id=\"添加数据是简单的\"><a href=\"#添加数据是简单的\" class=\"headerlink\" title=\"添加数据是简单的\"></a>添加数据是简单的</h3><p>&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type AppendMiddleware struct &#123;</span><br><span class=\"line\">    handler http.Handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    a.handler.ServeHTTP(w, r)</span><br><span class=\"line\">    w.Write([]byte(&quot;Middleware says hello.&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 返回的结构肯定会包含<code>Middleware says hello.</code></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。<br>&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。<br>&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。<br>&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在<code>net/http/httptest</code>包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ModifierMiddleware struct &#123;</span><br><span class=\"line\">    handler http.Handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    rec := httptest.NewRecorder()</span><br><span class=\"line\">    // passing a ResponseRecorder instead of the original RW</span><br><span class=\"line\">    m.handler.ServeHTTP(rec, r)</span><br><span class=\"line\">    // after this finishes, we have the response recorded</span><br><span class=\"line\">    // and can modify it before copying it to the original RW</span><br><span class=\"line\"></span><br><span class=\"line\">    // we copy the original headers first</span><br><span class=\"line\">    for k, v := range rec.Header() &#123;</span><br><span class=\"line\">        w.Header()[k] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // and set an additional one</span><br><span class=\"line\">    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)</span><br><span class=\"line\">    // only then the status code, as this call writes out the headers </span><br><span class=\"line\">    w.WriteHeader(418)</span><br><span class=\"line\"></span><br><span class=\"line\">    // The body hasn&apos;t been written (to the real RW) yet,</span><br><span class=\"line\">    // so we can prepend some data.</span><br><span class=\"line\">    data := []byte(&quot;Middleware says hello again. &quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // But the Content-Length might have been set already,</span><br><span class=\"line\">    // we should modify it by adding the length</span><br><span class=\"line\">    // of our own data.</span><br><span class=\"line\">    // Ignoring the error is fine here:</span><br><span class=\"line\">    // if Content-Length is empty or otherwise invalid,</span><br><span class=\"line\">    // Atoi() will return zero,</span><br><span class=\"line\">    // which is just what we&apos;d want in that case.</span><br><span class=\"line\">    clen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))</span><br><span class=\"line\">    clen += len(data)</span><br><span class=\"line\">    r.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))</span><br><span class=\"line\"></span><br><span class=\"line\">    // finally, write out our data</span><br><span class=\"line\">    w.Write(data)</span><br><span class=\"line\">    // then write out the original body</span><br><span class=\"line\">    w.Write(rec.Body.Bytes())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后僵尸我们中间件的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 418 I&apos;m a teapot</span><br><span class=\"line\">X-We-Modified-This: Yup</span><br><span class=\"line\">Content-Type: text/plain; charset=utf-8</span><br><span class=\"line\">Content-Length: 37</span><br><span class=\"line\">Date: Tue, 03 Sep 2013 18:41:39 GMT</span><br><span class=\"line\"></span><br><span class=\"line\">Middleware says hello again. Success!</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。</p>\n<h3 id=\"和其他handler分享数据\"><a href=\"#和其他handler分享数据\" class=\"headerlink\" title=\"和其他handler分享数据\"></a>和其他handler分享数据</h3><p>&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。<br>&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type csrfContext struct &#123;</span><br><span class=\"line\">    token string</span><br><span class=\"line\">    reason error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var (</span><br><span class=\"line\">    contextMap = make(map[*http.Request]*csrfContext)</span><br><span class=\"line\">    cmMutex    = new(sync.RWMutex)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 数据由Token设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func Token(req *http.Request) string &#123;</span><br><span class=\"line\">    cmMutex.RLock()</span><br><span class=\"line\">    defer cmMutex.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx, ok := contextMap[req]</span><br><span class=\"line\">    if !ok &#123;</span><br><span class=\"line\">            return &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return ctx.token</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;源码可以再nosurf的项目的<a href=\"https://github.com/justinas/nosurf/blob/master/context.go\" target=\"_blank\" rel=\"noopener\">context.go</a>中找到。</p>\n"},{"title":"为Go Web App 创建一个主页面","date":"2015-11-14T09:59:00.000Z","_content":"\n\n[原文地址](http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html)\n\n&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n&emsp;&emsp; 这个简单的例子来解释如何实现的：\n&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n&emsp;&emsp; header模板的代码如下：\n\n``` Go\n{ { define \"header\" }}\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>{ {.Title}}</title>\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\">\n        <style type=\"text/css\">\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        </style>\n    </head>\n    <body>\n        <nav class=\"navbar navbar-default\" role=\"navigation\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"/\">Go App</a>\n          </div>\n          <div class=\"collapse navbar-collapse navbar-ex1-collapse\">  \n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Main</a></li>\n                <li><a href=\"/about\">About</a></li>\n            </ul>\n          </div>\n        </nav>\n{ { end }}\n```\n\n&emsp;&emsp; footer模板的代码如下：\n\n\n``` Go\n{ { define \"footer\" }}\n        <p class=\"navbar-text navbar-fixed-bottom\">Go Rocks!</p>    \n        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"></script>\n    </body>\n</html>\n{ { end }}\n\n```\n\n&emsp;&emsp; main 模板的代码如下：\n\n```\n{ {define \"main\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>Main</h2>\n    <div>This is the Main page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n&emsp;&emsp; about 模板的代码如下：\n\n```\n{ {define \"about\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>About</h2>\n    <div>This is the About page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n&emsp;&emsp; 服务器代码如下：\n\n```\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(\"header.html\", \"footer.html\", \"main.html\", \"about.html\"))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"main\", &Page{Title: \"Home\"})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"about\", &Page{Title: \"About\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", mainHandler)\n    http.HandleFunc(\"/about\", aboutHandler)\n\n    //Listen on port 8080\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n&emsp;&emsp; 每一个模板页都有一个 `{ { define \"name\" }}`的命令来定义模板的名字。main和about页面通过`{ { template \"name\" }}`来包含header和footer。`.` 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n&emsp;&emsp; 两个页面的结果如下：\n\n![main](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png)  \n![about](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png)  \n","source":"_posts/为Go-Web-App-创建一个主页面.md","raw":"title: 为Go Web App 创建一个主页面\ndate: 2015-11-14 17:59:00\ntags:\n  - Go\n  - Translate\n---\n\n\n[原文地址](http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html)\n\n&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n&emsp;&emsp; 这个简单的例子来解释如何实现的：\n&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n&emsp;&emsp; header模板的代码如下：\n\n``` Go\n{ { define \"header\" }}\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>{ {.Title}}</title>\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\">\n        <style type=\"text/css\">\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        </style>\n    </head>\n    <body>\n        <nav class=\"navbar navbar-default\" role=\"navigation\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"/\">Go App</a>\n          </div>\n          <div class=\"collapse navbar-collapse navbar-ex1-collapse\">  \n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Main</a></li>\n                <li><a href=\"/about\">About</a></li>\n            </ul>\n          </div>\n        </nav>\n{ { end }}\n```\n\n&emsp;&emsp; footer模板的代码如下：\n\n\n``` Go\n{ { define \"footer\" }}\n        <p class=\"navbar-text navbar-fixed-bottom\">Go Rocks!</p>    \n        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"></script>\n    </body>\n</html>\n{ { end }}\n\n```\n\n&emsp;&emsp; main 模板的代码如下：\n\n```\n{ {define \"main\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>Main</h2>\n    <div>This is the Main page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n&emsp;&emsp; about 模板的代码如下：\n\n```\n{ {define \"about\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>About</h2>\n    <div>This is the About page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n&emsp;&emsp; 服务器代码如下：\n\n```\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(\"header.html\", \"footer.html\", \"main.html\", \"about.html\"))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"main\", &Page{Title: \"Home\"})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"about\", &Page{Title: \"About\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", mainHandler)\n    http.HandleFunc(\"/about\", aboutHandler)\n\n    //Listen on port 8080\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n&emsp;&emsp; 每一个模板页都有一个 `{ { define \"name\" }}`的命令来定义模板的名字。main和about页面通过`{ { template \"name\" }}`来包含header和footer。`.` 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n&emsp;&emsp; 两个页面的结果如下：\n\n![main](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png)  \n![about](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png)  \n","slug":"为Go-Web-App-创建一个主页面","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds6a000kmart7cse68c4","content":"<p><a href=\"http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。<br>&emsp;&emsp; 这个简单的例子来解释如何实现的：<br>&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。<br>&emsp;&emsp; header模板的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123; define <span class=\"string\">\"header\"</span> &#125;&#125;</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;title&gt;&#123; &#123;.Title&#125;&#125;&lt;/title&gt;</span><br><span class=\"line\">        &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\"</span>&gt;</span><br><span class=\"line\">        &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\"</span>&gt;</span><br><span class=\"line\">        &lt;style <span class=\"keyword\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><br><span class=\"line\">            body &#123;padding-bottom: <span class=\"number\">70</span>px;&#125;</span><br><span class=\"line\">            .content &#123;margin:<span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">        &lt;/style&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;nav class=<span class=\"string\">\"navbar navbar-default\"</span> role=<span class=\"string\">\"navigation\"</span>&gt;</span><br><span class=\"line\">          &lt;div class=<span class=\"string\">\"navbar-header\"</span>&gt;</span><br><span class=\"line\">            &lt;a class=\"navbar-brand\" href=\"/\"&gt;Go App&lt;/a&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &lt;div class=<span class=\"string\">\"collapse navbar-collapse navbar-ex1-collapse\"</span>&gt;  </span><br><span class=\"line\">            &lt;ul class=<span class=\"string\">\"nav navbar-nav\"</span>&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"/\"&gt;Main&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;/ul&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/nav&gt;</span><br><span class=\"line\">&#123; &#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; footer模板的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123; define <span class=\"string\">\"footer\"</span> &#125;&#125;</span><br><span class=\"line\">        &lt;p class=\"navbar-text navbar-fixed-bottom\"&gt;Go Rocks!&lt;/p&gt;    </span><br><span class=\"line\">        &lt;script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&#123; &#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; main 模板的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123;define &quot;main&quot;&#125;&#125;</span><br><span class=\"line\">&#123; &#123; template &quot;header&quot; .&#125;&#125;</span><br><span class=\"line\">&lt;div class=&quot;content&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;Main&lt;/h2&gt;</span><br><span class=\"line\">    &lt;div&gt;This is the Main page&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</span><br><span class=\"line\">&#123; &#123; end&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; about 模板的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123;define &quot;about&quot;&#125;&#125;</span><br><span class=\"line\">&#123; &#123; template &quot;header&quot; .&#125;&#125;</span><br><span class=\"line\">&lt;div class=&quot;content&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;About&lt;/h2&gt;</span><br><span class=\"line\">    &lt;div&gt;This is the About page&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</span><br><span class=\"line\">&#123; &#123; end&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 服务器代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;html/template&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">//Compile templates on start</span><br><span class=\"line\">var templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">//A Page structure</span><br><span class=\"line\">type Page struct &#123;</span><br><span class=\"line\">    Title string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Display the named template</span><br><span class=\"line\">func display(w http.ResponseWriter, tmpl string, data interface&#123;&#125;) &#123;</span><br><span class=\"line\">    templates.ExecuteTemplate(w, tmpl, data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//The handlers.</span><br><span class=\"line\">func mainHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    display(w, &quot;main&quot;, &amp;Page&#123;Title: &quot;Home&quot;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func aboutHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    display(w, &quot;about&quot;, &amp;Page&#123;Title: &quot;About&quot;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, mainHandler)</span><br><span class=\"line\">    http.HandleFunc(&quot;/about&quot;, aboutHandler)</span><br><span class=\"line\"></span><br><span class=\"line\">    //Listen on port 8080</span><br><span class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 每一个模板页都有一个 <code>{ { define &quot;name&quot; }}</code>的命令来定义模板的名字。main和about页面通过<code>{ { template &quot;name&quot; }}</code>来包含header和footer。<code>.</code> 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。<br>&emsp;&emsp; 两个页面的结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png\" alt=\"main\"><br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png\" alt=\"about\">  </p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。<br>&emsp;&emsp; 这个简单的例子来解释如何实现的：<br>&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。<br>&emsp;&emsp; header模板的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123; define <span class=\"string\">\"header\"</span> &#125;&#125;</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;title&gt;&#123; &#123;.Title&#125;&#125;&lt;/title&gt;</span><br><span class=\"line\">        &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\"</span>&gt;</span><br><span class=\"line\">        &lt;link rel=<span class=\"string\">\"stylesheet\"</span> href=<span class=\"string\">\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\"</span>&gt;</span><br><span class=\"line\">        &lt;style <span class=\"keyword\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><br><span class=\"line\">            body &#123;padding-bottom: <span class=\"number\">70</span>px;&#125;</span><br><span class=\"line\">            .content &#123;margin:<span class=\"number\">10</span>px;&#125;</span><br><span class=\"line\">        &lt;/style&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;nav class=<span class=\"string\">\"navbar navbar-default\"</span> role=<span class=\"string\">\"navigation\"</span>&gt;</span><br><span class=\"line\">          &lt;div class=<span class=\"string\">\"navbar-header\"</span>&gt;</span><br><span class=\"line\">            &lt;a class=\"navbar-brand\" href=\"/\"&gt;Go App&lt;/a&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &lt;div class=<span class=\"string\">\"collapse navbar-collapse navbar-ex1-collapse\"</span>&gt;  </span><br><span class=\"line\">            &lt;ul class=<span class=\"string\">\"nav navbar-nav\"</span>&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"/\"&gt;Main&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;/ul&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/nav&gt;</span><br><span class=\"line\">&#123; &#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; footer模板的代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123; define <span class=\"string\">\"footer\"</span> &#125;&#125;</span><br><span class=\"line\">        &lt;p class=\"navbar-text navbar-fixed-bottom\"&gt;Go Rocks!&lt;/p&gt;    </span><br><span class=\"line\">        &lt;script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">&#123; &#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; main 模板的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123;define &quot;main&quot;&#125;&#125;</span><br><span class=\"line\">&#123; &#123; template &quot;header&quot; .&#125;&#125;</span><br><span class=\"line\">&lt;div class=&quot;content&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;Main&lt;/h2&gt;</span><br><span class=\"line\">    &lt;div&gt;This is the Main page&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</span><br><span class=\"line\">&#123; &#123; end&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; about 模板的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; &#123;define &quot;about&quot;&#125;&#125;</span><br><span class=\"line\">&#123; &#123; template &quot;header&quot; .&#125;&#125;</span><br><span class=\"line\">&lt;div class=&quot;content&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;About&lt;/h2&gt;</span><br><span class=\"line\">    &lt;div&gt;This is the About page&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</span><br><span class=\"line\">&#123; &#123; end&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 服务器代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;html/template&quot;</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">//Compile templates on start</span><br><span class=\"line\">var templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">//A Page structure</span><br><span class=\"line\">type Page struct &#123;</span><br><span class=\"line\">    Title string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Display the named template</span><br><span class=\"line\">func display(w http.ResponseWriter, tmpl string, data interface&#123;&#125;) &#123;</span><br><span class=\"line\">    templates.ExecuteTemplate(w, tmpl, data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//The handlers.</span><br><span class=\"line\">func mainHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    display(w, &quot;main&quot;, &amp;Page&#123;Title: &quot;Home&quot;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func aboutHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    display(w, &quot;about&quot;, &amp;Page&#123;Title: &quot;About&quot;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;/&quot;, mainHandler)</span><br><span class=\"line\">    http.HandleFunc(&quot;/about&quot;, aboutHandler)</span><br><span class=\"line\"></span><br><span class=\"line\">    //Listen on port 8080</span><br><span class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp; 每一个模板页都有一个 <code>{ { define &quot;name&quot; }}</code>的命令来定义模板的名字。main和about页面通过<code>{ { template &quot;name&quot; }}</code>来包含header和footer。<code>.</code> 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。<br>&emsp;&emsp; 两个页面的结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png\" alt=\"main\"><br><img src=\"https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png\" alt=\"about\">  </p>\n"},{"title":"Jackson 简明教程","date":"2018-03-30T16:39:10.000Z","_content":"\n[原文地址](https://github.com/FasterXML/jackson-databind/)  \n#### 一分钟教程：POJOs和JSON的互相转换\n&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n```\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n```\n我们需要一个`com.fasterxml.jackson.databind.ObjectMapper`的实例来做所有的数据绑定，`ObjectMapper`仅需要创建一次即可。  \n```\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n```\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用`ObjectMapper`的示例：  \n```\nMyValue value = mapper.readValue(new File(\"data.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(\"http://some.com/api/entry.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"age\\\":13}\", MyValue.class);\n```\n如果想要生成JSON，只需要反过来就行：\n```\nmapper.writeValue(new File(\"result.json\"), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n```\n#### 三分钟教程：泛型集合和树模型\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的`List`和`Map`:  \n```\nMap<String, Integer> scoreByName = mapper.readValue(jsonSource, Map.class);\nList<String> names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(\"names.json\"), names);\n```\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是`List`等类型，则不需要指定类型)  \n```\nMap<String, ResultValue> results = mapper.readValue(jsonSource,\n   new TypeReference<Map<String, ResultValue>>() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n```\n然而，处理`Map`,`List`和其他'简单'类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的`Tree Model`迟早有用。  \n```\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(\"stuff.json\");\nString name = root.get(\"name\").asText();\nint age = root.get(\"age\").asInt();\n\n// can modify as well: this adds child Object as property 'other', set property 'type'\nroot.with(\"other\").put(\"type\", \"student\");\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as 'json' String:\n// {\n//   \"name\" : \"Bob\", \"age\" : 13,\n//   \"other\" : {\n//      \"type\" : \"student\"\n//   }\n// }\n```\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n#### 五分钟教程：Streaming parser, generator\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n```\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(\"test.json\");\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { \"message\" : \"Hello world!\" }\ng.writeStartObject();\ng.writeStringField(\"message\", \"Hello world!\");\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT\nt = p.nextToken(); // JsonToken.FIELD_NAME\nif ((t != JsonToken.FIELD_NAME) || !\"message\".equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUE_STRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(\"My message to you is: %s!\\n\", msg);\np.close(); }\n```\n#### 10分钟教程：配置\n有两种入门的配置方法：feature 和 Annotation\n##### feature 配置\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n```\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (\"pretty-printing\"):\nmapper.enable(SerializationFeature.INDENT_OUTPUT);\n// to allow serialization of \"empty\" POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n// to allow coercion of JSON empty String (\"\") to null Object value:\nmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n```\n下面是一些可以控制JSON底层解析，生成的配置：\n```\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)\nmapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n```\n##### 注解配置：修改属性名\n最简单的使用注解配置的方式是使用`@JsonProperty`:  \n```\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we'd get \"theName\", but we want \"name\":\n   @JsonProperty(\"name\")\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n```\n##### 注解配置：忽略属性\n有两个可以设置忽略属性的注解，一个是`@JsonIgnore` 修饰的是单个属性，一个是`@JsonIgnoreProperties` 修饰的类。\n```\n// means that if we see \"foo\" or \"bar\" in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ \"foo\", \"bar\" })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n```\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了`@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n```\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n```\n在这个例子中，`name`不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n##### 注解配置：定制注解构造器\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n```\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(\"name\") String name,\n    @JsonProperty(\"age\") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n```\n构造函数在不可变对象中非常实用。  \n也可以直接定义一个工厂方法：\n```\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n    @JsonCreator\n    public static FactoryBean create(@JsonProperty(\"name\") String name) {\n      // construct and return an instance\n    }\n}\n```\n#### 其他特性：\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n```\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n```\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n```\n// Convert from List<Integer> to int[]\nList<Integer> sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap<String,Object> propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\";\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n```\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。\n","source":"_posts/jackson-tutorial.md","raw":"title: 'Jackson 简明教程'\ndate: 2018-03-31 00:39:10\ntags:\n  - JSON\n  - Java\n  - Jackson\n  - Translate\n---\n\n[原文地址](https://github.com/FasterXML/jackson-databind/)  \n#### 一分钟教程：POJOs和JSON的互相转换\n&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n```\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n```\n我们需要一个`com.fasterxml.jackson.databind.ObjectMapper`的实例来做所有的数据绑定，`ObjectMapper`仅需要创建一次即可。  \n```\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n```\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用`ObjectMapper`的示例：  \n```\nMyValue value = mapper.readValue(new File(\"data.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(\"http://some.com/api/entry.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"age\\\":13}\", MyValue.class);\n```\n如果想要生成JSON，只需要反过来就行：\n```\nmapper.writeValue(new File(\"result.json\"), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n```\n#### 三分钟教程：泛型集合和树模型\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的`List`和`Map`:  \n```\nMap<String, Integer> scoreByName = mapper.readValue(jsonSource, Map.class);\nList<String> names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(\"names.json\"), names);\n```\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是`List`等类型，则不需要指定类型)  \n```\nMap<String, ResultValue> results = mapper.readValue(jsonSource,\n   new TypeReference<Map<String, ResultValue>>() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n```\n然而，处理`Map`,`List`和其他'简单'类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的`Tree Model`迟早有用。  \n```\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(\"stuff.json\");\nString name = root.get(\"name\").asText();\nint age = root.get(\"age\").asInt();\n\n// can modify as well: this adds child Object as property 'other', set property 'type'\nroot.with(\"other\").put(\"type\", \"student\");\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as 'json' String:\n// {\n//   \"name\" : \"Bob\", \"age\" : 13,\n//   \"other\" : {\n//      \"type\" : \"student\"\n//   }\n// }\n```\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n#### 五分钟教程：Streaming parser, generator\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n```\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(\"test.json\");\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { \"message\" : \"Hello world!\" }\ng.writeStartObject();\ng.writeStringField(\"message\", \"Hello world!\");\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT\nt = p.nextToken(); // JsonToken.FIELD_NAME\nif ((t != JsonToken.FIELD_NAME) || !\"message\".equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUE_STRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(\"My message to you is: %s!\\n\", msg);\np.close(); }\n```\n#### 10分钟教程：配置\n有两种入门的配置方法：feature 和 Annotation\n##### feature 配置\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n```\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (\"pretty-printing\"):\nmapper.enable(SerializationFeature.INDENT_OUTPUT);\n// to allow serialization of \"empty\" POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n// to allow coercion of JSON empty String (\"\") to null Object value:\nmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n```\n下面是一些可以控制JSON底层解析，生成的配置：\n```\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)\nmapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n```\n##### 注解配置：修改属性名\n最简单的使用注解配置的方式是使用`@JsonProperty`:  \n```\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we'd get \"theName\", but we want \"name\":\n   @JsonProperty(\"name\")\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n```\n##### 注解配置：忽略属性\n有两个可以设置忽略属性的注解，一个是`@JsonIgnore` 修饰的是单个属性，一个是`@JsonIgnoreProperties` 修饰的类。\n```\n// means that if we see \"foo\" or \"bar\" in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ \"foo\", \"bar\" })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n```\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了`@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n```\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n```\n在这个例子中，`name`不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n##### 注解配置：定制注解构造器\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n```\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(\"name\") String name,\n    @JsonProperty(\"age\") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n```\n构造函数在不可变对象中非常实用。  \n也可以直接定义一个工厂方法：\n```\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n    @JsonCreator\n    public static FactoryBean create(@JsonProperty(\"name\") String name) {\n      // construct and return an instance\n    }\n}\n```\n#### 其他特性：\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n```\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n```\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n```\n// Convert from List<Integer> to int[]\nList<Integer> sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap<String,Object> propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\";\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n```\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。\n","slug":"jackson-tutorial","published":1,"updated":"2018-04-06T13:56:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds6c000mmartjwnj65io","content":"<p><a href=\"https://github.com/FasterXML/jackson-databind/\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<h4 id=\"一分钟教程：POJOs和JSON的互相转换\"><a href=\"#一分钟教程：POJOs和JSON的互相转换\" class=\"headerlink\" title=\"一分钟教程：POJOs和JSON的互相转换\"></a>一分钟教程：POJOs和JSON的互相转换</h4><p>&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: can use getters/setters as well; here we just use public fields directly:</span><br><span class=\"line\">public class MyValue &#123;</span><br><span class=\"line\">  public String name;</span><br><span class=\"line\">  public int age;</span><br><span class=\"line\">  // NOTE: if using getters/setters, can keep fields `protected` or `private`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要一个<code>com.fasterxml.jackson.databind.ObjectMapper</code>的实例来做所有的数据绑定，<code>ObjectMapper</code>仅需要创建一次即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</span><br></pre></td></tr></table></figure></p>\n<p>采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用<code>ObjectMapper</code>的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">value = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">value = mapper.readValue(&quot;&#123;\\&quot;name\\&quot;:\\&quot;Bob\\&quot;, \\&quot;age\\&quot;:13&#125;&quot;, MyValue.class);</span><br></pre></td></tr></table></figure></p>\n<p>如果想要生成JSON，只需要反过来就行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapper.writeValue(new File(&quot;result.json&quot;), myResultObject);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"三分钟教程：泛型集合和树模型\"><a href=\"#三分钟教程：泛型集合和树模型\" class=\"headerlink\" title=\"三分钟教程：泛型集合和树模型\"></a>三分钟教程：泛型集合和树模型</h4><p>除了处理Bean风格的POJO，Jackson同时可以处理JDK的<code>List</code>和<code>Map</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);</span><br><span class=\"line\">List&lt;String&gt; names = mapper.readValue(jsonSource, List.class);</span><br><span class=\"line\"></span><br><span class=\"line\">// and can obviously write out as well</span><br><span class=\"line\">mapper.writeValue(new File(&quot;names.json&quot;), names);</span><br></pre></td></tr></table></figure></p>\n<p>匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是<code>List</code>等类型，则不需要指定类型)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,</span><br><span class=\"line\">   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() &#123; &#125; );</span><br><span class=\"line\">// why extra work? Java Type Erasure will prevent type detection otherwise &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然而，处理<code>Map</code>,<code>List</code>和其他’简单’类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的<code>Tree Model</code>迟早有用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// can be read as generic JsonNode, if it can be Object or Array; or,</span><br><span class=\"line\">// if known to be Object, as ObjectNode, if array, ArrayNode etc:</span><br><span class=\"line\">ObjectNode root = mapper.readTree(&quot;stuff.json&quot;);</span><br><span class=\"line\">String name = root.get(&quot;name&quot;).asText();</span><br><span class=\"line\">int age = root.get(&quot;age&quot;).asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">// can modify as well: this adds child Object as property &apos;other&apos;, set property &apos;type&apos;</span><br><span class=\"line\">root.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);</span><br><span class=\"line\">String json = mapper.writeValueAsString(root);</span><br><span class=\"line\"></span><br><span class=\"line\">// with above, we end up with something like as &apos;json&apos; String:</span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,</span><br><span class=\"line\">//   &quot;other&quot; : &#123;</span><br><span class=\"line\">//      &quot;type&quot; : &quot;student&quot;</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure></p>\n<p>树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。</p>\n<h4 id=\"五分钟教程：Streaming-parser-generator\"><a href=\"#五分钟教程：Streaming-parser-generator\" class=\"headerlink\" title=\"五分钟教程：Streaming parser, generator\"></a>五分钟教程：Streaming parser, generator</h4><p>有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JsonFactory f = mapper.getFactory(); // may alternatively construct directly too</span><br><span class=\"line\"></span><br><span class=\"line\">// First: write simple JSON output</span><br><span class=\"line\">File jsonFile = new File(&quot;test.json&quot;);</span><br><span class=\"line\">JsonGenerator g = f.createGenerator(jsonFile);</span><br><span class=\"line\">// write JSON: &#123; &quot;message&quot; : &quot;Hello world!&quot; &#125;</span><br><span class=\"line\">g.writeStartObject();</span><br><span class=\"line\">g.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);</span><br><span class=\"line\">g.writeEndObject();</span><br><span class=\"line\">g.close();</span><br><span class=\"line\"></span><br><span class=\"line\">// Second: read file back</span><br><span class=\"line\">JsonParser p = f.createParser(jsonFile);</span><br><span class=\"line\"></span><br><span class=\"line\">JsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT</span><br><span class=\"line\">t = p.nextToken(); // JsonToken.FIELD_NAME</span><br><span class=\"line\">if ((t != JsonToken.FIELD_NAME) || !&quot;message&quot;.equals(p.getCurrentName())) &#123;</span><br><span class=\"line\">   // handle error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">t = p.nextToken();</span><br><span class=\"line\">if (t != JsonToken.VALUE_STRING) &#123;</span><br><span class=\"line\">   // similarly</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String msg = p.getText();</span><br><span class=\"line\">System.out.printf(&quot;My message to you is: %s!\\n&quot;, msg);</span><br><span class=\"line\">p.close(); &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10分钟教程：配置\"><a href=\"#10分钟教程：配置\" class=\"headerlink\" title=\"10分钟教程：配置\"></a>10分钟教程：配置</h4><p>有两种入门的配置方法：feature 和 Annotation</p>\n<h5 id=\"feature-配置\"><a href=\"#feature-配置\" class=\"headerlink\" title=\"feature 配置\"></a>feature 配置</h5><p>下面是一些最常用的配置<br>首先从高层的data-bind配置开始：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SerializationFeature for changing how JSON is written</span><br><span class=\"line\"></span><br><span class=\"line\">// to enable standard indentation (&quot;pretty-printing&quot;):</span><br><span class=\"line\">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class=\"line\">// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)</span><br><span class=\"line\">// (without this setting, an exception is thrown in those cases)</span><br><span class=\"line\">mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class=\"line\">// to write java.util.Date, Calendar as number (timestamp):</span><br><span class=\"line\">mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class=\"line\"></span><br><span class=\"line\">// DeserializationFeature for changing how JSON is read as POJOs:</span><br><span class=\"line\"></span><br><span class=\"line\">// to prevent exception when encountering unknown property:</span><br><span class=\"line\">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class=\"line\">// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:</span><br><span class=\"line\">mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br></pre></td></tr></table></figure></p>\n<p>下面是一些可以控制JSON底层解析，生成的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// JsonParser.Feature for configuring parsing settings:</span><br><span class=\"line\"></span><br><span class=\"line\">// to allow C/C++ style comments in JSON (non-standard, disabled by default)</span><br><span class=\"line\">// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);</span><br><span class=\"line\">// to allow (non-standard) unquoted field names in JSON:</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</span><br><span class=\"line\">// to allow use of apostrophes (single quotes), non standard</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// JsonGenerator.Feature for configuring low-level JSON generation:</span><br><span class=\"line\"></span><br><span class=\"line\">// to force escaping of non-ASCII characters:</span><br><span class=\"line\">mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"注解配置：修改属性名\"><a href=\"#注解配置：修改属性名\" class=\"headerlink\" title=\"注解配置：修改属性名\"></a>注解配置：修改属性名</h5><p>最简单的使用注解配置的方式是使用<code>@JsonProperty</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyBean &#123;</span><br><span class=\"line\">   private String _name;</span><br><span class=\"line\"></span><br><span class=\"line\">   // without annotation, we&apos;d get &quot;theName&quot;, but we want &quot;name&quot;:</span><br><span class=\"line\">   @JsonProperty(&quot;name&quot;)</span><br><span class=\"line\">   public String getTheName() &#123; return _name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // note: it is enough to add annotation on just getter OR setter;</span><br><span class=\"line\">   // so we can omit it here</span><br><span class=\"line\">   public void setTheName(String n) &#123; _name = n; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"注解配置：忽略属性\"><a href=\"#注解配置：忽略属性\" class=\"headerlink\" title=\"注解配置：忽略属性\"></a>注解配置：忽略属性</h5><p>有两个可以设置忽略属性的注解，一个是<code>@JsonIgnore</code> 修饰的是单个属性，一个是<code>@JsonIgnoreProperties</code> 修饰的类。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped</span><br><span class=\"line\">// regardless of whether POJO has such properties</span><br><span class=\"line\">@JsonIgnoreProperties(&#123; &quot;foo&quot;, &quot;bar&quot; &#125;)</span><br><span class=\"line\">public class MyBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   // will not be written as JSON; nor assigned from JSON:</span><br><span class=\"line\">   @JsonIgnore</span><br><span class=\"line\">   public String internal;</span><br><span class=\"line\"></span><br><span class=\"line\">   // no annotation, public field is read/written normally</span><br><span class=\"line\">   public String external;</span><br><span class=\"line\"></span><br><span class=\"line\">   @JsonIgnore</span><br><span class=\"line\">   public void setCode(int c) &#123; _code = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // note: will also be ignored because setter has annotation!</span><br><span class=\"line\">   public int getCode() &#123; return _code; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了<code>@JsonIgnore</code>，其他的也受影响。当然也可以使用分离的注解来解决问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReadButDontWriteProps &#123;</span><br><span class=\"line\">   private String _name;</span><br><span class=\"line\">   @JsonProperty public void setName(String n) &#123; _name = n; &#125;</span><br><span class=\"line\">   @JsonIgnore public String getName() &#123; return _name; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，<code>name</code>不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。</p>\n<h5 id=\"注解配置：定制注解构造器\"><a href=\"#注解配置：定制注解构造器\" class=\"headerlink\" title=\"注解配置：定制注解构造器\"></a>注解配置：定制注解构造器</h5><p>和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CtorBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public final String name;</span><br><span class=\"line\">  public final int age;</span><br><span class=\"line\"></span><br><span class=\"line\">  @JsonCreator // constructor can be public, private, whatever</span><br><span class=\"line\">  private CtorBean(@JsonProperty(&quot;name&quot;) String name,</span><br><span class=\"line\">    @JsonProperty(&quot;age&quot;) int age)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      this.name = name;</span><br><span class=\"line\">      this.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数在不可变对象中非常实用。<br>也可以直接定义一个工厂方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FactoryBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fields etc omitted for brewity</span><br><span class=\"line\"></span><br><span class=\"line\">    @JsonCreator</span><br><span class=\"line\">    public static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) &#123;</span><br><span class=\"line\">      // construct and return an instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他特性：\"><a href=\"#其他特性：\" class=\"headerlink\" title=\"其他特性：\"></a>其他特性：</h4><p>一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。<br>转换在兼容的类型中运行的很好：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultType result = mapper.convertValue(sourceObject, ResultType.class);</span><br></pre></td></tr></table></figure></p>\n<p>只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Convert from List&lt;Integer&gt; to int[]</span><br><span class=\"line\">List&lt;Integer&gt; sourceList = ...;</span><br><span class=\"line\">int[] ints = mapper.convertValue(sourceList, int[].class);</span><br><span class=\"line\">// Convert a POJO into Map!</span><br><span class=\"line\">Map&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);</span><br><span class=\"line\">// ... and back</span><br><span class=\"line\">PojoType pojo = mapper.convertValue(propertyMap, PojoType.class);</span><br><span class=\"line\">// decode Base64! (default byte[] representation is base64-encoded String)</span><br><span class=\"line\">String base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;</span><br><span class=\"line\">byte[] binary = mapper.convertValue(base64, byte[].class);</span><br></pre></td></tr></table></figure></p>\n<p>基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/FasterXML/jackson-databind/\" target=\"_blank\" rel=\"noopener\">原文地址</a>  </p>\n<h4 id=\"一分钟教程：POJOs和JSON的互相转换\"><a href=\"#一分钟教程：POJOs和JSON的互相转换\" class=\"headerlink\" title=\"一分钟教程：POJOs和JSON的互相转换\"></a>一分钟教程：POJOs和JSON的互相转换</h4><p>&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Note: can use getters/setters as well; here we just use public fields directly:</span><br><span class=\"line\">public class MyValue &#123;</span><br><span class=\"line\">  public String name;</span><br><span class=\"line\">  public int age;</span><br><span class=\"line\">  // NOTE: if using getters/setters, can keep fields `protected` or `private`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要一个<code>com.fasterxml.jackson.databind.ObjectMapper</code>的实例来做所有的数据绑定，<code>ObjectMapper</code>仅需要创建一次即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</span><br></pre></td></tr></table></figure></p>\n<p>采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用<code>ObjectMapper</code>的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">value = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">value = mapper.readValue(&quot;&#123;\\&quot;name\\&quot;:\\&quot;Bob\\&quot;, \\&quot;age\\&quot;:13&#125;&quot;, MyValue.class);</span><br></pre></td></tr></table></figure></p>\n<p>如果想要生成JSON，只需要反过来就行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapper.writeValue(new File(&quot;result.json&quot;), myResultObject);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class=\"line\">// or:</span><br><span class=\"line\">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"三分钟教程：泛型集合和树模型\"><a href=\"#三分钟教程：泛型集合和树模型\" class=\"headerlink\" title=\"三分钟教程：泛型集合和树模型\"></a>三分钟教程：泛型集合和树模型</h4><p>除了处理Bean风格的POJO，Jackson同时可以处理JDK的<code>List</code>和<code>Map</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);</span><br><span class=\"line\">List&lt;String&gt; names = mapper.readValue(jsonSource, List.class);</span><br><span class=\"line\"></span><br><span class=\"line\">// and can obviously write out as well</span><br><span class=\"line\">mapper.writeValue(new File(&quot;names.json&quot;), names);</span><br></pre></td></tr></table></figure></p>\n<p>匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是<code>List</code>等类型，则不需要指定类型)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,</span><br><span class=\"line\">   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() &#123; &#125; );</span><br><span class=\"line\">// why extra work? Java Type Erasure will prevent type detection otherwise &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>然而，处理<code>Map</code>,<code>List</code>和其他’简单’类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的<code>Tree Model</code>迟早有用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// can be read as generic JsonNode, if it can be Object or Array; or,</span><br><span class=\"line\">// if known to be Object, as ObjectNode, if array, ArrayNode etc:</span><br><span class=\"line\">ObjectNode root = mapper.readTree(&quot;stuff.json&quot;);</span><br><span class=\"line\">String name = root.get(&quot;name&quot;).asText();</span><br><span class=\"line\">int age = root.get(&quot;age&quot;).asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">// can modify as well: this adds child Object as property &apos;other&apos;, set property &apos;type&apos;</span><br><span class=\"line\">root.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);</span><br><span class=\"line\">String json = mapper.writeValueAsString(root);</span><br><span class=\"line\"></span><br><span class=\"line\">// with above, we end up with something like as &apos;json&apos; String:</span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,</span><br><span class=\"line\">//   &quot;other&quot; : &#123;</span><br><span class=\"line\">//      &quot;type&quot; : &quot;student&quot;</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure></p>\n<p>树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。</p>\n<h4 id=\"五分钟教程：Streaming-parser-generator\"><a href=\"#五分钟教程：Streaming-parser-generator\" class=\"headerlink\" title=\"五分钟教程：Streaming parser, generator\"></a>五分钟教程：Streaming parser, generator</h4><p>有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JsonFactory f = mapper.getFactory(); // may alternatively construct directly too</span><br><span class=\"line\"></span><br><span class=\"line\">// First: write simple JSON output</span><br><span class=\"line\">File jsonFile = new File(&quot;test.json&quot;);</span><br><span class=\"line\">JsonGenerator g = f.createGenerator(jsonFile);</span><br><span class=\"line\">// write JSON: &#123; &quot;message&quot; : &quot;Hello world!&quot; &#125;</span><br><span class=\"line\">g.writeStartObject();</span><br><span class=\"line\">g.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);</span><br><span class=\"line\">g.writeEndObject();</span><br><span class=\"line\">g.close();</span><br><span class=\"line\"></span><br><span class=\"line\">// Second: read file back</span><br><span class=\"line\">JsonParser p = f.createParser(jsonFile);</span><br><span class=\"line\"></span><br><span class=\"line\">JsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT</span><br><span class=\"line\">t = p.nextToken(); // JsonToken.FIELD_NAME</span><br><span class=\"line\">if ((t != JsonToken.FIELD_NAME) || !&quot;message&quot;.equals(p.getCurrentName())) &#123;</span><br><span class=\"line\">   // handle error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">t = p.nextToken();</span><br><span class=\"line\">if (t != JsonToken.VALUE_STRING) &#123;</span><br><span class=\"line\">   // similarly</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String msg = p.getText();</span><br><span class=\"line\">System.out.printf(&quot;My message to you is: %s!\\n&quot;, msg);</span><br><span class=\"line\">p.close(); &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10分钟教程：配置\"><a href=\"#10分钟教程：配置\" class=\"headerlink\" title=\"10分钟教程：配置\"></a>10分钟教程：配置</h4><p>有两种入门的配置方法：feature 和 Annotation</p>\n<h5 id=\"feature-配置\"><a href=\"#feature-配置\" class=\"headerlink\" title=\"feature 配置\"></a>feature 配置</h5><p>下面是一些最常用的配置<br>首先从高层的data-bind配置开始：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SerializationFeature for changing how JSON is written</span><br><span class=\"line\"></span><br><span class=\"line\">// to enable standard indentation (&quot;pretty-printing&quot;):</span><br><span class=\"line\">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class=\"line\">// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)</span><br><span class=\"line\">// (without this setting, an exception is thrown in those cases)</span><br><span class=\"line\">mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class=\"line\">// to write java.util.Date, Calendar as number (timestamp):</span><br><span class=\"line\">mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class=\"line\"></span><br><span class=\"line\">// DeserializationFeature for changing how JSON is read as POJOs:</span><br><span class=\"line\"></span><br><span class=\"line\">// to prevent exception when encountering unknown property:</span><br><span class=\"line\">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class=\"line\">// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:</span><br><span class=\"line\">mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br></pre></td></tr></table></figure></p>\n<p>下面是一些可以控制JSON底层解析，生成的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// JsonParser.Feature for configuring parsing settings:</span><br><span class=\"line\"></span><br><span class=\"line\">// to allow C/C++ style comments in JSON (non-standard, disabled by default)</span><br><span class=\"line\">// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);</span><br><span class=\"line\">// to allow (non-standard) unquoted field names in JSON:</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</span><br><span class=\"line\">// to allow use of apostrophes (single quotes), non standard</span><br><span class=\"line\">mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// JsonGenerator.Feature for configuring low-level JSON generation:</span><br><span class=\"line\"></span><br><span class=\"line\">// to force escaping of non-ASCII characters:</span><br><span class=\"line\">mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"注解配置：修改属性名\"><a href=\"#注解配置：修改属性名\" class=\"headerlink\" title=\"注解配置：修改属性名\"></a>注解配置：修改属性名</h5><p>最简单的使用注解配置的方式是使用<code>@JsonProperty</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyBean &#123;</span><br><span class=\"line\">   private String _name;</span><br><span class=\"line\"></span><br><span class=\"line\">   // without annotation, we&apos;d get &quot;theName&quot;, but we want &quot;name&quot;:</span><br><span class=\"line\">   @JsonProperty(&quot;name&quot;)</span><br><span class=\"line\">   public String getTheName() &#123; return _name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // note: it is enough to add annotation on just getter OR setter;</span><br><span class=\"line\">   // so we can omit it here</span><br><span class=\"line\">   public void setTheName(String n) &#123; _name = n; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"注解配置：忽略属性\"><a href=\"#注解配置：忽略属性\" class=\"headerlink\" title=\"注解配置：忽略属性\"></a>注解配置：忽略属性</h5><p>有两个可以设置忽略属性的注解，一个是<code>@JsonIgnore</code> 修饰的是单个属性，一个是<code>@JsonIgnoreProperties</code> 修饰的类。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped</span><br><span class=\"line\">// regardless of whether POJO has such properties</span><br><span class=\"line\">@JsonIgnoreProperties(&#123; &quot;foo&quot;, &quot;bar&quot; &#125;)</span><br><span class=\"line\">public class MyBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   // will not be written as JSON; nor assigned from JSON:</span><br><span class=\"line\">   @JsonIgnore</span><br><span class=\"line\">   public String internal;</span><br><span class=\"line\"></span><br><span class=\"line\">   // no annotation, public field is read/written normally</span><br><span class=\"line\">   public String external;</span><br><span class=\"line\"></span><br><span class=\"line\">   @JsonIgnore</span><br><span class=\"line\">   public void setCode(int c) &#123; _code = c; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // note: will also be ignored because setter has annotation!</span><br><span class=\"line\">   public int getCode() &#123; return _code; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了<code>@JsonIgnore</code>，其他的也受影响。当然也可以使用分离的注解来解决问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReadButDontWriteProps &#123;</span><br><span class=\"line\">   private String _name;</span><br><span class=\"line\">   @JsonProperty public void setName(String n) &#123; _name = n; &#125;</span><br><span class=\"line\">   @JsonIgnore public String getName() &#123; return _name; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，<code>name</code>不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。</p>\n<h5 id=\"注解配置：定制注解构造器\"><a href=\"#注解配置：定制注解构造器\" class=\"headerlink\" title=\"注解配置：定制注解构造器\"></a>注解配置：定制注解构造器</h5><p>和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CtorBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  public final String name;</span><br><span class=\"line\">  public final int age;</span><br><span class=\"line\"></span><br><span class=\"line\">  @JsonCreator // constructor can be public, private, whatever</span><br><span class=\"line\">  private CtorBean(@JsonProperty(&quot;name&quot;) String name,</span><br><span class=\"line\">    @JsonProperty(&quot;age&quot;) int age)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      this.name = name;</span><br><span class=\"line\">      this.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数在不可变对象中非常实用。<br>也可以直接定义一个工厂方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FactoryBean</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // fields etc omitted for brewity</span><br><span class=\"line\"></span><br><span class=\"line\">    @JsonCreator</span><br><span class=\"line\">    public static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) &#123;</span><br><span class=\"line\">      // construct and return an instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"其他特性：\"><a href=\"#其他特性：\" class=\"headerlink\" title=\"其他特性：\"></a>其他特性：</h4><p>一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。<br>转换在兼容的类型中运行的很好：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultType result = mapper.convertValue(sourceObject, ResultType.class);</span><br></pre></td></tr></table></figure></p>\n<p>只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Convert from List&lt;Integer&gt; to int[]</span><br><span class=\"line\">List&lt;Integer&gt; sourceList = ...;</span><br><span class=\"line\">int[] ints = mapper.convertValue(sourceList, int[].class);</span><br><span class=\"line\">// Convert a POJO into Map!</span><br><span class=\"line\">Map&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);</span><br><span class=\"line\">// ... and back</span><br><span class=\"line\">PojoType pojo = mapper.convertValue(propertyMap, PojoType.class);</span><br><span class=\"line\">// decode Base64! (default byte[] representation is base64-encoded String)</span><br><span class=\"line\">String base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;</span><br><span class=\"line\">byte[] binary = mapper.convertValue(base64, byte[].class);</span><br></pre></td></tr></table></figure></p>\n<p>基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。</p>\n"},{"title":"mybatis 入门","date":"2017-03-21T03:58:14.000Z","_content":"[原文链接](http://www.mybatis.org/mybatis-3/getting-started.html)\n#### 安装\n&emsp;&emsp;使用Mybatis只需要将[mybatis-x.x.x.jar](https://github.com/mybatis/mybatis-3/releases)添加到类路径即可。\n&emsp;&emsp;如果使用maven只需要将下列代码添加到pom.xml中。\n```\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n```\n#### 根据XML配置构建SqlSessionFactory\n&emsp;&emsp;每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。\n&emsp;&emsp;根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫`Resource`的工具函数，可以很容易的从类路径或者其他文件路径加载资源。\n```\nString resource = \"org/mybatis/example/mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n&emsp;&emsp;XML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n```\n&emsp;&emsp;XML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。`environment`元素包含了一个事务管理器和一个连接池。`mappers`元素包含了很多`mapper`，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。\n#### 不使用XML构建SqlSessionFactory\n&emsp;&emsp;如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。\n```\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment(\"development\", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n```\n&emsp;&emsp;注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。\n#### 从SqlSessionFactory获取SqlSession\n&emsp;&emsp; 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  Blog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;现在让我们来看一下到底执行了些什么。\n#### 探索映射的SQL语句\n&emsp;&emsp;现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。\n&emsp;&emsp;无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"org.mybatis.example.BlogMapper\">\n  <select id=\"selectBlog\" resultType=\"Blog\">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n```\n&emsp;&emsp;虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间`org.mybatis.example.BlogMapper`中定义了一个名为`selectBlog`的映射语句。他可以让你像例子中那样通过全限定名`org.mybatis.example.BlogMapper.selectBlog`调用他。\n```\nBlog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n```\n&emsp;&emsp;注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。\n```\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n```\n&emsp;&emsp;第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。\n> namespace 的注意事项  \n> MyBatis之前的版本**Namespace**是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。  \n> 正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。\n> 名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：\n> * 全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。\n> * 短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。\n\n&emsp;&emsp;对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：\n```\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select(\"SELECT * FROM blog WHERE id = #{id}\")\n  Blog selectBlog(int id);\n}\n```\n&emsp;&emsp;注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。\n&emsp;&emsp;这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。\n#### 作用域和生命周期\n&emsp;&emsp;明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。\n> **对象生命周期和依赖注入框架**    \n> 依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目\n\n##### SqlSessionFactoryBuilder\n&emsp;&emsp;这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。\n##### SqlSessionFactory\n&emsp;&emsp;当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。\n##### SqlSession\n&emsp;&emsp;每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  // do work\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;使用这个模式可以保证你的代码关闭了数据库的连接。\n##### Mapper Instances\n&emsp;&emsp;Mappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // do work\n} finally {\n  session.close();\n}\n```","source":"_posts/mybatis/mybatis-started.md","raw":"title: mybatis 入门\ndate: 2017-03-21 11:58:14\ntags:\n    - Java\n    - Mybatis\n    - Translate\n---\n[原文链接](http://www.mybatis.org/mybatis-3/getting-started.html)\n#### 安装\n&emsp;&emsp;使用Mybatis只需要将[mybatis-x.x.x.jar](https://github.com/mybatis/mybatis-3/releases)添加到类路径即可。\n&emsp;&emsp;如果使用maven只需要将下列代码添加到pom.xml中。\n```\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n```\n#### 根据XML配置构建SqlSessionFactory\n&emsp;&emsp;每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。\n&emsp;&emsp;根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫`Resource`的工具函数，可以很容易的从类路径或者其他文件路径加载资源。\n```\nString resource = \"org/mybatis/example/mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n&emsp;&emsp;XML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n```\n&emsp;&emsp;XML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。`environment`元素包含了一个事务管理器和一个连接池。`mappers`元素包含了很多`mapper`，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。\n#### 不使用XML构建SqlSessionFactory\n&emsp;&emsp;如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。\n```\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment(\"development\", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n```\n&emsp;&emsp;注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。\n#### 从SqlSessionFactory获取SqlSession\n&emsp;&emsp; 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  Blog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;现在让我们来看一下到底执行了些什么。\n#### 探索映射的SQL语句\n&emsp;&emsp;现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。\n&emsp;&emsp;无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"org.mybatis.example.BlogMapper\">\n  <select id=\"selectBlog\" resultType=\"Blog\">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n```\n&emsp;&emsp;虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间`org.mybatis.example.BlogMapper`中定义了一个名为`selectBlog`的映射语句。他可以让你像例子中那样通过全限定名`org.mybatis.example.BlogMapper.selectBlog`调用他。\n```\nBlog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n```\n&emsp;&emsp;注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。\n```\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n```\n&emsp;&emsp;第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。\n> namespace 的注意事项  \n> MyBatis之前的版本**Namespace**是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。  \n> 正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。\n> 名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：\n> * 全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。\n> * 短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。\n\n&emsp;&emsp;对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：\n```\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select(\"SELECT * FROM blog WHERE id = #{id}\")\n  Blog selectBlog(int id);\n}\n```\n&emsp;&emsp;注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。\n&emsp;&emsp;这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。\n#### 作用域和生命周期\n&emsp;&emsp;明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。\n> **对象生命周期和依赖注入框架**    \n> 依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目\n\n##### SqlSessionFactoryBuilder\n&emsp;&emsp;这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。\n##### SqlSessionFactory\n&emsp;&emsp;当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。\n##### SqlSession\n&emsp;&emsp;每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  // do work\n} finally {\n  session.close();\n}\n```\n&emsp;&emsp;使用这个模式可以保证你的代码关闭了数据库的连接。\n##### Mapper Instances\n&emsp;&emsp;Mappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他\n```\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // do work\n} finally {\n  session.close();\n}\n```","slug":"mybatis/mybatis-started","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds7t0026martd24x5hjw","content":"<p><a href=\"http://www.mybatis.org/mybatis-3/getting-started.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>&emsp;&emsp;使用Mybatis只需要将<a href=\"https://github.com/mybatis/mybatis-3/releases\" target=\"_blank\" rel=\"noopener\">mybatis-x.x.x.jar</a>添加到类路径即可。<br>&emsp;&emsp;如果使用maven只需要将下列代码添加到pom.xml中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;x.x.x&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"根据XML配置构建SqlSessionFactory\"><a href=\"#根据XML配置构建SqlSessionFactory\" class=\"headerlink\" title=\"根据XML配置构建SqlSessionFactory\"></a>根据XML配置构建SqlSessionFactory</h4><p>&emsp;&emsp;每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。<br>&emsp;&emsp;根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫<code>Resource</code>的工具函数，可以很容易的从类路径或者其他文件路径加载资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;</span><br><span class=\"line\">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;XML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">  &lt;environments default=&quot;development&quot;&gt;</span><br><span class=\"line\">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class=\"line\">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class=\"line\">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">      &lt;/dataSource&gt;</span><br><span class=\"line\">    &lt;/environment&gt;</span><br><span class=\"line\">  &lt;/environments&gt;</span><br><span class=\"line\">  &lt;mappers&gt;</span><br><span class=\"line\">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;</span><br><span class=\"line\">  &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;XML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。<code>environment</code>元素包含了一个事务管理器和一个连接池。<code>mappers</code>元素包含了很多<code>mapper</code>，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。</p>\n<h4 id=\"不使用XML构建SqlSessionFactory\"><a href=\"#不使用XML构建SqlSessionFactory\" class=\"headerlink\" title=\"不使用XML构建SqlSessionFactory\"></a>不使用XML构建SqlSessionFactory</h4><p>&emsp;&emsp;如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class=\"line\">TransactionFactory transactionFactory = new JdbcTransactionFactory();</span><br><span class=\"line\">Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);</span><br><span class=\"line\">Configuration configuration = new Configuration(environment);</span><br><span class=\"line\">configuration.addMapper(BlogMapper.class);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。</p>\n<h4 id=\"从SqlSessionFactory获取SqlSession\"><a href=\"#从SqlSessionFactory获取SqlSession\" class=\"headerlink\" title=\"从SqlSessionFactory获取SqlSession\"></a>从SqlSessionFactory获取SqlSession</h4><p>&emsp;&emsp; 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">  Blog blog = mapper.selectBlog(101);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在让我们来看一下到底执行了些什么。</p>\n<h4 id=\"探索映射的SQL语句\"><a href=\"#探索映射的SQL语句\" class=\"headerlink\" title=\"探索映射的SQL语句\"></a>探索映射的SQL语句</h4><p>&emsp;&emsp;现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。<br>&emsp;&emsp;无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class=\"line\">&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;</span><br><span class=\"line\">  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class=\"line\">    select * from Blog where id = #&#123;id&#125;</span><br><span class=\"line\">  &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间<code>org.mybatis.example.BlogMapper</code>中定义了一个名为<code>selectBlog</code>的映射语句。他可以让你像例子中那样通过全限定名<code>org.mybatis.example.BlogMapper.selectBlog</code>调用他。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">Blog blog = mapper.selectBlog(101);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。</p>\n<blockquote>\n<p>namespace 的注意事项<br>MyBatis之前的版本<strong>Namespace</strong>是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。<br>正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。<br>名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：</p>\n<ul>\n<li>全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。</li>\n<li>短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。</li>\n</ul>\n</blockquote>\n<p>&emsp;&emsp;对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.mybatis.example;</span><br><span class=\"line\">public interface BlogMapper &#123;</span><br><span class=\"line\">  @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span><br><span class=\"line\">  Blog selectBlog(int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。<br>&emsp;&emsp;这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。</p>\n<h4 id=\"作用域和生命周期\"><a href=\"#作用域和生命周期\" class=\"headerlink\" title=\"作用域和生命周期\"></a>作用域和生命周期</h4><p>&emsp;&emsp;明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。</p>\n<blockquote>\n<p><strong>对象生命周期和依赖注入框架</strong><br>依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目</p>\n</blockquote>\n<h5 id=\"SqlSessionFactoryBuilder\"><a href=\"#SqlSessionFactoryBuilder\" class=\"headerlink\" title=\"SqlSessionFactoryBuilder\"></a>SqlSessionFactoryBuilder</h5><p>&emsp;&emsp;这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。</p>\n<h5 id=\"SqlSessionFactory\"><a href=\"#SqlSessionFactory\" class=\"headerlink\" title=\"SqlSessionFactory\"></a>SqlSessionFactory</h5><p>&emsp;&emsp;当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。</p>\n<h5 id=\"SqlSession\"><a href=\"#SqlSession\" class=\"headerlink\" title=\"SqlSession\"></a>SqlSession</h5><p>&emsp;&emsp;每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  // do work</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;使用这个模式可以保证你的代码关闭了数据库的连接。</p>\n<h5 id=\"Mapper-Instances\"><a href=\"#Mapper-Instances\" class=\"headerlink\" title=\"Mapper Instances\"></a>Mapper Instances</h5><p>&emsp;&emsp;Mappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">  // do work</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.mybatis.org/mybatis-3/getting-started.html\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>&emsp;&emsp;使用Mybatis只需要将<a href=\"https://github.com/mybatis/mybatis-3/releases\" target=\"_blank\" rel=\"noopener\">mybatis-x.x.x.jar</a>添加到类路径即可。<br>&emsp;&emsp;如果使用maven只需要将下列代码添加到pom.xml中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;x.x.x&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"根据XML配置构建SqlSessionFactory\"><a href=\"#根据XML配置构建SqlSessionFactory\" class=\"headerlink\" title=\"根据XML配置构建SqlSessionFactory\"></a>根据XML配置构建SqlSessionFactory</h4><p>&emsp;&emsp;每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。<br>&emsp;&emsp;根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫<code>Resource</code>的工具函数，可以很容易的从类路径或者其他文件路径加载资源。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;</span><br><span class=\"line\">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;XML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE configuration</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">  &lt;environments default=&quot;development&quot;&gt;</span><br><span class=\"line\">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class=\"line\">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class=\"line\">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class=\"line\">      &lt;/dataSource&gt;</span><br><span class=\"line\">    &lt;/environment&gt;</span><br><span class=\"line\">  &lt;/environments&gt;</span><br><span class=\"line\">  &lt;mappers&gt;</span><br><span class=\"line\">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;</span><br><span class=\"line\">  &lt;/mappers&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;XML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。<code>environment</code>元素包含了一个事务管理器和一个连接池。<code>mappers</code>元素包含了很多<code>mapper</code>，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。</p>\n<h4 id=\"不使用XML构建SqlSessionFactory\"><a href=\"#不使用XML构建SqlSessionFactory\" class=\"headerlink\" title=\"不使用XML构建SqlSessionFactory\"></a>不使用XML构建SqlSessionFactory</h4><p>&emsp;&emsp;如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class=\"line\">TransactionFactory transactionFactory = new JdbcTransactionFactory();</span><br><span class=\"line\">Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);</span><br><span class=\"line\">Configuration configuration = new Configuration(environment);</span><br><span class=\"line\">configuration.addMapper(BlogMapper.class);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。</p>\n<h4 id=\"从SqlSessionFactory获取SqlSession\"><a href=\"#从SqlSessionFactory获取SqlSession\" class=\"headerlink\" title=\"从SqlSessionFactory获取SqlSession\"></a>从SqlSessionFactory获取SqlSession</h4><p>&emsp;&emsp; 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">  Blog blog = mapper.selectBlog(101);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;现在让我们来看一下到底执行了些什么。</p>\n<h4 id=\"探索映射的SQL语句\"><a href=\"#探索映射的SQL语句\" class=\"headerlink\" title=\"探索映射的SQL语句\"></a>探索映射的SQL语句</h4><p>&emsp;&emsp;现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。<br>&emsp;&emsp;无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE mapper</span><br><span class=\"line\">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class=\"line\">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class=\"line\">&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;</span><br><span class=\"line\">  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class=\"line\">    select * from Blog where id = #&#123;id&#125;</span><br><span class=\"line\">  &lt;/select&gt;</span><br><span class=\"line\">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间<code>org.mybatis.example.BlogMapper</code>中定义了一个名为<code>selectBlog</code>的映射语句。他可以让你像例子中那样通过全限定名<code>org.mybatis.example.BlogMapper.selectBlog</code>调用他。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">Blog blog = mapper.selectBlog(101);</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。</p>\n<blockquote>\n<p>namespace 的注意事项<br>MyBatis之前的版本<strong>Namespace</strong>是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。<br>正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。<br>名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：</p>\n<ul>\n<li>全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。</li>\n<li>短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。</li>\n</ul>\n</blockquote>\n<p>&emsp;&emsp;对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.mybatis.example;</span><br><span class=\"line\">public interface BlogMapper &#123;</span><br><span class=\"line\">  @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span><br><span class=\"line\">  Blog selectBlog(int id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。<br>&emsp;&emsp;这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。</p>\n<h4 id=\"作用域和生命周期\"><a href=\"#作用域和生命周期\" class=\"headerlink\" title=\"作用域和生命周期\"></a>作用域和生命周期</h4><p>&emsp;&emsp;明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。</p>\n<blockquote>\n<p><strong>对象生命周期和依赖注入框架</strong><br>依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目</p>\n</blockquote>\n<h5 id=\"SqlSessionFactoryBuilder\"><a href=\"#SqlSessionFactoryBuilder\" class=\"headerlink\" title=\"SqlSessionFactoryBuilder\"></a>SqlSessionFactoryBuilder</h5><p>&emsp;&emsp;这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。</p>\n<h5 id=\"SqlSessionFactory\"><a href=\"#SqlSessionFactory\" class=\"headerlink\" title=\"SqlSessionFactory\"></a>SqlSessionFactory</h5><p>&emsp;&emsp;当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。</p>\n<h5 id=\"SqlSession\"><a href=\"#SqlSession\" class=\"headerlink\" title=\"SqlSession\"></a>SqlSession</h5><p>&emsp;&emsp;每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  // do work</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;使用这个模式可以保证你的代码关闭了数据库的连接。</p>\n<h5 id=\"Mapper-Instances\"><a href=\"#Mapper-Instances\" class=\"headerlink\" title=\"Mapper Instances\"></a>Mapper Instances</h5><p>&emsp;&emsp;Mappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class=\"line\">  // do work</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"OKHttp Recipes","date":"2017-03-18T11:44:10.000Z","_content":"\n[原文地址](https://github.com/square/okhttp/wiki/Recipes)\n&emsp;&emsp;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n#### 同步GET\n&emsp;&emsp;下载文件，打印header，打印body。\n&emsp;&emsp;`string()`方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用`string()`方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n```\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i < responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n    \n```\n\n #### 异步GET\n &emsp;&emsp;在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    Headers responseHeaders = response.headers();\n    for (int i = 0, size = responseHeaders.size(); i < size; i++) {\n        System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n    }\n\n    System.out.println(response.body().string());\n    }\n});\n}\n```\n\n #### 访问Header\n &emsp;&emsp;总体上说Header有点像`Map<String,String>`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。\n 例如HTTP提供多个Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n &emsp;&emsp;当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。\n &emsp;&emsp;当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。\n &emsp;&emsp;如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/repos/square/okhttp/issues\")\n    .header(\"User-Agent\", \"OkHttp Headers.java\")\n    .addHeader(\"Accept\", \"application/json; q=0.5\")\n    .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(\"Server: \" + response.header(\"Server\"));\nSystem.out.println(\"Date: \" + response.header(\"Date\"));\nSystem.out.println(\"Vary: \" + response.headers(\"Vary\"));\n}\n```\n\n #### 使用POST发送String请求。\n &emsp;&emsp;使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = \"\"\n    + \"Releases\\n\"\n    + \"--------\\n\"\n    + \"\\n\"\n    + \" * _1.0_ May 6, 2013\\n\"\n    + \" * _1.1_ June 15, 2013\\n\"\n    + \" * _1.2_ August 11, 2013\\n\";\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送流\n &emsp;&emsp;使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了`[Okio](https://github.com/square/okio)`的缓冲库。可能你更熟悉`OutputStream`可以通过`BufferedSink.outputStream`获取。\n\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIA_TYPE_MARKDOWN;\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n    sink.writeUtf8(\"Numbers\\n\");\n    sink.writeUtf8(\"-------\\n\");\n    for (int i = 2; i <= 997; i++) {\n        sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n    }\n    }\n\n    private String factor(int n) {\n    for (int i = 2; i < n; i++) {\n        int x = n / i;\n        if (x * i == n) return factor(x) + \" × \" + i;\n    }\n    return Integer.toString(n);\n    }\n};\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送一个文件\n &emsp;&emsp;文件很容易当作一个请求体。\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(\"README.md\");\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送form 参数\n &emsp;&emsp;使用`FormBody.Builder`来创建一个同HTML 的`form`标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(\"search\", \"Jurassic Park\")\n    .build();\nRequest request = new Request.Builder()\n    .url(\"https://en.wikipedia.org/w/index.php\")\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送multipart请求\n &emsp;&emsp;`MultipartBody.Builder`可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如`Content-Dispositon`。`Content-Type`,`Content-Length`如果可用会自动添加。\n \n```\nprivate static final String IMGUR_CLIENT_ID = \"...\";\nprivate static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Square Logo\")\n    .addFormDataPart(\"image\", \"logo-square.png\",\n        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n    .url(\"https://api.imgur.com/3/image\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n #### 使用Gson解析响应JSON\n &emsp;&emsp;[Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n &emsp;&emsp;注意，`ResponseBody.charStream()`使用`content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/gists/c2a7c39532239ff261be\")\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap<String, GistFile> files;\n}\n\nstatic class GistFile {\nString content;\n}\n```\n\n #### 响应缓存\n &emsp;&emsp;为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。  \n &emsp;&emsp;同时访问一个缓冲目录回出现错误。大多数应用应该调用一次`new OkHttpClient()`，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n &emsp;&emsp;响应缓存使用HTTP的header来配置。如果请求头添加了`Cache-Control: max-stale=3600`,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如`Cache-Control: max-age=9600`。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n \n```\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10 * 1024 * 1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(\"Response 1 response:          \" + response1);\nSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\nSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(\"Response 2 response:          \" + response2);\nSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\nSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\n\nSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\n}\n```\n\n &emsp;&emsp;为了阻止缓冲可以使用`[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)`.为了阻止网络连接可以使用`[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)`。警告：如果使用了`FORCE_CACHE`并且响应需要网络，将会返回`504 Unsatisfiable Request`。\n #### 取消请求\n &emsp;&emsp;使用`Call.cancel()`立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n \n```\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(\"%.2f Call failed as expected: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n```\n\n #### 超时\n &emsp;&emsp;当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n \n```\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(\"Response completed: \" + response);\n}\n ```\n\n #### 调用前配置\n &emsp;&emsp;所有的HTTP调用配置都会在`OkHttpClient`中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用`OKHttpClient.newBuilder()`。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n ```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 1 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 1 failed: \" + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 2 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 2 failed: \" + e);\n}\n}\n ```\n\n #### 处理认证\n &emsp;&emsp;OKHttp会自动重试认证请求。当响应是`401 Not Authorized`,`Authenticator`需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n &emsp;&emsp;使用` Response.challenges()`来获取任何认证口令的方案和域。当使用`Basic`认证的时候使用`Credentials.basic(username,password)`来编码一个header。\n \n```\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(\"Authenticating for response: \" + response);\n        System.out.println(\"Challenges: \" + response.challenges());\n        String credential = Credentials.basic(\"jesse\", \"password1\");\n        return response.request().newBuilder()\n            .header(\"Authorization\", credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/secrets/hellosecret.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n","source":"_posts/okhttp/Recipes.md","raw":"title: OKHttp Recipes\ndate: 2017-03-18 19:44:10\ntags:\n    - Java\n    - Translate\n    - OKHttp\n    - HTTP\n---\n\n[原文地址](https://github.com/square/okhttp/wiki/Recipes)\n&emsp;&emsp;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n#### 同步GET\n&emsp;&emsp;下载文件，打印header，打印body。\n&emsp;&emsp;`string()`方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用`string()`方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n```\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i < responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n    \n```\n\n #### 异步GET\n &emsp;&emsp;在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    Headers responseHeaders = response.headers();\n    for (int i = 0, size = responseHeaders.size(); i < size; i++) {\n        System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n    }\n\n    System.out.println(response.body().string());\n    }\n});\n}\n```\n\n #### 访问Header\n &emsp;&emsp;总体上说Header有点像`Map<String,String>`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。\n 例如HTTP提供多个Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n &emsp;&emsp;当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。\n &emsp;&emsp;当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。\n &emsp;&emsp;如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/repos/square/okhttp/issues\")\n    .header(\"User-Agent\", \"OkHttp Headers.java\")\n    .addHeader(\"Accept\", \"application/json; q=0.5\")\n    .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(\"Server: \" + response.header(\"Server\"));\nSystem.out.println(\"Date: \" + response.header(\"Date\"));\nSystem.out.println(\"Vary: \" + response.headers(\"Vary\"));\n}\n```\n\n #### 使用POST发送String请求。\n &emsp;&emsp;使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = \"\"\n    + \"Releases\\n\"\n    + \"--------\\n\"\n    + \"\\n\"\n    + \" * _1.0_ May 6, 2013\\n\"\n    + \" * _1.1_ June 15, 2013\\n\"\n    + \" * _1.2_ August 11, 2013\\n\";\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送流\n &emsp;&emsp;使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了`[Okio](https://github.com/square/okio)`的缓冲库。可能你更熟悉`OutputStream`可以通过`BufferedSink.outputStream`获取。\n\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIA_TYPE_MARKDOWN;\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n    sink.writeUtf8(\"Numbers\\n\");\n    sink.writeUtf8(\"-------\\n\");\n    for (int i = 2; i <= 997; i++) {\n        sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n    }\n    }\n\n    private String factor(int n) {\n    for (int i = 2; i < n; i++) {\n        int x = n / i;\n        if (x * i == n) return factor(x) + \" × \" + i;\n    }\n    return Integer.toString(n);\n    }\n};\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送一个文件\n &emsp;&emsp;文件很容易当作一个请求体。\n\n```\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(\"README.md\");\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送form 参数\n &emsp;&emsp;使用`FormBody.Builder`来创建一个同HTML 的`form`标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(\"search\", \"Jurassic Park\")\n    .build();\nRequest request = new Request.Builder()\n    .url(\"https://en.wikipedia.org/w/index.php\")\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送multipart请求\n &emsp;&emsp;`MultipartBody.Builder`可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如`Content-Dispositon`。`Content-Type`,`Content-Length`如果可用会自动添加。\n \n```\nprivate static final String IMGUR_CLIENT_ID = \"...\";\nprivate static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Square Logo\")\n    .addFormDataPart(\"image\", \"logo-square.png\",\n        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n    .url(\"https://api.imgur.com/3/image\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n #### 使用Gson解析响应JSON\n &emsp;&emsp;[Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n &emsp;&emsp;注意，`ResponseBody.charStream()`使用`content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n```\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/gists/c2a7c39532239ff261be\")\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap<String, GistFile> files;\n}\n\nstatic class GistFile {\nString content;\n}\n```\n\n #### 响应缓存\n &emsp;&emsp;为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。  \n &emsp;&emsp;同时访问一个缓冲目录回出现错误。大多数应用应该调用一次`new OkHttpClient()`，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n &emsp;&emsp;响应缓存使用HTTP的header来配置。如果请求头添加了`Cache-Control: max-stale=3600`,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如`Cache-Control: max-age=9600`。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n \n```\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10 * 1024 * 1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(\"Response 1 response:          \" + response1);\nSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\nSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(\"Response 2 response:          \" + response2);\nSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\nSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\n\nSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\n}\n```\n\n &emsp;&emsp;为了阻止缓冲可以使用`[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)`.为了阻止网络连接可以使用`[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)`。警告：如果使用了`FORCE_CACHE`并且响应需要网络，将会返回`504 Unsatisfiable Request`。\n #### 取消请求\n &emsp;&emsp;使用`Call.cancel()`立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n \n```\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(\"%.2f Call failed as expected: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n```\n\n #### 超时\n &emsp;&emsp;当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n \n```\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(\"Response completed: \" + response);\n}\n ```\n\n #### 调用前配置\n &emsp;&emsp;所有的HTTP调用配置都会在`OkHttpClient`中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用`OKHttpClient.newBuilder()`。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n ```\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 1 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 1 failed: \" + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 2 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 2 failed: \" + e);\n}\n}\n ```\n\n #### 处理认证\n &emsp;&emsp;OKHttp会自动重试认证请求。当响应是`401 Not Authorized`,`Authenticator`需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n &emsp;&emsp;使用` Response.challenges()`来获取任何认证口令的方案和域。当使用`Basic`认证的时候使用`Credentials.basic(username,password)`来编码一个header。\n \n```\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(\"Authenticating for response: \" + response);\n        System.out.println(\"Challenges: \" + response.challenges());\n        String credential = Credentials.basic(\"jesse\", \"password1\");\n        return response.request().newBuilder()\n            .header(\"Authorization\", credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/secrets/hellosecret.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n","slug":"okhttp/Recipes","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds7w0027martptqy36jf","content":"<p><a href=\"https://github.com/square/okhttp/wiki/Recipes\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。</p>\n<h4 id=\"同步GET\"><a href=\"#同步GET\" class=\"headerlink\" title=\"同步GET\"></a>同步GET</h4><p>&emsp;&emsp;下载文件，打印header，打印body。<br>&emsp;&emsp;<code>string()</code>方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用<code>string()</code>方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">Headers responseHeaders = response.headers();</span><br><span class=\"line\">for (int i = 0; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class=\"line\">System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(response.body().string());</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步GET\"><a href=\"#异步GET\" class=\"headerlink\" title=\"异步GET\"></a>异步GET</h4><p> &emsp;&emsp;在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">client.newCall(request).enqueue(new Callback() &#123;</span><br><span class=\"line\">    @Override public void onFailure(Call call, IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class=\"line\">    if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">    Headers responseHeaders = response.headers();</span><br><span class=\"line\">    for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(response.body().string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问Header\"><a href=\"#访问Header\" class=\"headerlink\" title=\"访问Header\"></a>访问Header</h4><p> &emsp;&emsp;总体上说Header有点像<code>Map&lt;String,String&gt;</code>，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的<code>[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)</code>。<br> 例如HTTP提供多个Vary<code>的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n &amp;emsp;&amp;emsp;当写入请求header的时候使用</code>header(name,value)<code>设置仅有一个的</code>name<code>和</code>value<code>。如果有存在的值，会先移除值再添加。 使用</code>addHeader(name,value)<code>添加header不会移除已经存在的header。\n &amp;emsp;&amp;emsp;当读响应header的时候，</code>header(name)<code>只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用</code>headers(name)`。<br> &emsp;&emsp;如果要访问所有的header，可以使用Headers类，支持坐标访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)</span><br><span class=\"line\">    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)</span><br><span class=\"line\">    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));</span><br><span class=\"line\">System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));</span><br><span class=\"line\">System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送String请求。\"><a href=\"#使用POST发送String请求。\" class=\"headerlink\" title=\"使用POST发送String请求。\"></a>使用POST发送String请求。</h4><p> &emsp;&emsp;使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">String postBody = &quot;&quot;</span><br><span class=\"line\">    + &quot;Releases\\n&quot;</span><br><span class=\"line\">    + &quot;--------\\n&quot;</span><br><span class=\"line\">    + &quot;\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.0_ May 6, 2013\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.1_ June 15, 2013\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.2_ August 11, 2013\\n&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送流\"><a href=\"#使用POST发送流\" class=\"headerlink\" title=\"使用POST发送流\"></a>使用POST发送流</h4><p> &emsp;&emsp;使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了<code>[Okio](https://github.com/square/okio)</code>的缓冲库。可能你更熟悉<code>OutputStream</code>可以通过<code>BufferedSink.outputStream</code>获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">RequestBody requestBody = new RequestBody() &#123;</span><br><span class=\"line\">    @Override public MediaType contentType() &#123;</span><br><span class=\"line\">    return MEDIA_TYPE_MARKDOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class=\"line\">    sink.writeUtf8(&quot;Numbers\\n&quot;);</span><br><span class=\"line\">    sink.writeUtf8(&quot;-------\\n&quot;);</span><br><span class=\"line\">    for (int i = 2; i &lt;= 997; i++) &#123;</span><br><span class=\"line\">        sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String factor(int n) &#123;</span><br><span class=\"line\">    for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">        int x = n / i;</span><br><span class=\"line\">        if (x * i == n) return factor(x) + &quot; × &quot; + i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Integer.toString(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(requestBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送一个文件\"><a href=\"#使用POST发送一个文件\" class=\"headerlink\" title=\"使用POST发送一个文件\"></a>使用POST发送一个文件</h4><p> &emsp;&emsp;文件很容易当作一个请求体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">File file = new File(&quot;README.md&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送form-参数\"><a href=\"#发送form-参数\" class=\"headerlink\" title=\"发送form 参数\"></a>发送form 参数</h4><p> &emsp;&emsp;使用<code>FormBody.Builder</code>来创建一个同HTML 的<code>form</code>标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">RequestBody formBody = new FormBody.Builder()</span><br><span class=\"line\">    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)</span><br><span class=\"line\">    .post(formBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送multipart请求\"><a href=\"#发送multipart请求\" class=\"headerlink\" title=\"发送multipart请求\"></a>发送multipart请求</h4><p> &emsp;&emsp;<code>MultipartBody.Builder</code>可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如<code>Content-Dispositon</code>。<code>Content-Type</code>,<code>Content-Length</code>如果可用会自动添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final String IMGUR_CLIENT_ID = &quot;...&quot;;</span><br><span class=\"line\">private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span><br><span class=\"line\">RequestBody requestBody = new MultipartBody.Builder()</span><br><span class=\"line\">    .setType(MultipartBody.FORM)</span><br><span class=\"line\">    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)</span><br><span class=\"line\">    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,</span><br><span class=\"line\">        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)</span><br><span class=\"line\">    .url(&quot;https://api.imgur.com/3/image&quot;)</span><br><span class=\"line\">    .post(requestBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Gson解析响应JSON\"><a href=\"#使用Gson解析响应JSON\" class=\"headerlink\" title=\"使用Gson解析响应JSON\"></a>使用Gson解析响应JSON</h4><p> &emsp;&emsp;<a href=\"http://code.google.com/p/google-gson/\" target=\"_blank\" rel=\"noopener\">Gson</a>是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。<br> &emsp;&emsp;注意，<code>ResponseBody.charStream()</code>使用<code>content-type</code>的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\">private final Gson gson = new Gson();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</span><br><span class=\"line\">for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue().content);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class Gist &#123;</span><br><span class=\"line\">Map&lt;String, GistFile&gt; files;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class GistFile &#123;</span><br><span class=\"line\">String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"响应缓存\"><a href=\"#响应缓存\" class=\"headerlink\" title=\"响应缓存\"></a>响应缓存</h4><p> &emsp;&emsp;为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。<br> &emsp;&emsp;同时访问一个缓冲目录回出现错误。大多数应用应该调用一次<code>new OkHttpClient()</code>，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。<br> &emsp;&emsp;响应缓存使用HTTP的header来配置。如果请求头添加了<code>Cache-Control: max-stale=3600</code>,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如<code>Cache-Control: max-age=9600</code>。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class=\"line\">int cacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class=\"line\">Cache cache = new Cache(cacheDirectory, cacheSize);</span><br><span class=\"line\"></span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .cache(cache)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response1 = client.newCall(request).execute();</span><br><span class=\"line\">if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);</span><br><span class=\"line\"></span><br><span class=\"line\">String response1Body = response1.body().string();</span><br><span class=\"line\">System.out.println(&quot;Response 1 response:          &quot; + response1);</span><br><span class=\"line\">System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());</span><br><span class=\"line\">System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());</span><br><span class=\"line\"></span><br><span class=\"line\">Response response2 = client.newCall(request).execute();</span><br><span class=\"line\">if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);</span><br><span class=\"line\"></span><br><span class=\"line\">String response2Body = response2.body().string();</span><br><span class=\"line\">System.out.println(&quot;Response 2 response:          &quot; + response2);</span><br><span class=\"line\">System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());</span><br><span class=\"line\">System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;为了阻止缓冲可以使用<code>[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)</code>.为了阻止网络连接可以使用<code>[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)</code>。警告：如果使用了<code>FORCE_CACHE</code>并且响应需要网络，将会返回<code>504 Unsatisfiable Request</code>。</p>\n<h4 id=\"取消请求\"><a href=\"#取消请求\" class=\"headerlink\" title=\"取消请求\"></a>取消请求</h4><p> &emsp;&emsp;使用<code>Call.cancel()</code>立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">final long startNanos = System.nanoTime();</span><br><span class=\"line\">final Call call = client.newCall(request);</span><br><span class=\"line\"></span><br><span class=\"line\">// Schedule a job to cancel the call in 1 second.</span><br><span class=\"line\">executor.schedule(new Runnable() &#123;</span><br><span class=\"line\">    @Override public void run() &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    call.cancel();</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, 1, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    Response response = call.execute();</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,</span><br><span class=\"line\">        (System.nanoTime() - startNanos) / 1e9f, response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,</span><br><span class=\"line\">        (System.nanoTime() - startNanos) / 1e9f, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h4><p> &emsp;&emsp;当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public ConfigureTimeouts() throws Exception &#123;</span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(10, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">System.out.println(&quot;Response completed: &quot; + response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用前配置\"><a href=\"#调用前配置\" class=\"headerlink\" title=\"调用前配置\"></a>调用前配置</h4><p> &emsp;&emsp;所有的HTTP调用配置都会在<code>OkHttpClient</code>中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用<code>OKHttpClient.newBuilder()</code>。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    // Copy to customize OkHttp for this request.</span><br><span class=\"line\">    OkHttpClient copy = client.newBuilder()</span><br><span class=\"line\">        .readTimeout(500, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = copy.newCall(request).execute();</span><br><span class=\"line\">    System.out.println(&quot;Response 1 succeeded: &quot; + response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Response 1 failed: &quot; + e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    // Copy to customize OkHttp for this request.</span><br><span class=\"line\">    OkHttpClient copy = client.newBuilder()</span><br><span class=\"line\">        .readTimeout(3000, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = copy.newCall(request).execute();</span><br><span class=\"line\">    System.out.println(&quot;Response 2 succeeded: &quot; + response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Response 2 failed: &quot; + e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"处理认证\"><a href=\"#处理认证\" class=\"headerlink\" title=\"处理认证\"></a>处理认证</h4><p> &emsp;&emsp;OKHttp会自动重试认证请求。当响应是<code>401 Not Authorized</code>,<code>Authenticator</code>需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。<br> &emsp;&emsp;使用<code>Response.challenges()</code>来获取任何认证口令的方案和域。当使用<code>Basic</code>认证的时候使用<code>Credentials.basic(username,password)</code>来编码一个header。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public Authenticate() &#123;</span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .authenticator(new Authenticator() &#123;</span><br><span class=\"line\">        @Override public Request authenticate(Route route, Response response) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;Authenticating for response: &quot; + response);</span><br><span class=\"line\">        System.out.println(&quot;Challenges: &quot; + response.challenges());</span><br><span class=\"line\">        String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);</span><br><span class=\"line\">        return response.request().newBuilder()</span><br><span class=\"line\">            .header(&quot;Authorization&quot;, credential)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/square/okhttp/wiki/Recipes\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。</p>\n<h4 id=\"同步GET\"><a href=\"#同步GET\" class=\"headerlink\" title=\"同步GET\"></a>同步GET</h4><p>&emsp;&emsp;下载文件，打印header，打印body。<br>&emsp;&emsp;<code>string()</code>方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用<code>string()</code>方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">Headers responseHeaders = response.headers();</span><br><span class=\"line\">for (int i = 0; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class=\"line\">System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(response.body().string());</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步GET\"><a href=\"#异步GET\" class=\"headerlink\" title=\"异步GET\"></a>异步GET</h4><p> &emsp;&emsp;在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">client.newCall(request).enqueue(new Callback() &#123;</span><br><span class=\"line\">    @Override public void onFailure(Call call, IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class=\"line\">    if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">    Headers responseHeaders = response.headers();</span><br><span class=\"line\">    for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">        System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(response.body().string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问Header\"><a href=\"#访问Header\" class=\"headerlink\" title=\"访问Header\"></a>访问Header</h4><p> &emsp;&emsp;总体上说Header有点像<code>Map&lt;String,String&gt;</code>，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的<code>[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)</code>。<br> 例如HTTP提供多个Vary<code>的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n &amp;emsp;&amp;emsp;当写入请求header的时候使用</code>header(name,value)<code>设置仅有一个的</code>name<code>和</code>value<code>。如果有存在的值，会先移除值再添加。 使用</code>addHeader(name,value)<code>添加header不会移除已经存在的header。\n &amp;emsp;&amp;emsp;当读响应header的时候，</code>header(name)<code>只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用</code>headers(name)`。<br> &emsp;&emsp;如果要访问所有的header，可以使用Headers类，支持坐标访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)</span><br><span class=\"line\">    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)</span><br><span class=\"line\">    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));</span><br><span class=\"line\">System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));</span><br><span class=\"line\">System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送String请求。\"><a href=\"#使用POST发送String请求。\" class=\"headerlink\" title=\"使用POST发送String请求。\"></a>使用POST发送String请求。</h4><p> &emsp;&emsp;使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">String postBody = &quot;&quot;</span><br><span class=\"line\">    + &quot;Releases\\n&quot;</span><br><span class=\"line\">    + &quot;--------\\n&quot;</span><br><span class=\"line\">    + &quot;\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.0_ May 6, 2013\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.1_ June 15, 2013\\n&quot;</span><br><span class=\"line\">    + &quot; * _1.2_ August 11, 2013\\n&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送流\"><a href=\"#使用POST发送流\" class=\"headerlink\" title=\"使用POST发送流\"></a>使用POST发送流</h4><p> &emsp;&emsp;使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了<code>[Okio](https://github.com/square/okio)</code>的缓冲库。可能你更熟悉<code>OutputStream</code>可以通过<code>BufferedSink.outputStream</code>获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">RequestBody requestBody = new RequestBody() &#123;</span><br><span class=\"line\">    @Override public MediaType contentType() &#123;</span><br><span class=\"line\">    return MEDIA_TYPE_MARKDOWN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class=\"line\">    sink.writeUtf8(&quot;Numbers\\n&quot;);</span><br><span class=\"line\">    sink.writeUtf8(&quot;-------\\n&quot;);</span><br><span class=\"line\">    for (int i = 2; i &lt;= 997; i++) &#123;</span><br><span class=\"line\">        sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String factor(int n) &#123;</span><br><span class=\"line\">    for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">        int x = n / i;</span><br><span class=\"line\">        if (x * i == n) return factor(x) + &quot; × &quot; + i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Integer.toString(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(requestBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用POST发送一个文件\"><a href=\"#使用POST发送一个文件\" class=\"headerlink\" title=\"使用POST发送一个文件\"></a>使用POST发送一个文件</h4><p> &emsp;&emsp;文件很容易当作一个请求体。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final MediaType MEDIA_TYPE_MARKDOWN</span><br><span class=\"line\">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">File file = new File(&quot;README.md&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/markdown/raw&quot;)</span><br><span class=\"line\">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送form-参数\"><a href=\"#发送form-参数\" class=\"headerlink\" title=\"发送form 参数\"></a>发送form 参数</h4><p> &emsp;&emsp;使用<code>FormBody.Builder</code>来创建一个同HTML 的<code>form</code>标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">RequestBody formBody = new FormBody.Builder()</span><br><span class=\"line\">    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)</span><br><span class=\"line\">    .post(formBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送multipart请求\"><a href=\"#发送multipart请求\" class=\"headerlink\" title=\"发送multipart请求\"></a>发送multipart请求</h4><p> &emsp;&emsp;<code>MultipartBody.Builder</code>可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如<code>Content-Dispositon</code>。<code>Content-Type</code>,<code>Content-Length</code>如果可用会自动添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final String IMGUR_CLIENT_ID = &quot;...&quot;;</span><br><span class=\"line\">private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span><br><span class=\"line\">RequestBody requestBody = new MultipartBody.Builder()</span><br><span class=\"line\">    .setType(MultipartBody.FORM)</span><br><span class=\"line\">    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)</span><br><span class=\"line\">    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,</span><br><span class=\"line\">        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)</span><br><span class=\"line\">    .url(&quot;https://api.imgur.com/3/image&quot;)</span><br><span class=\"line\">    .post(requestBody)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用Gson解析响应JSON\"><a href=\"#使用Gson解析响应JSON\" class=\"headerlink\" title=\"使用Gson解析响应JSON\"></a>使用Gson解析响应JSON</h4><p> &emsp;&emsp;<a href=\"http://code.google.com/p/google-gson/\" target=\"_blank\" rel=\"noopener\">Gson</a>是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。<br> &emsp;&emsp;注意，<code>ResponseBody.charStream()</code>使用<code>content-type</code>的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\">private final Gson gson = new Gson();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</span><br><span class=\"line\">for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey());</span><br><span class=\"line\">    System.out.println(entry.getValue().content);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class Gist &#123;</span><br><span class=\"line\">Map&lt;String, GistFile&gt; files;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class GistFile &#123;</span><br><span class=\"line\">String content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"响应缓存\"><a href=\"#响应缓存\" class=\"headerlink\" title=\"响应缓存\"></a>响应缓存</h4><p> &emsp;&emsp;为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。<br> &emsp;&emsp;同时访问一个缓冲目录回出现错误。大多数应用应该调用一次<code>new OkHttpClient()</code>，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。<br> &emsp;&emsp;响应缓存使用HTTP的header来配置。如果请求头添加了<code>Cache-Control: max-stale=3600</code>,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如<code>Cache-Control: max-age=9600</code>。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class=\"line\">int cacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class=\"line\">Cache cache = new Cache(cacheDirectory, cacheSize);</span><br><span class=\"line\"></span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .cache(cache)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response1 = client.newCall(request).execute();</span><br><span class=\"line\">if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);</span><br><span class=\"line\"></span><br><span class=\"line\">String response1Body = response1.body().string();</span><br><span class=\"line\">System.out.println(&quot;Response 1 response:          &quot; + response1);</span><br><span class=\"line\">System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());</span><br><span class=\"line\">System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());</span><br><span class=\"line\"></span><br><span class=\"line\">Response response2 = client.newCall(request).execute();</span><br><span class=\"line\">if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);</span><br><span class=\"line\"></span><br><span class=\"line\">String response2Body = response2.body().string();</span><br><span class=\"line\">System.out.println(&quot;Response 2 response:          &quot; + response2);</span><br><span class=\"line\">System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());</span><br><span class=\"line\">System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> &emsp;&emsp;为了阻止缓冲可以使用<code>[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)</code>.为了阻止网络连接可以使用<code>[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)</code>。警告：如果使用了<code>FORCE_CACHE</code>并且响应需要网络，将会返回<code>504 Unsatisfiable Request</code>。</p>\n<h4 id=\"取消请求\"><a href=\"#取消请求\" class=\"headerlink\" title=\"取消请求\"></a>取消请求</h4><p> &emsp;&emsp;使用<code>Call.cancel()</code>立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">final long startNanos = System.nanoTime();</span><br><span class=\"line\">final Call call = client.newCall(request);</span><br><span class=\"line\"></span><br><span class=\"line\">// Schedule a job to cancel the call in 1 second.</span><br><span class=\"line\">executor.schedule(new Runnable() &#123;</span><br><span class=\"line\">    @Override public void run() &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    call.cancel();</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, 1, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</span><br><span class=\"line\">    Response response = call.execute();</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,</span><br><span class=\"line\">        (System.nanoTime() - startNanos) / 1e9f, response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,</span><br><span class=\"line\">        (System.nanoTime() - startNanos) / 1e9f, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h4><p> &emsp;&emsp;当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public ConfigureTimeouts() throws Exception &#123;</span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(10, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(30, TimeUnit.SECONDS)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">System.out.println(&quot;Response completed: &quot; + response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用前配置\"><a href=\"#调用前配置\" class=\"headerlink\" title=\"调用前配置\"></a>调用前配置</h4><p> &emsp;&emsp;所有的HTTP调用配置都会在<code>OkHttpClient</code>中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用<code>OKHttpClient.newBuilder()</code>。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client = new OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    // Copy to customize OkHttp for this request.</span><br><span class=\"line\">    OkHttpClient copy = client.newBuilder()</span><br><span class=\"line\">        .readTimeout(500, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = copy.newCall(request).execute();</span><br><span class=\"line\">    System.out.println(&quot;Response 1 succeeded: &quot; + response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Response 1 failed: &quot; + e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    // Copy to customize OkHttp for this request.</span><br><span class=\"line\">    OkHttpClient copy = client.newBuilder()</span><br><span class=\"line\">        .readTimeout(3000, TimeUnit.MILLISECONDS)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = copy.newCall(request).execute();</span><br><span class=\"line\">    System.out.println(&quot;Response 2 succeeded: &quot; + response);</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    System.out.println(&quot;Response 2 failed: &quot; + e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"处理认证\"><a href=\"#处理认证\" class=\"headerlink\" title=\"处理认证\"></a>处理认证</h4><p> &emsp;&emsp;OKHttp会自动重试认证请求。当响应是<code>401 Not Authorized</code>,<code>Authenticator</code>需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。<br> &emsp;&emsp;使用<code>Response.challenges()</code>来获取任何认证口令的方案和域。当使用<code>Basic</code>认证的时候使用<code>Credentials.basic(username,password)</code>来编码一个header。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public Authenticate() &#123;</span><br><span class=\"line\">client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .authenticator(new Authenticator() &#123;</span><br><span class=\"line\">        @Override public Request authenticate(Route route, Response response) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;Authenticating for response: &quot; + response);</span><br><span class=\"line\">        System.out.println(&quot;Challenges: &quot; + response.challenges());</span><br><span class=\"line\">        String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);</span><br><span class=\"line\">        return response.request().newBuilder()</span><br><span class=\"line\">            .header(&quot;Authorization&quot;, credential)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"OKHttp的调用","date":"2017-03-18T07:10:03.000Z","_content":"\n[原文地址](https://github.com/square/okhttp/wiki/Calls)\n\n&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。\n#### Requests\n&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。\n#### Responses\n&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。\n##### 重写请求\n&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。\n&emsp;&emsp;OkHttp将会添加原请求没有的header，包括`Content-length`,`Transfer-Encoding`,`User-Agent`,`Host`,`Connection`，`Content-Type`。除非已经提供了，否则OKHttp回会添加 `Acceept-Encoding`来压缩响应。如果有Cookie，也会添加`Cookie`。\n&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求`If-Modified-Since`和`If-None-Match`添加到headers中。\n##### 重写响应\n&emsp;&emsp;如果透明压缩启用了，OKHttp将会把`Content-Encoding`和`Content-Length`从headers中移除，因为他们不是用来解压缩的。\n&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。\n##### 后续请求\n&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。\n&emsp;&emsp;如果响应需要认证，OKHttp将会使用`Authenticator`（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。\n##### 重试请求\n&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。\n#### calls\n&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用`call`建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。\n&emsp;&emsp;call有两种工作方\n   * 同步：线程将会阻塞道到响应可读。\n   * 异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。\n&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。\n##### 调度\n&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。\n&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。","source":"_posts/okhttp/calls.md","raw":"title: OKHttp的调用\ndate: 2017-03-18 15:10:03\ntags:\n    - Translate\n    - Java\n    - OKHttp\n    - HTTP\n---\n\n[原文地址](https://github.com/square/okhttp/wiki/Calls)\n\n&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。\n#### Requests\n&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。\n#### Responses\n&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。\n##### 重写请求\n&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。\n&emsp;&emsp;OkHttp将会添加原请求没有的header，包括`Content-length`,`Transfer-Encoding`,`User-Agent`,`Host`,`Connection`，`Content-Type`。除非已经提供了，否则OKHttp回会添加 `Acceept-Encoding`来压缩响应。如果有Cookie，也会添加`Cookie`。\n&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求`If-Modified-Since`和`If-None-Match`添加到headers中。\n##### 重写响应\n&emsp;&emsp;如果透明压缩启用了，OKHttp将会把`Content-Encoding`和`Content-Length`从headers中移除，因为他们不是用来解压缩的。\n&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。\n##### 后续请求\n&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。\n&emsp;&emsp;如果响应需要认证，OKHttp将会使用`Authenticator`（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。\n##### 重试请求\n&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。\n#### calls\n&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用`call`建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。\n&emsp;&emsp;call有两种工作方\n   * 同步：线程将会阻塞道到响应可读。\n   * 异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。\n&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。\n##### 调度\n&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。\n&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。","slug":"okhttp/calls","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds810029mart3qsqwrox","content":"<p><a href=\"https://github.com/square/okhttp/wiki/Calls\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。</p>\n<h4 id=\"Requests\"><a href=\"#Requests\" class=\"headerlink\" title=\"Requests\"></a>Requests</h4><p>&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。</p>\n<h4 id=\"Responses\"><a href=\"#Responses\" class=\"headerlink\" title=\"Responses\"></a>Responses</h4><p>&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。</p>\n<h5 id=\"重写请求\"><a href=\"#重写请求\" class=\"headerlink\" title=\"重写请求\"></a>重写请求</h5><p>&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。<br>&emsp;&emsp;OkHttp将会添加原请求没有的header，包括<code>Content-length</code>,<code>Transfer-Encoding</code>,<code>User-Agent</code>,<code>Host</code>,<code>Connection</code>，<code>Content-Type</code>。除非已经提供了，否则OKHttp回会添加 <code>Acceept-Encoding</code>来压缩响应。如果有Cookie，也会添加<code>Cookie</code>。<br>&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求<code>If-Modified-Since</code>和<code>If-None-Match</code>添加到headers中。</p>\n<h5 id=\"重写响应\"><a href=\"#重写响应\" class=\"headerlink\" title=\"重写响应\"></a>重写响应</h5><p>&emsp;&emsp;如果透明压缩启用了，OKHttp将会把<code>Content-Encoding</code>和<code>Content-Length</code>从headers中移除，因为他们不是用来解压缩的。<br>&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。</p>\n<h5 id=\"后续请求\"><a href=\"#后续请求\" class=\"headerlink\" title=\"后续请求\"></a>后续请求</h5><p>&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。<br>&emsp;&emsp;如果响应需要认证，OKHttp将会使用<code>Authenticator</code>（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。</p>\n<h5 id=\"重试请求\"><a href=\"#重试请求\" class=\"headerlink\" title=\"重试请求\"></a>重试请求</h5><p>&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。</p>\n<h4 id=\"calls\"><a href=\"#calls\" class=\"headerlink\" title=\"calls\"></a>calls</h4><p>&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用<code>call</code>建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。<br>&emsp;&emsp;call有两种工作方</p>\n<ul>\n<li>同步：线程将会阻塞道到响应可读。</li>\n<li>异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。<br>&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。<h5 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h5>&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。<br>&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/square/okhttp/wiki/Calls\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。</p>\n<h4 id=\"Requests\"><a href=\"#Requests\" class=\"headerlink\" title=\"Requests\"></a>Requests</h4><p>&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。</p>\n<h4 id=\"Responses\"><a href=\"#Responses\" class=\"headerlink\" title=\"Responses\"></a>Responses</h4><p>&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。</p>\n<h5 id=\"重写请求\"><a href=\"#重写请求\" class=\"headerlink\" title=\"重写请求\"></a>重写请求</h5><p>&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。<br>&emsp;&emsp;OkHttp将会添加原请求没有的header，包括<code>Content-length</code>,<code>Transfer-Encoding</code>,<code>User-Agent</code>,<code>Host</code>,<code>Connection</code>，<code>Content-Type</code>。除非已经提供了，否则OKHttp回会添加 <code>Acceept-Encoding</code>来压缩响应。如果有Cookie，也会添加<code>Cookie</code>。<br>&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求<code>If-Modified-Since</code>和<code>If-None-Match</code>添加到headers中。</p>\n<h5 id=\"重写响应\"><a href=\"#重写响应\" class=\"headerlink\" title=\"重写响应\"></a>重写响应</h5><p>&emsp;&emsp;如果透明压缩启用了，OKHttp将会把<code>Content-Encoding</code>和<code>Content-Length</code>从headers中移除，因为他们不是用来解压缩的。<br>&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。</p>\n<h5 id=\"后续请求\"><a href=\"#后续请求\" class=\"headerlink\" title=\"后续请求\"></a>后续请求</h5><p>&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。<br>&emsp;&emsp;如果响应需要认证，OKHttp将会使用<code>Authenticator</code>（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。</p>\n<h5 id=\"重试请求\"><a href=\"#重试请求\" class=\"headerlink\" title=\"重试请求\"></a>重试请求</h5><p>&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。</p>\n<h4 id=\"calls\"><a href=\"#calls\" class=\"headerlink\" title=\"calls\"></a>calls</h4><p>&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用<code>call</code>建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。<br>&emsp;&emsp;call有两种工作方</p>\n<ul>\n<li>同步：线程将会阻塞道到响应可读。</li>\n<li>异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。<br>&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。<h5 id=\"调度\"><a href=\"#调度\" class=\"headerlink\" title=\"调度\"></a>调度</h5>&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。<br>&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。</li>\n</ul>\n"},{"title":"OKHttp connections","date":"2017-03-18T11:05:48.000Z","_content":"\n[原文地址](https://github.com/square/okhttp/wiki/Connections)\n&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。\n\n#### URLS\n&emsp;&emsp;URLs例如（https://github.com/square/okhttp) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。\nURLs是抽象的：\n  * 它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书([HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html))，或者是哪个证书可信([SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html))\n  * 它为指定是否需要使用代理服务器以及代理服务器如何授权。\n &emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&lang=en)。每个服务器有很多URL。\n\n #### Addresses\n &emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。\n &emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（[TCP 慢启动](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/))，低电量。OKHttp使用[ConnectionPool](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html)自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。\n &emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自[OKHttpClient](http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html)。\n #### Routes\n &emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（[ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html)），协n哪个TLS版本（HTTPS).\n &emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。\n #### Connections\n &emsp;&emsp;当发起一个URL的请求的时候：\n   1. 使用URL和OKHttpCLient确定具体的**Address**。这个地址明确如何连接服务器。\n   2. 尝试从**连接池**中查找具体Address的连接。\n   3. 如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。\n   4. 如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。\n   5. 发送请求，接受响应。\n &emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。\n &emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。\n\n","source":"_posts/okhttp/connections.md","raw":"title: OKHttp connections\ndate: 2017-03-18 19:05:48\ntags:\n    - OKHttp\n    - Translate\n    - Java\n    - HTTP\n---\n\n[原文地址](https://github.com/square/okhttp/wiki/Connections)\n&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。\n\n#### URLS\n&emsp;&emsp;URLs例如（https://github.com/square/okhttp) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。\nURLs是抽象的：\n  * 它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书([HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html))，或者是哪个证书可信([SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html))\n  * 它为指定是否需要使用代理服务器以及代理服务器如何授权。\n &emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&lang=en)。每个服务器有很多URL。\n\n #### Addresses\n &emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。\n &emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（[TCP 慢启动](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/))，低电量。OKHttp使用[ConnectionPool](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html)自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。\n &emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自[OKHttpClient](http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html)。\n #### Routes\n &emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（[ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html)），协n哪个TLS版本（HTTPS).\n &emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。\n #### Connections\n &emsp;&emsp;当发起一个URL的请求的时候：\n   1. 使用URL和OKHttpCLient确定具体的**Address**。这个地址明确如何连接服务器。\n   2. 尝试从**连接池**中查找具体Address的连接。\n   3. 如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。\n   4. 如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。\n   5. 发送请求，接受响应。\n &emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。\n &emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。\n\n","slug":"okhttp/connections","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds85002cmartb3h6zkw4","content":"<p><a href=\"https://github.com/square/okhttp/wiki/Connections\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。</p>\n<h4 id=\"URLS\"><a href=\"#URLS\" class=\"headerlink\" title=\"URLS\"></a>URLS</h4><p>&emsp;&emsp;URLs例如（<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"noopener\">https://github.com/square/okhttp</a>) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。<br>URLs是抽象的：</p>\n<ul>\n<li>它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书(<a href=\"http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html\" target=\"_blank\" rel=\"noopener\">HostnameVerifier</a>)，或者是哪个证书可信(<a href=\"http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html\" target=\"_blank\" rel=\"noopener\">SSLSocketFactory</a>)</li>\n<li><p>它为指定是否需要使用代理服务器以及代理服务器如何授权。<br>&emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&amp;lang=en)。每个服务器有很多URL。</p>\n<h4 id=\"Addresses\"><a href=\"#Addresses\" class=\"headerlink\" title=\"Addresses\"></a>Addresses</h4><p>&emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。<br>&emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（<a href=\"http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/\" target=\"_blank\" rel=\"noopener\">TCP 慢启动</a>)，低电量。OKHttp使用<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html\" target=\"_blank\" rel=\"noopener\">ConnectionPool</a>自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。<br>&emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html\" target=\"_blank\" rel=\"noopener\">OKHttpClient</a>。</p>\n<h4 id=\"Routes\"><a href=\"#Routes\" class=\"headerlink\" title=\"Routes\"></a>Routes</h4><p>&emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（<a href=\"http://developer.android.com/reference/java/net/ProxySelector.html\" target=\"_blank\" rel=\"noopener\">ProxySelector</a>），协n哪个TLS版本（HTTPS).<br>&emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。</p>\n<h4 id=\"Connections\"><a href=\"#Connections\" class=\"headerlink\" title=\"Connections\"></a>Connections</h4><p>&emsp;&emsp;当发起一个URL的请求的时候：</p>\n<ol>\n<li>使用URL和OKHttpCLient确定具体的<strong>Address</strong>。这个地址明确如何连接服务器。</li>\n<li>尝试从<strong>连接池</strong>中查找具体Address的连接。</li>\n<li>如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。</li>\n<li>如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。</li>\n<li>发送请求，接受响应。<br>&emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。<br>&emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/square/okhttp/wiki/Connections\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。</p>\n<h4 id=\"URLS\"><a href=\"#URLS\" class=\"headerlink\" title=\"URLS\"></a>URLS</h4><p>&emsp;&emsp;URLs例如（<a href=\"https://github.com/square/okhttp\" target=\"_blank\" rel=\"noopener\">https://github.com/square/okhttp</a>) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。<br>URLs是抽象的：</p>\n<ul>\n<li>它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书(<a href=\"http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html\" target=\"_blank\" rel=\"noopener\">HostnameVerifier</a>)，或者是哪个证书可信(<a href=\"http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html\" target=\"_blank\" rel=\"noopener\">SSLSocketFactory</a>)</li>\n<li><p>它为指定是否需要使用代理服务器以及代理服务器如何授权。<br>&emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&amp;lang=en)。每个服务器有很多URL。</p>\n<h4 id=\"Addresses\"><a href=\"#Addresses\" class=\"headerlink\" title=\"Addresses\"></a>Addresses</h4><p>&emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。<br>&emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（<a href=\"http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/\" target=\"_blank\" rel=\"noopener\">TCP 慢启动</a>)，低电量。OKHttp使用<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html\" target=\"_blank\" rel=\"noopener\">ConnectionPool</a>自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。<br>&emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html\" target=\"_blank\" rel=\"noopener\">OKHttpClient</a>。</p>\n<h4 id=\"Routes\"><a href=\"#Routes\" class=\"headerlink\" title=\"Routes\"></a>Routes</h4><p>&emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（<a href=\"http://developer.android.com/reference/java/net/ProxySelector.html\" target=\"_blank\" rel=\"noopener\">ProxySelector</a>），协n哪个TLS版本（HTTPS).<br>&emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。</p>\n<h4 id=\"Connections\"><a href=\"#Connections\" class=\"headerlink\" title=\"Connections\"></a>Connections</h4><p>&emsp;&emsp;当发起一个URL的请求的时候：</p>\n<ol>\n<li>使用URL和OKHttpCLient确定具体的<strong>Address</strong>。这个地址明确如何连接服务器。</li>\n<li>尝试从<strong>连接池</strong>中查找具体Address的连接。</li>\n<li>如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。</li>\n<li>如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。</li>\n<li>发送请求，接受响应。<br>&emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。<br>&emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"OKHttp https","date":"2017-03-23T05:32:29.000Z","_content":"\n[原文链接](https://github.com/square/okhttp/wiki/HTTPS)\n\n&emsp;&emsp;OKHttp尝试平衡两个相互矛盾的内容：\n * 连接尽可能多的主机。包括使用[boringssl](https://boringssl.googlesource.com/boringssl/)的高级的主机和一些使用[openssl](https://www.openssl.org/)的过时的主机。\n * 连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。\n\n&emsp;&emsp;协商连接到HTTPS的时候，OKHttp需要知道需要提供的[TLS版本](http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html)和[密码套件](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html)。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。\n&emsp;&emsp;安全和连接规范具体是由[ConnectionSpec](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html)实现的。OKHttp包含三个内置的规范：\n * `MODERN_TLS` 是连接现代HTTPS服务器的配置。\n * `COMPATIBLE_TLS` 是连接非现代，但安全的HTTPS服务器的配置。\n * `CLEARTEXT` 是非安全的http的配置。\n\n&emsp;&emsp;默认OKHttp会尝试使用`MODERN_TLS`连接，如果现代配置失败，回到使用`COMPATIBLE_TLS`配置。\n&emsp;&emsp;TLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为[POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了[RC4](http://en.wikipedia.org/wiki/RC4#Security)的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。\n&emsp;&emsp;也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。\n```\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  \n    .tlsVersions(TlsVersion.TLS_1_2)\n    .cipherSuites(\n          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)\n    .build();\n\nOkHttpClient client = new OkHttpClient.Builder() \n    .connectionSpecs(Collections.singletonList(spec))\n    .build();\n```\n#### 证书锁定\n&emsp;&emsp;默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如[2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html)。同样也假设你的证书是权威机构颁发的。\n&emsp;&emsp;使用[CertificatePinner](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html)限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。**在没的到服务端团队的许可的时候不要使用证书锁定**。\n```\n  public CertificatePinning() {\n    client = new OkHttpClient.Builder()\n        .certificatePinner(new CertificatePinner.Builder()\n            .add(\"publicobject.com\", \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\")\n            .build())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/robots.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    for (Certificate certificate : response.handshake().peerCertificates()) {\n      System.out.println(CertificatePinner.pin(certificate));\n    }\n  }\n```\n#### 定制信任证书\n&emsp;&emsp;下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，**在没的到服务端团队的许可的时候不要使用定制证书*。\n```\n  private final OkHttpClient client;\n\n  public CustomTrust() {\n    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());\n    client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/helloworld.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    System.out.println(response.body().string());\n  }\n\n  private InputStream trustedCertificatesInputStream() {\n    ... // Full source omitted. See sample.\n  }\n\n  public SSLContext sslContextForTrustedCertificates(InputStream in) {\n    ... // Full source omitted. See sample.\n  }\n```","source":"_posts/okhttp/https.md","raw":"title: OKHttp https\ndate: 2017-03-23 13:32:29\ntags:\n    - Translate\n    - Java\n    - OKHttp\n    - HTTP\n---\n\n[原文链接](https://github.com/square/okhttp/wiki/HTTPS)\n\n&emsp;&emsp;OKHttp尝试平衡两个相互矛盾的内容：\n * 连接尽可能多的主机。包括使用[boringssl](https://boringssl.googlesource.com/boringssl/)的高级的主机和一些使用[openssl](https://www.openssl.org/)的过时的主机。\n * 连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。\n\n&emsp;&emsp;协商连接到HTTPS的时候，OKHttp需要知道需要提供的[TLS版本](http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html)和[密码套件](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html)。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。\n&emsp;&emsp;安全和连接规范具体是由[ConnectionSpec](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html)实现的。OKHttp包含三个内置的规范：\n * `MODERN_TLS` 是连接现代HTTPS服务器的配置。\n * `COMPATIBLE_TLS` 是连接非现代，但安全的HTTPS服务器的配置。\n * `CLEARTEXT` 是非安全的http的配置。\n\n&emsp;&emsp;默认OKHttp会尝试使用`MODERN_TLS`连接，如果现代配置失败，回到使用`COMPATIBLE_TLS`配置。\n&emsp;&emsp;TLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为[POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了[RC4](http://en.wikipedia.org/wiki/RC4#Security)的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。\n&emsp;&emsp;也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。\n```\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  \n    .tlsVersions(TlsVersion.TLS_1_2)\n    .cipherSuites(\n          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)\n    .build();\n\nOkHttpClient client = new OkHttpClient.Builder() \n    .connectionSpecs(Collections.singletonList(spec))\n    .build();\n```\n#### 证书锁定\n&emsp;&emsp;默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如[2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html)。同样也假设你的证书是权威机构颁发的。\n&emsp;&emsp;使用[CertificatePinner](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html)限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。**在没的到服务端团队的许可的时候不要使用证书锁定**。\n```\n  public CertificatePinning() {\n    client = new OkHttpClient.Builder()\n        .certificatePinner(new CertificatePinner.Builder()\n            .add(\"publicobject.com\", \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\")\n            .build())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/robots.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    for (Certificate certificate : response.handshake().peerCertificates()) {\n      System.out.println(CertificatePinner.pin(certificate));\n    }\n  }\n```\n#### 定制信任证书\n&emsp;&emsp;下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，**在没的到服务端团队的许可的时候不要使用定制证书*。\n```\n  private final OkHttpClient client;\n\n  public CustomTrust() {\n    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());\n    client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/helloworld.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    System.out.println(response.body().string());\n  }\n\n  private InputStream trustedCertificatesInputStream() {\n    ... // Full source omitted. See sample.\n  }\n\n  public SSLContext sslContextForTrustedCertificates(InputStream in) {\n    ... // Full source omitted. See sample.\n  }\n```","slug":"okhttp/https","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds88002emart1bn6zk5m","content":"<p><a href=\"https://github.com/square/okhttp/wiki/HTTPS\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>&emsp;&emsp;OKHttp尝试平衡两个相互矛盾的内容：</p>\n<ul>\n<li>连接尽可能多的主机。包括使用<a href=\"https://boringssl.googlesource.com/boringssl/\" target=\"_blank\" rel=\"noopener\">boringssl</a>的高级的主机和一些使用<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener\">openssl</a>的过时的主机。</li>\n<li>连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。</li>\n</ul>\n<p>&emsp;&emsp;协商连接到HTTPS的时候，OKHttp需要知道需要提供的<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html\" target=\"_blank\" rel=\"noopener\">TLS版本</a>和<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html\" target=\"_blank\" rel=\"noopener\">密码套件</a>。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。<br>&emsp;&emsp;安全和连接规范具体是由<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html\" target=\"_blank\" rel=\"noopener\">ConnectionSpec</a>实现的。OKHttp包含三个内置的规范：</p>\n<ul>\n<li><code>MODERN_TLS</code> 是连接现代HTTPS服务器的配置。</li>\n<li><code>COMPATIBLE_TLS</code> 是连接非现代，但安全的HTTPS服务器的配置。</li>\n<li><code>CLEARTEXT</code> 是非安全的http的配置。</li>\n</ul>\n<p>&emsp;&emsp;默认OKHttp会尝试使用<code>MODERN_TLS</code>连接，如果现代配置失败，回到使用<code>COMPATIBLE_TLS</code>配置。<br>&emsp;&emsp;TLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为<a href=\"http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html\" target=\"_blank\" rel=\"noopener\">POODLE</a>攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了<a href=\"http://en.wikipedia.org/wiki/RC4#Security\" target=\"_blank\" rel=\"noopener\">RC4</a>的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。<br>&emsp;&emsp;也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </span><br><span class=\"line\">    .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class=\"line\">    .cipherSuites(</span><br><span class=\"line\">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class=\"line\">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class=\"line\">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder() </span><br><span class=\"line\">    .connectionSpecs(Collections.singletonList(spec))</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"证书锁定\"><a href=\"#证书锁定\" class=\"headerlink\" title=\"证书锁定\"></a>证书锁定</h4><p>&emsp;&emsp;默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如<a href=\"http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html\" target=\"_blank\" rel=\"noopener\">2011 DigiNotar attack</a>。同样也假设你的证书是权威机构颁发的。<br>&emsp;&emsp;使用<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html\" target=\"_blank\" rel=\"noopener\">CertificatePinner</a>限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。<strong>在没的到服务端团队的许可的时候不要使用证书锁定</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CertificatePinning() &#123;</span><br><span class=\"line\">  client = new OkHttpClient.Builder()</span><br><span class=\"line\">      .certificatePinner(new CertificatePinner.Builder()</span><br><span class=\"line\">          .add(&quot;publicobject.com&quot;, &quot;sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=&quot;)</span><br><span class=\"line\">          .build())</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">  Request request = new Request.Builder()</span><br><span class=\"line\">      .url(&quot;https://publicobject.com/robots.txt&quot;)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\"></span><br><span class=\"line\">  Response response = client.newCall(request).execute();</span><br><span class=\"line\">  if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (Certificate certificate : response.handshake().peerCertificates()) &#123;</span><br><span class=\"line\">    System.out.println(CertificatePinner.pin(certificate));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定制信任证书\"><a href=\"#定制信任证书\" class=\"headerlink\" title=\"定制信任证书\"></a>定制信任证书</h4><p>&emsp;&emsp;下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，*<em>在没的到服务端团队的许可的时候不要使用定制证书</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public CustomTrust() &#123;</span><br><span class=\"line\">  SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</span><br><span class=\"line\">  client = new OkHttpClient.Builder()</span><br><span class=\"line\">      .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">  Request request = new Request.Builder()</span><br><span class=\"line\">      .url(&quot;https://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\"></span><br><span class=\"line\">  Response response = client.newCall(request).execute();</span><br><span class=\"line\">  System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private InputStream trustedCertificatesInputStream() &#123;</span><br><span class=\"line\">  ... // Full source omitted. See sample.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public SSLContext sslContextForTrustedCertificates(InputStream in) &#123;</span><br><span class=\"line\">  ... // Full source omitted. See sample.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/square/okhttp/wiki/HTTPS\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>&emsp;&emsp;OKHttp尝试平衡两个相互矛盾的内容：</p>\n<ul>\n<li>连接尽可能多的主机。包括使用<a href=\"https://boringssl.googlesource.com/boringssl/\" target=\"_blank\" rel=\"noopener\">boringssl</a>的高级的主机和一些使用<a href=\"https://www.openssl.org/\" target=\"_blank\" rel=\"noopener\">openssl</a>的过时的主机。</li>\n<li>连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。</li>\n</ul>\n<p>&emsp;&emsp;协商连接到HTTPS的时候，OKHttp需要知道需要提供的<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html\" target=\"_blank\" rel=\"noopener\">TLS版本</a>和<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html\" target=\"_blank\" rel=\"noopener\">密码套件</a>。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。<br>&emsp;&emsp;安全和连接规范具体是由<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html\" target=\"_blank\" rel=\"noopener\">ConnectionSpec</a>实现的。OKHttp包含三个内置的规范：</p>\n<ul>\n<li><code>MODERN_TLS</code> 是连接现代HTTPS服务器的配置。</li>\n<li><code>COMPATIBLE_TLS</code> 是连接非现代，但安全的HTTPS服务器的配置。</li>\n<li><code>CLEARTEXT</code> 是非安全的http的配置。</li>\n</ul>\n<p>&emsp;&emsp;默认OKHttp会尝试使用<code>MODERN_TLS</code>连接，如果现代配置失败，回到使用<code>COMPATIBLE_TLS</code>配置。<br>&emsp;&emsp;TLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为<a href=\"http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html\" target=\"_blank\" rel=\"noopener\">POODLE</a>攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了<a href=\"http://en.wikipedia.org/wiki/RC4#Security\" target=\"_blank\" rel=\"noopener\">RC4</a>的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。<br>&emsp;&emsp;也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </span><br><span class=\"line\">    .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class=\"line\">    .cipherSuites(</span><br><span class=\"line\">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class=\"line\">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class=\"line\">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder() </span><br><span class=\"line\">    .connectionSpecs(Collections.singletonList(spec))</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"证书锁定\"><a href=\"#证书锁定\" class=\"headerlink\" title=\"证书锁定\"></a>证书锁定</h4><p>&emsp;&emsp;默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如<a href=\"http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html\" target=\"_blank\" rel=\"noopener\">2011 DigiNotar attack</a>。同样也假设你的证书是权威机构颁发的。<br>&emsp;&emsp;使用<a href=\"http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html\" target=\"_blank\" rel=\"noopener\">CertificatePinner</a>限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。<strong>在没的到服务端团队的许可的时候不要使用证书锁定</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public CertificatePinning() &#123;</span><br><span class=\"line\">  client = new OkHttpClient.Builder()</span><br><span class=\"line\">      .certificatePinner(new CertificatePinner.Builder()</span><br><span class=\"line\">          .add(&quot;publicobject.com&quot;, &quot;sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=&quot;)</span><br><span class=\"line\">          .build())</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">  Request request = new Request.Builder()</span><br><span class=\"line\">      .url(&quot;https://publicobject.com/robots.txt&quot;)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\"></span><br><span class=\"line\">  Response response = client.newCall(request).execute();</span><br><span class=\"line\">  if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class=\"line\"></span><br><span class=\"line\">  for (Certificate certificate : response.handshake().peerCertificates()) &#123;</span><br><span class=\"line\">    System.out.println(CertificatePinner.pin(certificate));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定制信任证书\"><a href=\"#定制信任证书\" class=\"headerlink\" title=\"定制信任证书\"></a>定制信任证书</h4><p>&emsp;&emsp;下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，*<em>在没的到服务端团队的许可的时候不要使用定制证书</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final OkHttpClient client;</span><br><span class=\"line\"></span><br><span class=\"line\">public CustomTrust() &#123;</span><br><span class=\"line\">  SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</span><br><span class=\"line\">  client = new OkHttpClient.Builder()</span><br><span class=\"line\">      .sslSocketFactory(sslContext.getSocketFactory())</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void run() throws Exception &#123;</span><br><span class=\"line\">  Request request = new Request.Builder()</span><br><span class=\"line\">      .url(&quot;https://publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\"></span><br><span class=\"line\">  Response response = client.newCall(request).execute();</span><br><span class=\"line\">  System.out.println(response.body().string());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private InputStream trustedCertificatesInputStream() &#123;</span><br><span class=\"line\">  ... // Full source omitted. See sample.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public SSLContext sslContextForTrustedCertificates(InputStream in) &#123;</span><br><span class=\"line\">  ... // Full source omitted. See sample.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"OKHttp 拦截器","date":"2017-03-19T07:47:42.000Z","_content":"\n[原文地址](https://github.com/square/okhttp/wiki/Interceptors)\n&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。\n```\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n\n    long t1 = System.nanoTime();\n    logger.info(String.format(\"Sending request %s on %s%n%s\",\n        request.url(), chain.connection(), request.headers()));\n\n    Response response = chain.proceed(request);\n\n    long t2 = System.nanoTime();\n    logger.info(String.format(\"Received response for %s in %.1fms%n%s\",\n        response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n    return response;\n  }\n}\n```\n&emsp;&emsp;调用`chain.proceed(request)`是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。\n&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。\n![Interceptors](https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png)\n#### 应用拦截器\n&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的`LoggingInterceptor`来展示这两者的不同。\n&emsp;&emsp;通过调用`OkHttpClient.Builder`的`addInterceptor()`来注册一个应用拦截器。\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n&emsp;&emsp;链接`http://www.publicobject.com/helloworld.txt`重定向到链接`http://www.publicobject.com/helloworld.txt`,OKHttp回自动重定向。应用拦截器只会被调用一次。`chain.proceed()`返回的响应是重定向之后的响应。\n```\nINFO: Sending request http://www.publicobject.com/helloworld.txt on null\nUser-Agent: OkHttp Example\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n&emsp;&emsp;因为`response.request().url()`和`request.url()`获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。\n#### 网络拦截器\n&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用`addNetworkInterceptor()`代替了`addInterceptor()`。\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .addNetworkInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址`http://www.publicobject.com/helloworld.txt`，一次是重定向的地址`https://publicobject.com/helloworld.txt`。\n```\nINFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: www.publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/html\nContent-Length: 193\nConnection: keep-alive\nLocation: https://publicobject.com/helloworld.txt\n\nINFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的`Accept-Encoding: gzip`header。网络拦截器的`chain`有一个非空的`Connection`，用来查询连接服务器的IP地址和TLS配置信息。\n#### 如何选择拦截器\n&emsp;&emsp;每种拦截器都有优点。\n##### 应用拦截器\n * 无需关心像重试，重定向等这样的中间过程。\n * 即使是从缓存响应，也会调用一次。\n * 只关心应用最初的目的，并不需要关心OKHttp注入的header，例如`If-None-Match`\n * 允许短路，不执行`Chain.proceed()`\n * 允许重试，执行多次`Chain.proceed()`\n##### 网络拦截器\n * 可以操作想重试，重定向这样的中间过程。\n * 短路网络连接的从cache返回响应的时候不执行。\n * 可以监控呗发送到网络上的数据\n * 访问包含request的`Connection`\n#### 重写请求\n&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。\n```\n/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */\nfinal class GzipRequestInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request originalRequest = chain.request();\n    if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) {\n      return chain.proceed(originalRequest);\n    }\n\n    Request compressedRequest = originalRequest.newBuilder()\n        .header(\"Content-Encoding\", \"gzip\")\n        .method(originalRequest.method(), gzip(originalRequest.body()))\n        .build();\n    return chain.proceed(compressedRequest);\n  }\n\n  private RequestBody gzip(final RequestBody body) {\n    return new RequestBody() {\n      @Override public MediaType contentType() {\n        return body.contentType();\n      }\n\n      @Override public long contentLength() {\n        return -1; // We don't know the compressed length in advance!\n      }\n\n      @Override public void writeTo(BufferedSink sink) throws IOException {\n        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));\n        body.writeTo(gzipSink);\n        gzipSink.close();\n      }\n    };\n  }\n}\n```\n#### 重写响应\n&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。\n&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的`Cache-Control`来获取更好的缓存响应配置。\n```\n/** Dangerous interceptor that rewrites the server's cache-control header. */\nprivate static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Response originalResponse = chain.proceed(chain.request());\n    return originalResponse.newBuilder()\n        .header(\"Cache-Control\", \"max-age=60\")\n        .build();\n  }\n};\n```\n&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。\n#### 那些可以使用拦截器\n&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和`OkUrlFactory`，或者依赖于他的库同时使用，包括[Retrofit](http://square.github.io/retrofit/)1.8以下，[Picasso](http://square.github.io/picasso/)2.4以下。","source":"_posts/okhttp/interceptors.md","raw":"title: OKHttp 拦截器\ndate: 2017-03-19 15:47:42\ntags:\n    - Translate\n    - Java\n    - OKHttp\n    - HTTP\n---\n\n[原文地址](https://github.com/square/okhttp/wiki/Interceptors)\n&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。\n```\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n\n    long t1 = System.nanoTime();\n    logger.info(String.format(\"Sending request %s on %s%n%s\",\n        request.url(), chain.connection(), request.headers()));\n\n    Response response = chain.proceed(request);\n\n    long t2 = System.nanoTime();\n    logger.info(String.format(\"Received response for %s in %.1fms%n%s\",\n        response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n    return response;\n  }\n}\n```\n&emsp;&emsp;调用`chain.proceed(request)`是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。\n&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。\n![Interceptors](https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png)\n#### 应用拦截器\n&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的`LoggingInterceptor`来展示这两者的不同。\n&emsp;&emsp;通过调用`OkHttpClient.Builder`的`addInterceptor()`来注册一个应用拦截器。\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n&emsp;&emsp;链接`http://www.publicobject.com/helloworld.txt`重定向到链接`http://www.publicobject.com/helloworld.txt`,OKHttp回自动重定向。应用拦截器只会被调用一次。`chain.proceed()`返回的响应是重定向之后的响应。\n```\nINFO: Sending request http://www.publicobject.com/helloworld.txt on null\nUser-Agent: OkHttp Example\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n&emsp;&emsp;因为`response.request().url()`和`request.url()`获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。\n#### 网络拦截器\n&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用`addNetworkInterceptor()`代替了`addInterceptor()`。\n```\nOkHttpClient client = new OkHttpClient.Builder()\n    .addNetworkInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址`http://www.publicobject.com/helloworld.txt`，一次是重定向的地址`https://publicobject.com/helloworld.txt`。\n```\nINFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: www.publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/html\nContent-Length: 193\nConnection: keep-alive\nLocation: https://publicobject.com/helloworld.txt\n\nINFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的`Accept-Encoding: gzip`header。网络拦截器的`chain`有一个非空的`Connection`，用来查询连接服务器的IP地址和TLS配置信息。\n#### 如何选择拦截器\n&emsp;&emsp;每种拦截器都有优点。\n##### 应用拦截器\n * 无需关心像重试，重定向等这样的中间过程。\n * 即使是从缓存响应，也会调用一次。\n * 只关心应用最初的目的，并不需要关心OKHttp注入的header，例如`If-None-Match`\n * 允许短路，不执行`Chain.proceed()`\n * 允许重试，执行多次`Chain.proceed()`\n##### 网络拦截器\n * 可以操作想重试，重定向这样的中间过程。\n * 短路网络连接的从cache返回响应的时候不执行。\n * 可以监控呗发送到网络上的数据\n * 访问包含request的`Connection`\n#### 重写请求\n&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。\n```\n/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */\nfinal class GzipRequestInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request originalRequest = chain.request();\n    if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) {\n      return chain.proceed(originalRequest);\n    }\n\n    Request compressedRequest = originalRequest.newBuilder()\n        .header(\"Content-Encoding\", \"gzip\")\n        .method(originalRequest.method(), gzip(originalRequest.body()))\n        .build();\n    return chain.proceed(compressedRequest);\n  }\n\n  private RequestBody gzip(final RequestBody body) {\n    return new RequestBody() {\n      @Override public MediaType contentType() {\n        return body.contentType();\n      }\n\n      @Override public long contentLength() {\n        return -1; // We don't know the compressed length in advance!\n      }\n\n      @Override public void writeTo(BufferedSink sink) throws IOException {\n        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));\n        body.writeTo(gzipSink);\n        gzipSink.close();\n      }\n    };\n  }\n}\n```\n#### 重写响应\n&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。\n&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的`Cache-Control`来获取更好的缓存响应配置。\n```\n/** Dangerous interceptor that rewrites the server's cache-control header. */\nprivate static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Response originalResponse = chain.proceed(chain.request());\n    return originalResponse.newBuilder()\n        .header(\"Cache-Control\", \"max-age=60\")\n        .build();\n  }\n};\n```\n&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。\n#### 那些可以使用拦截器\n&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和`OkUrlFactory`，或者依赖于他的库同时使用，包括[Retrofit](http://square.github.io/retrofit/)1.8以下，[Picasso](http://square.github.io/picasso/)2.4以下。","slug":"okhttp/interceptors","published":1,"updated":"2018-03-31T15:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfo2ds89002fmart5uug4afd","content":"<p><a href=\"https://github.com/square/okhttp/wiki/Interceptors\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class LoggingInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    long t1 = System.nanoTime();</span><br><span class=\"line\">    logger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,</span><br><span class=\"line\">        request.url(), chain.connection(), request.headers()));</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    long t2 = System.nanoTime();</span><br><span class=\"line\">    logger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,</span><br><span class=\"line\">        response.request().url(), (t2 - t1) / 1e6d, response.headers()));</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;调用<code>chain.proceed(request)</code>是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。<br>&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。<br><img src=\"https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png\" alt=\"Interceptors\"></p>\n<h4 id=\"应用拦截器\"><a href=\"#应用拦截器\" class=\"headerlink\" title=\"应用拦截器\"></a>应用拦截器</h4><p>&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的<code>LoggingInterceptor</code>来展示这两者的不同。<br>&emsp;&emsp;通过调用<code>OkHttpClient.Builder</code>的<code>addInterceptor()</code>来注册一个应用拦截器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .addInterceptor(new LoggingInterceptor())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">response.body().close();</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;链接<code>http://www.publicobject.com/helloworld.txt</code>重定向到链接<code>http://www.publicobject.com/helloworld.txt</code>,OKHttp回自动重定向。应用拦截器只会被调用一次。<code>chain.proceed()</code>返回的响应是重定向之后的响应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Sending request http://www.publicobject.com/helloworld.txt on null</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Content-Length: 1759</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;因为<code>response.request().url()</code>和<code>request.url()</code>获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。</p>\n<h4 id=\"网络拦截器\"><a href=\"#网络拦截器\" class=\"headerlink\" title=\"网络拦截器\"></a>网络拦截器</h4><p>&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用<code>addNetworkInterceptor()</code>代替了<code>addInterceptor()</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .addNetworkInterceptor(new LoggingInterceptor())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">response.body().close();</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址<code>http://www.publicobject.com/helloworld.txt</code>，一次是重定向的地址<code>https://publicobject.com/helloworld.txt</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\">Host: www.publicobject.com</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Accept-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: 193</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Location: https://publicobject.com/helloworld.txt</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\">Host: publicobject.com</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Accept-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Content-Length: 1759</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的<code>Accept-Encoding: gzip</code>header。网络拦截器的<code>chain</code>有一个非空的<code>Connection</code>，用来查询连接服务器的IP地址和TLS配置信息。</p>\n<h4 id=\"如何选择拦截器\"><a href=\"#如何选择拦截器\" class=\"headerlink\" title=\"如何选择拦截器\"></a>如何选择拦截器</h4><p>&emsp;&emsp;每种拦截器都有优点。</p>\n<h5 id=\"应用拦截器-1\"><a href=\"#应用拦截器-1\" class=\"headerlink\" title=\"应用拦截器\"></a>应用拦截器</h5><ul>\n<li>无需关心像重试，重定向等这样的中间过程。</li>\n<li>即使是从缓存响应，也会调用一次。</li>\n<li>只关心应用最初的目的，并不需要关心OKHttp注入的header，例如<code>If-None-Match</code></li>\n<li>允许短路，不执行<code>Chain.proceed()</code></li>\n<li>允许重试，执行多次<code>Chain.proceed()</code><h5 id=\"网络拦截器-1\"><a href=\"#网络拦截器-1\" class=\"headerlink\" title=\"网络拦截器\"></a>网络拦截器</h5></li>\n<li>可以操作想重试，重定向这样的中间过程。</li>\n<li>短路网络连接的从cache返回响应的时候不执行。</li>\n<li>可以监控呗发送到网络上的数据</li>\n<li>访问包含request的<code>Connection</code><h4 id=\"重写请求\"><a href=\"#重写请求\" class=\"headerlink\" title=\"重写请求\"></a>重写请求</h4>&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** This interceptor compresses the HTTP request body. Many webservers can&apos;t handle this! */</span><br><span class=\"line\">final class GzipRequestInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Request originalRequest = chain.request();</span><br><span class=\"line\">    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</span><br><span class=\"line\">      return chain.proceed(originalRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class=\"line\">        .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</span><br><span class=\"line\">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    return chain.proceed(compressedRequest);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private RequestBody gzip(final RequestBody body) &#123;</span><br><span class=\"line\">    return new RequestBody() &#123;</span><br><span class=\"line\">      @Override public MediaType contentType() &#123;</span><br><span class=\"line\">        return body.contentType();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public long contentLength() &#123;</span><br><span class=\"line\">        return -1; // We don&apos;t know the compressed length in advance!</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class=\"line\">        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</span><br><span class=\"line\">        body.writeTo(gzipSink);</span><br><span class=\"line\">        gzipSink.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"重写响应\"><a href=\"#重写响应\" class=\"headerlink\" title=\"重写响应\"></a>重写响应</h4><p>&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。<br>&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的<code>Cache-Control</code>来获取更好的缓存响应配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Dangerous interceptor that rewrites the server&apos;s cache-control header. */</span><br><span class=\"line\">private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Response originalResponse = chain.proceed(chain.request());</span><br><span class=\"line\">    return originalResponse.newBuilder()</span><br><span class=\"line\">        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。</p>\n<h4 id=\"那些可以使用拦截器\"><a href=\"#那些可以使用拦截器\" class=\"headerlink\" title=\"那些可以使用拦截器\"></a>那些可以使用拦截器</h4><p>&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和<code>OkUrlFactory</code>，或者依赖于他的库同时使用，包括<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Retrofit</a>1.8以下，<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"noopener\">Picasso</a>2.4以下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/square/okhttp/wiki/Interceptors\" target=\"_blank\" rel=\"noopener\">原文地址</a><br>&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class LoggingInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    long t1 = System.nanoTime();</span><br><span class=\"line\">    logger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,</span><br><span class=\"line\">        request.url(), chain.connection(), request.headers()));</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    long t2 = System.nanoTime();</span><br><span class=\"line\">    logger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,</span><br><span class=\"line\">        response.request().url(), (t2 - t1) / 1e6d, response.headers()));</span><br><span class=\"line\"></span><br><span class=\"line\">    return response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;调用<code>chain.proceed(request)</code>是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。<br>&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。<br><img src=\"https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png\" alt=\"Interceptors\"></p>\n<h4 id=\"应用拦截器\"><a href=\"#应用拦截器\" class=\"headerlink\" title=\"应用拦截器\"></a>应用拦截器</h4><p>&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的<code>LoggingInterceptor</code>来展示这两者的不同。<br>&emsp;&emsp;通过调用<code>OkHttpClient.Builder</code>的<code>addInterceptor()</code>来注册一个应用拦截器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .addInterceptor(new LoggingInterceptor())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">response.body().close();</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;链接<code>http://www.publicobject.com/helloworld.txt</code>重定向到链接<code>http://www.publicobject.com/helloworld.txt</code>,OKHttp回自动重定向。应用拦截器只会被调用一次。<code>chain.proceed()</code>返回的响应是重定向之后的响应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Sending request http://www.publicobject.com/helloworld.txt on null</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Content-Length: 1759</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;因为<code>response.request().url()</code>和<code>request.url()</code>获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。</p>\n<h4 id=\"网络拦截器\"><a href=\"#网络拦截器\" class=\"headerlink\" title=\"网络拦截器\"></a>网络拦截器</h4><p>&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用<code>addNetworkInterceptor()</code>代替了<code>addInterceptor()</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class=\"line\">    .addNetworkInterceptor(new LoggingInterceptor())</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Request request = new Request.Builder()</span><br><span class=\"line\">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</span><br><span class=\"line\">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\">Response response = client.newCall(request).execute();</span><br><span class=\"line\">response.body().close();</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址<code>http://www.publicobject.com/helloworld.txt</code>，一次是重定向的地址<code>https://publicobject.com/helloworld.txt</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\">Host: www.publicobject.com</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Accept-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: 193</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Location: https://publicobject.com/helloworld.txt</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</span><br><span class=\"line\">User-Agent: OkHttp Example</span><br><span class=\"line\">Host: publicobject.com</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Accept-Encoding: gzip</span><br><span class=\"line\"></span><br><span class=\"line\">INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms</span><br><span class=\"line\">Server: nginx/1.4.6 (Ubuntu)</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\">Content-Length: 1759</span><br><span class=\"line\">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的<code>Accept-Encoding: gzip</code>header。网络拦截器的<code>chain</code>有一个非空的<code>Connection</code>，用来查询连接服务器的IP地址和TLS配置信息。</p>\n<h4 id=\"如何选择拦截器\"><a href=\"#如何选择拦截器\" class=\"headerlink\" title=\"如何选择拦截器\"></a>如何选择拦截器</h4><p>&emsp;&emsp;每种拦截器都有优点。</p>\n<h5 id=\"应用拦截器-1\"><a href=\"#应用拦截器-1\" class=\"headerlink\" title=\"应用拦截器\"></a>应用拦截器</h5><ul>\n<li>无需关心像重试，重定向等这样的中间过程。</li>\n<li>即使是从缓存响应，也会调用一次。</li>\n<li>只关心应用最初的目的，并不需要关心OKHttp注入的header，例如<code>If-None-Match</code></li>\n<li>允许短路，不执行<code>Chain.proceed()</code></li>\n<li>允许重试，执行多次<code>Chain.proceed()</code><h5 id=\"网络拦截器-1\"><a href=\"#网络拦截器-1\" class=\"headerlink\" title=\"网络拦截器\"></a>网络拦截器</h5></li>\n<li>可以操作想重试，重定向这样的中间过程。</li>\n<li>短路网络连接的从cache返回响应的时候不执行。</li>\n<li>可以监控呗发送到网络上的数据</li>\n<li>访问包含request的<code>Connection</code><h4 id=\"重写请求\"><a href=\"#重写请求\" class=\"headerlink\" title=\"重写请求\"></a>重写请求</h4>&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** This interceptor compresses the HTTP request body. Many webservers can&apos;t handle this! */</span><br><span class=\"line\">final class GzipRequestInterceptor implements Interceptor &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Request originalRequest = chain.request();</span><br><span class=\"line\">    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</span><br><span class=\"line\">      return chain.proceed(originalRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class=\"line\">        .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</span><br><span class=\"line\">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    return chain.proceed(compressedRequest);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  private RequestBody gzip(final RequestBody body) &#123;</span><br><span class=\"line\">    return new RequestBody() &#123;</span><br><span class=\"line\">      @Override public MediaType contentType() &#123;</span><br><span class=\"line\">        return body.contentType();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public long contentLength() &#123;</span><br><span class=\"line\">        return -1; // We don&apos;t know the compressed length in advance!</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</span><br><span class=\"line\">        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</span><br><span class=\"line\">        body.writeTo(gzipSink);</span><br><span class=\"line\">        gzipSink.close();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"重写响应\"><a href=\"#重写响应\" class=\"headerlink\" title=\"重写响应\"></a>重写响应</h4><p>&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。<br>&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的<code>Cache-Control</code>来获取更好的缓存响应配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** Dangerous interceptor that rewrites the server&apos;s cache-control header. */</span><br><span class=\"line\">private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123;</span><br><span class=\"line\">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</span><br><span class=\"line\">    Response originalResponse = chain.proceed(chain.request());</span><br><span class=\"line\">    return originalResponse.newBuilder()</span><br><span class=\"line\">        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。</p>\n<h4 id=\"那些可以使用拦截器\"><a href=\"#那些可以使用拦截器\" class=\"headerlink\" title=\"那些可以使用拦截器\"></a>那些可以使用拦截器</h4><p>&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和<code>OkUrlFactory</code>，或者依赖于他的库同时使用，包括<a href=\"http://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Retrofit</a>1.8以下，<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"noopener\">Picasso</a>2.4以下。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjfo2ds530000mart7ppg4upx","tag_id":"cjfo2ds5g0004martpidl3wqb","_id":"cjfo2ds61000dmarth4k42x1d"},{"post_id":"cjfo2ds530000mart7ppg4upx","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds63000fmartfrq663js"},{"post_id":"cjfo2ds5b0002martvp1f2fix","tag_id":"cjfo2ds5x000bmart7wzxultx","_id":"cjfo2ds6b000lmarthamvixo0"},{"post_id":"cjfo2ds5b0002martvp1f2fix","tag_id":"cjfo2ds64000gmartiq1gtsrn","_id":"cjfo2ds6d000nmarto6zkf8jq"},{"post_id":"cjfo2ds5j0005martgvaiov6r","tag_id":"cjfo2ds6a000jmart512ufv94","_id":"cjfo2ds6h000rmartlorfxa1q"},{"post_id":"cjfo2ds5j0005martgvaiov6r","tag_id":"cjfo2ds6e000omart7zw4cziz","_id":"cjfo2ds6i000smart368lttf1"},{"post_id":"cjfo2ds5j0005martgvaiov6r","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6i000umartpsqk7qgh"},{"post_id":"cjfo2ds5n0006mart0cmmumlz","tag_id":"cjfo2ds6h000qmartq2cey3b1","_id":"cjfo2ds6k000xmartthn7pa88"},{"post_id":"cjfo2ds5n0006mart0cmmumlz","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6l000ymartkidt8i6s"},{"post_id":"cjfo2ds5n0006mart0cmmumlz","tag_id":"cjfo2ds6a000jmart512ufv94","_id":"cjfo2ds6l0010martgijuymfu"},{"post_id":"cjfo2ds5q0007martzqfjbvki","tag_id":"cjfo2ds5g0004martpidl3wqb","_id":"cjfo2ds6m0012martcw1cyc4x"},{"post_id":"cjfo2ds5q0007martzqfjbvki","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6m0013martsr7n0me9"},{"post_id":"cjfo2ds5q0007martzqfjbvki","tag_id":"cjfo2ds6l000zmartogqxjkx8","_id":"cjfo2ds6n0015martef0r8hu1"},{"post_id":"cjfo2ds5t0009mart1fz1gv3b","tag_id":"cjfo2ds6l000zmartogqxjkx8","_id":"cjfo2ds6n0016martdrqndmya"},{"post_id":"cjfo2ds5t0009mart1fz1gv3b","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6o0018martiy5ox05c"},{"post_id":"cjfo2ds5v000amarttqg5nlt6","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds6p001amartiryz4nvn"},{"post_id":"cjfo2ds5v000amarttqg5nlt6","tag_id":"cjfo2ds6o0017martwvi91qfa","_id":"cjfo2ds6q001bmartfluqplt3"},{"post_id":"cjfo2ds5v000amarttqg5nlt6","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6q001dmartgx9ovzdu"},{"post_id":"cjfo2ds5y000cmartzfk9jkpb","tag_id":"cjfo2ds6p0019mart3zt73g7n","_id":"cjfo2ds6s001gmarta1aiopm3"},{"post_id":"cjfo2ds5y000cmartzfk9jkpb","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds6s001hmart214ucmx9"},{"post_id":"cjfo2ds5y000cmartzfk9jkpb","tag_id":"cjfo2ds6r001emart7j9fyp2f","_id":"cjfo2ds6t001jmartnqdjqaz8"},{"post_id":"cjfo2ds62000emartsc1yfgl1","tag_id":"cjfo2ds6a000jmart512ufv94","_id":"cjfo2ds6t001kmartp3yh1q7r"},{"post_id":"cjfo2ds62000emartsc1yfgl1","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6t001mmartizqg3t0j"},{"post_id":"cjfo2ds64000hmart49n8v13h","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds6u001omarte3q711rr"},{"post_id":"cjfo2ds64000hmart49n8v13h","tag_id":"cjfo2ds6t001lmartf1ft4t82","_id":"cjfo2ds6u001pmart4z3pa8vz"},{"post_id":"cjfo2ds64000hmart49n8v13h","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6v001rmart8wyfmip3"},{"post_id":"cjfo2ds68000imartn2mlxbr4","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds6w001umart7hjirbxf"},{"post_id":"cjfo2ds68000imartn2mlxbr4","tag_id":"cjfo2ds6a000jmart512ufv94","_id":"cjfo2ds6x001vmart0oirxm7o"},{"post_id":"cjfo2ds68000imartn2mlxbr4","tag_id":"cjfo2ds6v001smart4rivkf4t","_id":"cjfo2ds6x001xmartqbsuf93j"},{"post_id":"cjfo2ds6a000kmart7cse68c4","tag_id":"cjfo2ds6a000jmart512ufv94","_id":"cjfo2ds6x001ymartq75hbmjv"},{"post_id":"cjfo2ds6a000kmart7cse68c4","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds6y0020mart6x7se0jj"},{"post_id":"cjfo2ds6c000mmartjwnj65io","tag_id":"cjfo2ds6x001wmartbprnzwie","_id":"cjfo2ds700022mart1t1bect8"},{"post_id":"cjfo2ds6c000mmartjwnj65io","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds700023martq6fl4gpr"},{"post_id":"cjfo2ds6c000mmartjwnj65io","tag_id":"cjfo2ds6z0021mart4cysv2nv","_id":"cjfo2ds700024marte1ovii86"},{"post_id":"cjfo2ds6c000mmartjwnj65io","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds700025mart4xrlcrd6"},{"post_id":"cjfo2ds7t0026martd24x5hjw","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds800028martqjlnwwcz"},{"post_id":"cjfo2ds7t0026martd24x5hjw","tag_id":"cjfo2ds6t001lmartf1ft4t82","_id":"cjfo2ds85002bmartkkrdk8bp"},{"post_id":"cjfo2ds7t0026martd24x5hjw","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds88002dmartyvslrsqp"},{"post_id":"cjfo2ds88002emart1bn6zk5m","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds8c002hmartxk8ku1p5"},{"post_id":"cjfo2ds88002emart1bn6zk5m","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds8d002imart6m6cjbeq"},{"post_id":"cjfo2ds88002emart1bn6zk5m","tag_id":"cjfo2ds85002amartgwhkinz5","_id":"cjfo2ds8e002kmartpie6qb67"},{"post_id":"cjfo2ds88002emart1bn6zk5m","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds8e002lmarttpzape3u"},{"post_id":"cjfo2ds7w0027martptqy36jf","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds8f002mmartx3um6v7z"},{"post_id":"cjfo2ds7w0027martptqy36jf","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds8f002nmart03e2pu54"},{"post_id":"cjfo2ds7w0027martptqy36jf","tag_id":"cjfo2ds85002amartgwhkinz5","_id":"cjfo2ds8f002omart3oij4w0v"},{"post_id":"cjfo2ds7w0027martptqy36jf","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds8f002pmartkar6iu0u"},{"post_id":"cjfo2ds89002fmart5uug4afd","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds8g002qmartly0ka6v4"},{"post_id":"cjfo2ds89002fmart5uug4afd","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds8g002rmartc8ode7qa"},{"post_id":"cjfo2ds89002fmart5uug4afd","tag_id":"cjfo2ds85002amartgwhkinz5","_id":"cjfo2ds8g002smart6sh2scnt"},{"post_id":"cjfo2ds89002fmart5uug4afd","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds8g002tmartbk59octk"},{"post_id":"cjfo2ds810029mart3qsqwrox","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds8g002umartv6owf2eb"},{"post_id":"cjfo2ds810029mart3qsqwrox","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds8g002vmartyysbwddy"},{"post_id":"cjfo2ds810029mart3qsqwrox","tag_id":"cjfo2ds85002amartgwhkinz5","_id":"cjfo2ds8g002wmartqsrpgc15"},{"post_id":"cjfo2ds810029mart3qsqwrox","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds8g002xmartbd1nghvh"},{"post_id":"cjfo2ds85002cmartb3h6zkw4","tag_id":"cjfo2ds85002amartgwhkinz5","_id":"cjfo2ds8g002ymartz114ia7d"},{"post_id":"cjfo2ds85002cmartb3h6zkw4","tag_id":"cjfo2ds5r0008martacaxl43l","_id":"cjfo2ds8h002zmarthdzdldgv"},{"post_id":"cjfo2ds85002cmartb3h6zkw4","tag_id":"cjfo2ds6n0014martfhb71ml7","_id":"cjfo2ds8h0030mart0jo1gf1a"},{"post_id":"cjfo2ds85002cmartb3h6zkw4","tag_id":"cjfo2ds6u001nmartfa03n8hl","_id":"cjfo2ds8h0031mart7og6rdht"}],"Tag":[{"name":"Ansible","_id":"cjfo2ds5g0004martpidl3wqb"},{"name":"Translate","_id":"cjfo2ds5r0008martacaxl43l"},{"name":"Git","_id":"cjfo2ds5x000bmart7wzxultx"},{"name":"Git分支","_id":"cjfo2ds64000gmartiq1gtsrn"},{"name":"Go","_id":"cjfo2ds6a000jmart512ufv94"},{"name":"Architecture","_id":"cjfo2ds6e000omart7zw4cziz"},{"name":"HTTP/2","_id":"cjfo2ds6h000qmartq2cey3b1"},{"name":"Vagrant","_id":"cjfo2ds6l000zmartogqxjkx8"},{"name":"Java","_id":"cjfo2ds6n0014martfhb71ml7"},{"name":"Java8","_id":"cjfo2ds6o0017martwvi91qfa"},{"name":"CPU","_id":"cjfo2ds6p0019mart3zt73g7n"},{"name":"Linux","_id":"cjfo2ds6r001emart7j9fyp2f"},{"name":"Mybatis","_id":"cjfo2ds6t001lmartf1ft4t82"},{"name":"HTTP","_id":"cjfo2ds6u001nmartfa03n8hl"},{"name":"Middleware","_id":"cjfo2ds6v001smart4rivkf4t"},{"name":"JSON","_id":"cjfo2ds6x001wmartbprnzwie"},{"name":"Jackson","_id":"cjfo2ds6z0021mart4cysv2nv"},{"name":"OKHttp","_id":"cjfo2ds85002amartgwhkinz5"}]}}